<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入理解 TypeScript | 南上康青山</title>
    <meta name="description" content="TypeScript 深入理解 TS">
    <link rel="stylesheet" href="/assets/style.a1cb9c64.css">
    <link rel="modulepreload" href="/assets/Home.4b84188e.js">
    <link rel="modulepreload" href="/assets/app.e09fd7d1.js">
    <link rel="modulepreload" href="/assets/books_typescript-deep-dive.md.7d536d5b.lean.js">
    <link rel="modulepreload" href="/assets/app.e09fd7d1.js">
    <link rel="image/x-icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="keywords" content="南上康青山, vitepress, 顾青山, blog, 博客, 狗窝, 青山">
    <meta name="baidu-site-verification" content="code-5BMDhSDgSq">
    <meta name="baidu_union_verify" content="acd0eb90461e19817cabd1140c8ffd54">
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1801e4a45f1eecdfe603fc0637120c56";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);

      // 引入谷歌,不需要可删除这段
      var hm1 = document.createElement("script");
      hm1.src = "https://www.googletagmanager.com/gtag/js?id=G-SBNLNM3Q41";
      var s1 = document.getElementsByTagName("script")[0]; 
      s1.parentNode.insertBefore(hm1, s1);
    })();

    // 谷歌加载,不需要可删除
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-SBNLNM3Q41');
  </script>
    <script type="async" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
    <meta name="keywords" content="TypeScript 深入理解 TS">
    <meta name="twitter:title" content="深入理解 TypeScript | 南上康青山">
    <meta property="og:title" content="深入理解 TypeScript | 南上康青山">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="南上康青山, back to home" data-v-675d8756 data-v-4a583abe><!----> 南上康青山</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="前端" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>前端</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/blog-build/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>博客相关</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/swagger-hub/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>SwaggerHub</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/linux/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Linux相关</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/vue/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vue</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/ast/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>AST</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/css/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>CSS</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/git/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Git</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/websocket/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>WebSocket</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/web-container/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>WebContainer</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="书籍" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>书籍</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/you-dont-know-js" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>你不知道的JavaScript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/js-advice" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>JavaScript深入系列</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/typescript-tutorial" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>TypeScript入门教程</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/books/typescript-deep-dive" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>深入理解TypeScript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/css-tricks" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>CSS揭秘</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/grokking-algorithms" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>算法图解</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/pro-git" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Pro-Git</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/docker-practice" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Docker-从入门到实践</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/everything-curl" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Everything Curl</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="算法" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>算法</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithm/leetcode" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>LeetCode</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithm/lodash" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Lodash</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="DevOps" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>DevOps</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/devops/jira" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Jira</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="其他" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>其他</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/smart-tools" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Markdown</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/computer-tech" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>计算机基础知识</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/30-seconds-of-code" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>30 seconds of code</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/vanillawebprojects" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>vanillawebprojects</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/quotations/" aria-label="摘抄语录" data-v-b8818f8c>摘抄语录 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item isExternal" href="https://github.com/QiYoe/c-blog" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="前端" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>前端</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/blog-build/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>博客相关</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/swagger-hub/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>SwaggerHub</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/linux/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Linux相关</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/vue/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vue</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/ast/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>AST</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/css/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>CSS</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/git/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Git</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/websocket/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>WebSocket</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/web-container/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>WebContainer</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="书籍" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>书籍</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/you-dont-know-js" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>你不知道的JavaScript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/js-advice" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>JavaScript深入系列</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/typescript-tutorial" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>TypeScript入门教程</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/books/typescript-deep-dive" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>深入理解TypeScript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/css-tricks" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>CSS揭秘</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/grokking-algorithms" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>算法图解</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/pro-git" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Pro-Git</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/docker-practice" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Docker-从入门到实践</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/everything-curl" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Everything Curl</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="算法" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>算法</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithm/leetcode" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>LeetCode</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithm/lodash" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Lodash</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="DevOps" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>DevOps</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/devops/jira" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Jira</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="其他" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>其他</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/smart-tools" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Markdown</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/computer-tech" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>计算机基础知识</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/30-seconds-of-code" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>30 seconds of code</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/vanillawebprojects" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>vanillawebprojects</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/quotations/" aria-label="摘抄语录" data-v-b8818f8c>摘抄语录 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item isExternal" href="https://github.com/QiYoe/c-blog" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><p class="sidebar-link-item">书籍</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/books/you-dont-know-js">你不知道的JavaScript</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/js-advice">JavaScript深入系列</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/typescript-tutorial">TypeScript入门教程</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/books/typescript-deep-dive">深入理解TypeScript</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript-项目">TypeScript 项目</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#编译上下文">编译上下文</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#声明空间">声明空间</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#模块">模块</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#命名空间">命名空间</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#动态导入表达式">动态导入表达式</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript-类型系统">TypeScript 类型系统</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#概览">概览</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#从javascript-迁移">从JavaScript 迁移</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#types">@types</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#环境声明">环境声明</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#接口-1">接口</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#枚举">枚举</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#lib-d-ts">lib.d.ts</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#函数">函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#可调用的">可调用的</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型断言">类型断言</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#freshness">Freshness</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型保护">类型保护</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#字面量类型">字面量类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#readonly">readonly</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#范型-1">范型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型推断">类型推断</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型兼容性">类型兼容性</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#never">Never</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#辨析联合类型-1">辨析联合类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#索引签名">索引签名</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#流动的类型">流动的类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#异常处理">异常处理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#混合">混合</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#thistype">ThisType</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript-编译原理">TypeScript 编译原理</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#概览-1">概览</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#程序">程序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#抽象语法树">抽象语法树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#扫描器">扫描器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#解析器">解析器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#绑定器">绑定器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#检查器">检查器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#发射器">发射器</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/css-tricks">CSS揭秘</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/grokking-algorithms">算法图解</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/pro-git">Pro-Git</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/docker-practice">Docker-从入门到实践</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/everything-curl">Everything Curl</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h2 id="typescript-项目"><a class="header-anchor" href="#typescript-项目" aria-hidden="true">#</a> TypeScript 项目</h2><h3 id="编译上下文"><a class="header-anchor" href="#编译上下文" aria-hidden="true">#</a> 编译上下文</h3><p>编译上下文算是一个比较花哨的术语，可以用它来给文件分组，告诉 TypeScript 哪些文件是有效的，哪些是无效的。除了有效文件所携带信息外，编译上下文还包含有正在被使用的编译选项的信息。定义这种逻辑分组，一个比较好的方式是使用 <code>tsconfig.json</code> 文件。</p><h4 id="tsconfig-json"><a class="header-anchor" href="#tsconfig-json" aria-hidden="true">#</a> tsconfig.json</h4><h5 id="基础"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h5><p>开始使用 <code>tsconfig.json</code> 是一件比较容易的事，你仅仅需要写下：</p><div class="language-json"><pre><code><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>例如，在项目的根目录下创建一个空 JSON 文件。通过这种方式，TypeScript 将 会把此目录和子目录下的所有 .ts 文件作为编译上下文的一部分，它还会包含一部分默认的编译选项。</p><h5 id="编译选项"><a class="header-anchor" href="#编译选项" aria-hidden="true">#</a> 编译选项</h5><p>你可以通过 <code>compilerOptions</code> 来定制你的编译选项：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>

    <span class="token comment">/* 基本选项 */</span>
    <span class="token property">&quot;target&quot;</span><span class="token operator">:</span> <span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 指定 ECMAScript 目标版本: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES6&#39;/&#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, or &#39;ESNEXT&#39;</span>
    <span class="token property">&quot;module&quot;</span><span class="token operator">:</span> <span class="token string">&quot;commonjs&quot;</span><span class="token punctuation">,</span>                  <span class="token comment">// 指定使用模块: &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39; or &#39;es2015&#39;</span>
    <span class="token property">&quot;lib&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                             <span class="token comment">// 指定要包含在编译中的库文件</span>
    <span class="token property">&quot;allowJs&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                       <span class="token comment">// 允许编译 javascript 文件</span>
    <span class="token property">&quot;checkJs&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                       <span class="token comment">// 报告 javascript 文件中的错误</span>
    <span class="token property">&quot;jsx&quot;</span><span class="token operator">:</span> <span class="token string">&quot;preserve&quot;</span><span class="token punctuation">,</span>                     <span class="token comment">// 指定 jsx 代码的生成: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39;</span>
    <span class="token property">&quot;declaration&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                   <span class="token comment">// 生成相应的 &#39;.d.ts&#39; 文件</span>
    <span class="token property">&quot;sourceMap&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                     <span class="token comment">// 生成相应的 &#39;.map&#39; 文件</span>
    <span class="token property">&quot;outFile&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 将输出文件合并为一个文件</span>
    <span class="token property">&quot;outDir&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                        <span class="token comment">// 指定输出目录</span>
    <span class="token property">&quot;rootDir&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 用来控制输出目录结构 --outDir.</span>
    <span class="token property">&quot;removeComments&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                <span class="token comment">// 删除编译后的所有的注释</span>
    <span class="token property">&quot;noEmit&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        <span class="token comment">// 不生成输出文件</span>
    <span class="token property">&quot;importHelpers&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 <span class="token comment">// 从 tslib 导入辅助工具函数</span>
    <span class="token property">&quot;isolatedModules&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>               <span class="token comment">// 将每个文件作为单独的模块 （与 &#39;ts.transpileModule&#39; 类似）.</span>

    <span class="token comment">/* 严格的类型检查选项 */</span>
    <span class="token property">&quot;strict&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        <span class="token comment">// 启用所有严格类型检查选项</span>
    <span class="token property">&quot;noImplicitAny&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 <span class="token comment">// 在表达式和声明上有隐含的 any类型时报错</span>
    <span class="token property">&quot;strictNullChecks&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>              <span class="token comment">// 启用严格的 null 检查</span>
    <span class="token property">&quot;noImplicitThis&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                <span class="token comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span>
    <span class="token property">&quot;alwaysStrict&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                  <span class="token comment">// 以严格模式检查每个模块，并在每个文件里加入 &#39;use strict&#39;</span>

    <span class="token comment">/* 额外的检查 */</span>
    <span class="token property">&quot;noUnusedLocals&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                <span class="token comment">// 有未使用的变量时，抛出错误</span>
    <span class="token property">&quot;noUnusedParameters&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token comment">// 有未使用的参数时，抛出错误</span>
    <span class="token property">&quot;noImplicitReturns&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>             <span class="token comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span>
    <span class="token property">&quot;noFallthroughCasesInSwitch&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span>

    <span class="token comment">/* 模块解析选项 */</span>
    <span class="token property">&quot;moduleResolution&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span>            <span class="token comment">// 选择模块解析策略： &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6)</span>
    <span class="token property">&quot;baseUrl&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 用于解析非相对模块名称的基目录</span>
    <span class="token property">&quot;paths&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                           <span class="token comment">// 模块名到基于 baseUrl 的路径映射的列表</span>
    <span class="token property">&quot;rootDirs&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                        <span class="token comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span>
    <span class="token property">&quot;typeRoots&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                       <span class="token comment">// 包含类型声明的文件列表</span>
    <span class="token property">&quot;types&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                           <span class="token comment">// 需要包含的类型声明文件名列表</span>
    <span class="token property">&quot;allowSyntheticDefaultImports&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment">// 允许从没有设置默认导出的模块中默认导入。</span>

    <span class="token comment">/* Source Map Options */</span>
    <span class="token property">&quot;sourceRoot&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                    <span class="token comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span>
    <span class="token property">&quot;mapRoot&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span>
    <span class="token property">&quot;inlineSourceMap&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>               <span class="token comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span>
    <span class="token property">&quot;inlineSources&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 <span class="token comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span>

    <span class="token comment">/* 其他选项 */</span>
    <span class="token property">&quot;experimentalDecorators&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment">// 启用装饰器</span>
    <span class="token property">&quot;emitDecoratorMetadata&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>          <span class="token comment">// 为装饰器提供元数据的支持</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>关于这些（或者更多）编译选项，稍后将会讨论。</p><h5 id="typescript-编译"><a class="header-anchor" href="#typescript-编译" aria-hidden="true">#</a> TypeScript 编译</h5><p>好的 IDE 支持对 TypeScript 的即时编译。但是，如果你想在使用 <code>tsconfig.json</code> 时从命令行手动运行 TypeScript 编译器，你可以通过以下方式：</p><p>运行 tsc，它会在当前目录或者是父级目录寻找 <code>tsconfig.json</code> 文件。 运行 <code>tsc -p ./path-to-project-directory</code> 。当然，这个路径可以是绝对路径，也可以是相对于当前目录的相对路径。 你甚至可以使用 <code>tsc -w</code> 来启用 TypeScript 编译器的观测模式，在检测到文件改动之后，它将重新编译。</p><h4 id="制定文件"><a class="header-anchor" href="#制定文件" aria-hidden="true">#</a> 制定文件</h4><p>你也可以显式指定需要编译的文件：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
  <span class="token property">&quot;files&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;./some/file.ts&quot;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你还可以使用 <code>include</code> 和 <code>exclude</code> 选项来指定需要包含的文件和排除的文件：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
  <span class="token property">&quot;include&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;./folder&quot;</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">&quot;exclude&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;./folder/**/*.spec.ts&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;./folder/someSubFolder&quot;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>使用 <code>globs</code>：<code>**/*</code> （一个示例用法：<code>some/folder/**/*</code>）意味着匹配所有的文件夹和所有文件（扩展名为 <code>.ts/.tsx</code>，当开启了 <code>allowJs: true</code> 选项时，扩展名可以是 <code>.js/.jsx</code>）。</p></div><h3 id="声明空间"><a class="header-anchor" href="#声明空间" aria-hidden="true">#</a> 声明空间</h3><p>在 TypeScript 里存在两种声明空间：类型声明空间与变量声明空间。下文将分别讨论这两个概念。</p><h4 id="类型声明空间"><a class="header-anchor" href="#类型声明空间" aria-hidden="true">#</a> 类型声明空间</h4><p>类型声明空间包含用来当做类型注解的内容，例如下面的类型声明：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Bas</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>你可以将 <code>Foo</code>, <code>Bar</code>, <code>Bas</code> 作为类型注解使用，示例如下：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Bas</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，尽管你定义了 interface Bar，却并不能够把它作为一个变量来使用，因为它没有定义在变量声明空间中。</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> Bar<span class="token punctuation">;</span> <span class="token comment">// Error: &quot;cannot find name &#39;Bar&#39;&quot;</span>
</code></pre></div><p>出现错误提示： <code>cannot find name &#39;Bar&#39;</code> 的原因是名称 <code>Bar</code> 并未定义在变量声明空间。这将带领我们进入下一个主题 -- 变量声明空间。</p><h4 id="变量声明空间"><a class="header-anchor" href="#变量声明空间" aria-hidden="true">#</a> 变量声明空间</h4><p>变量声明空间包含可用作变量的内容，在上文中 <code>Class Foo</code> 提供了一个类型 <code>Foo</code> 到类型声明空间，此外它同样提供了一个变量 Foo 到变量声明空间，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> someVar <span class="token operator">=</span> Foo<span class="token punctuation">;</span>
<span class="token keyword">const</span> someOtherVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre></div><p>这很棒，尤其是当你想把一个类来当做变量传递时。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>我们并不能把一些如 <code>interface</code> 定义的内容当作变量使用。</p></div><p>与此相似，一些用 <code>var</code> 声明的变量，也只能在变量声明空间使用，不能用作类型注解。</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> foo<span class="token punctuation">;</span> <span class="token comment">// ERROR: &quot;cannot find name &#39;foo&#39;&quot;</span>
</code></pre></div><p>提示 <code>ERROR: &quot;cannot find name &#39;foo&#39;&quot;</code> 原因是，名称 foo 没有定义在类型声明空间里。</p><h3 id="模块"><a class="header-anchor" href="#模块" aria-hidden="true">#</a> 模块</h3><h4 id="全局模块"><a class="header-anchor" href="#全局模块" aria-hidden="true">#</a> 全局模块</h4><p>在默认情况下，当你开始在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中。如在 foo.ts 里的以下代码。</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你在相同的项目里创建了一个新的文件 bar.ts，TypeScript 类型系统将会允许你使用变量 foo，就好像它在全局可用一样：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// allowed</span>
</code></pre></div><p>毋庸置疑，使用全局变量空间是危险的，因为它会与文件内的代码命名冲突。我们推荐使用下文中将要提到的文件模块。</p><h4 id="文件模块"><a class="header-anchor" href="#文件模块" aria-hidden="true">#</a> 文件模块</h4><p>文件模块也被称为外部模块。如果在你的 TypeScript 文件的根级别位置含有 <code>import</code> 或者 <code>export</code>，那么它会在这个文件中创建一个本地的作用域。因此，我们需要把上文 <code>foo.ts</code> 改成如下方式（注意 <code>export</code> 用法）：</p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre></div><p>在全局命名空间里，我们不再有 <code>foo</code>，这可以通过创建一个新文件 <code>bar.ts</code> 来证明：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// ERROR: &quot;cannot find name &#39;foo&#39;&quot;</span>
</code></pre></div><p>如果你想在 <code>bar.ts</code> 里使用来自 <code>foo.ts</code> 的内容，你必须显式地导入它，更新后的 <code>bar.ts</code> 如下所示。</p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// allow</span>
</code></pre></div><p>在 <code>bar.ts</code> 文件里使用 <code>import</code> 时，它不仅允许你使用从其他文件导入的内容，还会将此文件 <code>bar.ts</code> 标记为一个模块，文件内定义的声明也不会“污染”全局命名空间</p><h4 id="文件模块详情"><a class="header-anchor" href="#文件模块详情" aria-hidden="true">#</a> 文件模块详情</h4><p>文件模块拥有强大的功能和较强的可用性。下面我们来讨论它的功能及一些用法。</p><h5 id="澄清-commonjs-amd-esmodules-others"><a class="header-anchor" href="#澄清-commonjs-amd-esmodules-others" aria-hidden="true">#</a> 澄清: commonjs, amd, esmodules, others</h5><p>首先，我们需要澄清这些模块系统的不一致性。我将会提供给你我当前的建议，以及消除一些你的顾虑。</p><p>你可以根据不同的 <code>module</code> 选项来把 TypeScript 编译成不同的 JavaScript 模块类型，这有一些你可以忽略的东西：</p><ul><li>AMD：不要使用它，它仅能在浏览器工作；</li><li>SystemJS：这是一个好的实验，已经被 ES 模块替代；</li><li>ES 模块：它并没有准备好。</li></ul><p>使用 <code>module: commonjs</code> 选项来替代这些模式，将会是一个好的主意。</p><p>怎么书写 TypeScript 模块呢？，这也是一件让人困惑的事。在今天我们应该这么做：</p><ul><li>放弃使用 <code>import/require</code> 语法即 <code>import foo = require(&#39;foo&#39;)</code> 写法</li><li>推荐使用 ES 模块语法</li></ul><p>这很酷，接下来，让我们看看 ES 模块语法。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>使用 <code>module: commonjs</code> 选项以及使用 ES 模块语法导入、导出、编写模块。</p></div><h5 id="es-模块语法"><a class="header-anchor" href="#es-模块语法" aria-hidden="true">#</a> ES 模块语法</h5><ul><li>使用 <code>export</code> 关键字导出一个变量或类型</li></ul><div class="language-ts"><pre><code><span class="token comment">// foo.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> someVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">someType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>export</code> 的写法除了上面这种，还有另外一种：</li></ul><div class="language-ts"><pre><code><span class="token comment">// foo.ts</span>
<span class="token keyword">const</span> someVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">someType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span> someVar<span class="token punctuation">,</span> someType <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>你也可以用重命名变量的方式导出：</li></ul><div class="language-ts"><pre><code><span class="token comment">// foo.ts</span>
<span class="token keyword">const</span> someVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> someVar <span class="token keyword">as</span> aDifferentName <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>使用 <code>import</code> 关键字导入一个变量或者是一个类型：</li></ul><div class="language-ts"><pre><code><span class="token comment">// bar.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> someVar<span class="token punctuation">,</span> someType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通过重命名的方式导入变量或者类型：</li></ul><div class="language-ts"><pre><code><span class="token comment">// bar.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> someVar <span class="token keyword">as</span> aDifferentName <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面：</li></ul><div class="language-ts"><pre><code><span class="token comment">// bar.ts</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> foo <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
<span class="token comment">// 你可以使用 `foo.someVar` 和 `foo.someType` 以及其他任何从 `foo` 导出的变量或者类型</span>
</code></pre></div><ul><li>只导入模块：</li></ul><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token string">&#39;core-js&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 一个普通的 polyfill 库</span>
</code></pre></div><ul><li>从其他模块导入后整体导出：</li></ul><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>从其他模块导入后，部分导出：</li></ul><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token punctuation">{</span> someVar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通过重命名，部分导出从另一个模块导入的项目：</li></ul><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token punctuation">{</span> someVar <span class="token keyword">as</span> aDifferentName <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h6 id="默认导入／导出"><a class="header-anchor" href="#默认导入／导出" aria-hidden="true">#</a> 默认导入／导出</h6><p>我并不喜欢用默认导出，虽然有默认导出的语法：</p><ul><li>使用 export default <ul><li>在一个变量之前（不需要使用 let/const/var）；</li><li>在一个函数之前；</li><li>在一个类之前。</li></ul></li></ul><div class="language-ts"><pre><code><span class="token comment">// some var</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span>someVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// some function</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// some class</span>
<span class="token class-name"><span class="token keyword">export</span></span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">someClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><ul><li>导入使用 <code>import someName from &#39;someModule&#39;</code> 语法（你可以根据需要为导入命名）：</li></ul><div class="language-ts"><pre><code><span class="token keyword">import</span> someLocalNameForThisFile <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="模块路径"><a class="header-anchor" href="#模块路径" aria-hidden="true">#</a> 模块路径</h5><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果你需要使用 <code>moduleResolution: node</code> 选项，你应该将此选项放入你的配置文件中。如果你使用了 <code>module: commonjs</code> 选项， <code>moduleResolution: node</code> 将会默认开启。</p></div><p>这里存在两种截然不同的模块：</p><ul><li>相对模块路径（路径以 <code>.</code> 开头，例如：<code>./someFile</code> 或者 <code>../../someFolder/someFile</code> 等）；</li><li>其他动态查找模块（如：<code>core-js</code>，<code>typestyle</code>，<code>react</code> 或者甚至是 <code>react/core</code> 等）。</li></ul><p>它们的主要区别在于系统如何解析模块。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>我将会使用一个概念性术语，<code>place</code> -- 将在提及查找模式后解释它。</p></div><h6 id="相对模块路径"><a class="header-anchor" href="#相对模块路径" aria-hidden="true">#</a> 相对模块路径</h6><p>这很简单，仅仅是按照相对路径来就可以了：</p><ul><li>如果文件 <code>bar.ts</code> 中含有 <code>import * as foo from &#39;./foo&#39;</code>，那么 <code>foo</code> 文件必须与 <code>bar.ts</code> 文件存在于相同的文件夹下</li><li>如果文件 <code>bar.ts</code> 中含有 <code>import * as foo from &#39;../foo&#39;</code>，那么 <code>foo</code> 文件所存在的地方必须是 <code>bar.ts</code> 的上一级目录；</li><li>如果文件 <code>bar.ts</code> 中含有 <code>import * as foo from &#39;../someFolder/foo&#39;</code>，那么 <code>foo</code> 文件所在的文件夹 someFolder 必须与 <code>bar.ts</code> 文件所在文件夹在相同的目录下。</li></ul><p>你还可以思考一下其他相对路径导入的场景。😃</p><h6 id="动态查找"><a class="header-anchor" href="#动态查找" aria-hidden="true">#</a> 动态查找</h6><p>当导入路径不是相对路径时，模块解析将会模仿 <a href="https://nodejs.org/api/modules.html#modules_all_together" target="_blank" rel="noopener noreferrer">Node 模块解析策略</a>，下面我将给出一个简单例子：</p><ul><li>当你使用 <code>import * as foo from &#39;foo&#39;</code>，将会按如下顺序查找模块： <ul><li><code>./node_modules/foo</code></li><li><code>../node_modules/foo</code></li><li><code>../../node_modules/foo</code></li><li>直到系统的根目录</li></ul></li><li>当你使用 <code>import * as foo from &#39;something/foo&#39;</code>，将会按照如下顺序查找内容 <ul><li><code>./node_modules/something/foo</code></li><li><code>../node_modules/something/foo</code></li><li><code>../../node_modules/something/foo</code></li><li>直到系统的根目录</li></ul></li></ul><h5 id="什么是-place"><a class="header-anchor" href="#什么是-place" aria-hidden="true">#</a> 什么是 <code>place</code></h5><p>当我提及被检查的 <code>place</code> 时，我想表达的是在这个 <code>place</code> 上，TypeScript 将会检查以下内容（例如一个 <code>foo</code> 的 <code>place</code>）：</p><ul><li>如果这个 <code>place</code> 表示一个文件，如：<code>foo.ts</code>，欢呼！</li><li>否则，如果这个 <code>place</code> 是一个文件夹，并且存在一个文件 <code>foo/index.ts</code>，欢呼！</li><li>否则，如果这个 <code>place</code> 是一个文件夹，并且存在一个 <code>foo/package.json</code> 文件，在该文件中指定 <code>types</code> 的文件存在，那么就欢呼！</li><li>否则，如果这个 <code>place</code> 是一个文件夹，并且存在一个 <code>package.json</code> 文件，在该文件中指定 <code>main</code> 的文件存在，那么就欢呼！</li></ul><p>从文件类型上来说，我实际上是指 <code>.ts</code>， <code>.d.ts</code> 或者 <code>.js</code></p><p>就是这样，现在你已经是一个模块查找专家（这并不是一个小小的成功）。</p><h5 id="重写类型的动态查找"><a class="header-anchor" href="#重写类型的动态查找" aria-hidden="true">#</a> 重写类型的动态查找</h5><p>在你的项目里，你可以通过 <code>declare module &#39;somePath&#39;</code> 声明一个全局模块的方式，来解决查找模块路径的问题。</p><div class="language-ts"><pre><code><span class="token comment">// global.d.ts</span>
<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&#39;foo&#39;</span> <span class="token punctuation">{</span>
  <span class="token comment">// some variable declarations</span>
  <span class="token keyword">export</span> <span class="token keyword">var</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接着 ：</p><div class="language-ts"><pre><code><span class="token comment">// anyOtherTsFileInYourProject.ts</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> foo <span class="token keyword">from</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>
<span class="token comment">// TypeScript 将假设（在没有做其他查找的情况下）</span>
<span class="token comment">// foo 是 { bar: number }</span>
</code></pre></div><h5 id="import-require-仅仅是导入类型"><a class="header-anchor" href="#import-require-仅仅是导入类型" aria-hidden="true">#</a> import/require 仅仅是导入类型</h5><p>以下导入语法：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>它实际上只做了两件事：</p><ul><li>导入 foo 模块的所有类型信息；</li><li>确定 foo 模块运行时的依赖关系。</li></ul><p>你可以选择仅加载类型信息，而没有运行时的依赖关系。在继续之前，你可能需要重新阅读本书 <a href="#%E5%A3%B0%E6%98%8E%E7%A9%BA%E9%97%B4">声明空间部分</a>。</p><p>如果你没有把导入的名称当做变量声明空间来用，在编译成 JavaScript 时，导入的模块将会被完全移除。这最好用例子来解释，下面我们将会给出一些示例。</p><h6 id="例子-1"><a class="header-anchor" href="#例子-1" aria-hidden="true">#</a> 例子 1</h6><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>将会编译成 JavaScript：</p><div class="language-js"><pre><code></code></pre></div><p>这是正确的，一个没有被使用的空文件。</p><h6 id="例子-2"><a class="header-anchor" href="#例子-2" aria-hidden="true">#</a> 例子 2</h6><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar<span class="token operator">:</span> foo<span class="token punctuation">;</span>
</code></pre></div><p>将会被编译成：</p><div class="language-js"><pre><code><span class="token keyword">let</span> bar<span class="token punctuation">;</span>
</code></pre></div><p>这是因为 foo （或者其他任何属性如：<code>foo.bas</code>）没有被当做一个变量使用。</p><h6 id="例子-3"><a class="header-anchor" href="#例子-3" aria-hidden="true">#</a> 例子 3</h6><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span>
</code></pre></div><p>将会被编译成（假设是 commonjs）：</p><div class="language-js"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span>
</code></pre></div><p>这是因为 <code>foo</code> 被当做变量使用了。</p><h6 id="使用例子：懒加载"><a class="header-anchor" href="#使用例子：懒加载" aria-hidden="true">#</a> 使用例子：懒加载</h6><p>类型推断需要提前完成，这意味着，如果你想在 <code>bar</code> 文件里，使用从其他文件 <code>foo</code> 导出的类型，你将不得不这么做：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> foo<span class="token punctuation">.</span>SomeType<span class="token punctuation">;</span>
</code></pre></div><p>然而，在某些情景下，你只想在需要时加载模块 <code>foo</code>，此时你需要仅在类型注解中使用导入的模块名称，而<strong>不</strong>是在变量中使用。在编译成 JavaScript 时，这些将会被移除。接着，你可以手动导入你需要的模块。</p><p>作为一个例子，考虑以下基于 <code>commonjs</code> 的代码，我们仅在一个函数内导入 <code>foo</code> 模块：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">loadFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这是懒加载 foo，原始的加载仅仅用来做类型注解</span>
  <span class="token keyword">const</span> _foo<span class="token operator">:</span> <span class="token keyword">typeof</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 现在，你可以使用 `_foo` 替代 `foo` 来作为一个变量使用</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个同样简单的 <code>amd</code> 模块（使用 requirejs）：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">loadFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这是懒加载 foo，原始的加载仅仅用来做类型注解</span>
  <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>_foo<span class="token operator">:</span> <span class="token keyword">typeof</span> foo<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 现在，你可以使用 `_foo` 替代 `foo` 来作为一个变量使用</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些通常在以下情景使用：</p><ul><li>在 web app 里， 当你在特定路由上加载 JavaScript 时；</li><li>在 node 应用里，当你只想加载特定模块，用来加快启动速度时。</li></ul><h6 id="使用例子：打破循环依赖"><a class="header-anchor" href="#使用例子：打破循环依赖" aria-hidden="true">#</a> 使用例子：打破循环依赖</h6><p>类似于懒加载的使用用例，某些模块加载器（commonjs/node 和 amd/requirejs）不能很好的处理循环依赖。在这种情况下，一方面我们使用延迟加载代码，并在另一方面预先加载模块是很实用的。</p><h6 id="使用例子：确保导入"><a class="header-anchor" href="#使用例子：确保导入" aria-hidden="true">#</a> 使用例子：确保导入</h6><p>当你加载一个模块，只是想引入其附加的作用（如：模块可能会注册一些像 <a href="https://codemirror.net/doc/manual.html#addons" target="_blank" rel="noopener noreferrer">CodeMirror addons</a>）时，然而，如果你仅仅是 <code>import/require</code> （导入）一些并没有与你的模块或者模块加载器有任何依赖的 JavaScript 代码，（如：webpack），经过 TypeScript 编译后，这些将会被完全忽视。在这种情况下，你可以使用一个 <code>ensureImport</code> 变量，来确保编译的 JavaScript 依赖与模块。如：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;./foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> bar <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;./bar&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> bas <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;./bas&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> ensureImport<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> foo <span class="token operator">||</span> bar <span class="token operator">||</span> bas<span class="token punctuation">;</span>
</code></pre></div><h4 id="global-d-ts"><a class="header-anchor" href="#global-d-ts" aria-hidden="true">#</a> global.d.ts</h4><p>在上文中，当我们讨论文件模块时，比较了全局变量与文件模块，并且我们推荐使用基于文件的模块，而不是选择污染全局命名空间。</p><p>然而，如果你的团队里有 TypeScript 初学者，你可以提供他们一个 <code>global.d.ts</code> 文件，用来将一些接口或者类型放入全局命名空间里，这些定义的接口和类型能在你的所有 TypeScript 代码里使用。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>对于任何需要编译成 <code>JavaScript</code> 的代码，我们强烈建议你放入文件模块里。</p></div><ul><li><code>global.d.ts</code> 是一种扩充 <code>lib.d.ts</code> 很好的方式，如果你需要的话。</li><li>当你从 <code>JS</code> 迁移到 <code>TS</code> 时，定义 <code>declare module &quot;some-library-you-dont-care-to-get-defs-for&quot;</code> 能让你快速开始。</li></ul><h3 id="命名空间"><a class="header-anchor" href="#命名空间" aria-hidden="true">#</a> 命名空间</h3><p>在 JavaScript 使用命名空间时， 这有一个常用的、方便的语法：</p><div class="language-js"><pre><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  something<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>something <span class="token operator">||</span> <span class="token punctuation">(</span>something <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>something || (something = {})</code> 允许匿名函数 <code>function (something) {}</code> 向现有对象添加内容，或者创建一个新对象，然后向该对象添加内容。这意味着你可以拥有两个由某些边界拆成的块。</p><div class="language-js"><pre><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  something<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>something <span class="token operator">||</span> <span class="token punctuation">(</span>something <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { foo: 123 }</span>

<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  something<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>something <span class="token operator">||</span> <span class="token punctuation">(</span>something <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { foo: 123, bar: 456 }</span>
</code></pre></div><p>在确保创建的变量不会泄漏至全局命名空间时，这种方式在 JavaScript 中很常见。当基于文件模块使用时，你无须担心这点，但是该模式仍然适用于一组函数的逻辑分组。因此 TypeScript 提供了 <code>namespace</code> 关键字来描述这种分组，如下所示。</p><div class="language-ts"><pre><code><span class="token keyword">namespace</span> Utility <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// usage</span>
Utility<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Call me&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Utility<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&#39;maybe&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>namespace</code> 关键字编译后的 JavaScript 代码，与我们早些时候看到的 JavaScript 代码一样。</p><div class="language-js"><pre><code><span class="token keyword">var</span> Utility<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Utility</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 添加属性至 Utility</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Utility <span class="token operator">||</span> Utility <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>值得注意的一点是，命名空间是支持嵌套的。因此，你可以做一些类似于在 <code>Utility</code> 命名空间下嵌套一个命名空间 <code>Messaging</code> 的事情。</p><p>对于大多数项目，我们建议使用外部模块和命名空间，来快速演示和移植旧的 JavaScript 代码。</p><h3 id="动态导入表达式"><a class="header-anchor" href="#动态导入表达式" aria-hidden="true">#</a> 动态导入表达式</h3><p>动态导入表达式是 ECMAScript 的一个新功能，它允许你在程序的任意位置异步加载一个模块，TC39 JavaScript 委员会有一个提案，目前处于第四阶段，它被称为 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener noreferrer">import() proposal for JavaScript</a>。</p><p>此外，<strong>webpack</strong> bundler 有一个 <code>Code Splitting</code> 功能，它能允许你将代码拆分为许多块，这些块在将来可被异步下载。因此，你可以在程序中首先提供一个最小的程序启动包，并在将来异步加载其他模块。</p><p>这很自然就会让人想到（如果我们工作在 webpack dev 的工作流程中）<a href="https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#dynamic-import-expressions" target="_blank" rel="noopener noreferrer">TypeScript 2.4 dynamic import expressions</a> 将会把你最终生成的 JavaScript 代码自动分割成很多块。但是这似乎并不容易实现，因为它依赖于我们正在使用的 <code>tsconfig.json</code> 配置文件。</p><p>webpack 实现代码分割的方式有两种：使用 <code>import()</code> （首选，ECMAScript 的提案）和 <code>require.ensure()</code> （最后考虑，webpack 具体实现）。因此，我们期望 TypeScript 的输出是保留 <code>import()</code> 语句，而不是将其转化为其他任何代码。</p><p>让我们来看一个例子，在这个例子中，我们演示了如何配置 webpack 和 TypeScript 2.4 +。</p><p>在下面的代码中，我希望懒加载 <code>moment</code> 库，同时我也希望使用代码分割的功能，这意味 <code>moment</code> 会被分割到一个单独的 JavaScript 文件，当它被使用时，会被异步加载。</p><div class="language-ts"><pre><code><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: &quot;momentjs&quot; */</span> <span class="token string">&#39;moment&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>moment <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 懒加载的模块拥有所有的类型，并且能够按期工作</span>
    <span class="token comment">// 类型检查会工作，代码引用也会工作  :100:</span>
    <span class="token keyword">const</span> time <span class="token operator">=</span> <span class="token function">moment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;TypeScript &gt;= 2.4.0 Dynamic Import Expression:&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Failed to load moment&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这是 <code>tsconfig.json</code> 的配置文件：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;target&quot;</span><span class="token operator">:</span> <span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;module&quot;</span><span class="token operator">:</span> <span class="token string">&quot;esnext&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;lib&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">&quot;dom&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;scripthost&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;es2015.promise&quot;</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">&quot;jsx&quot;</span><span class="token operator">:</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;declaration&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token property">&quot;sourceMap&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">&quot;outDir&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./dist/js&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;strict&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">&quot;moduleResolution&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;typeRoots&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">&quot;./node_modules/@types&quot;</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">&quot;types&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;react&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;react-dom&quot;</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p><ul><li>使用 <code>&quot;module&quot;: &quot;esnext&quot;</code> 选项：TypeScript 保留 <code>import()</code> 语句，该语句用于 Webpack Code Splitting。</li><li>进一步了解有关信息，推荐阅读这篇文章：<a href="https://blog.josequinto.com/2017/06/29/dynamic-import-expressions-and-webpack-code-splitting-integration-with-typescript-2-4/" target="_blank" rel="noopener noreferrer">Dynamic Import Expressions and webpack 2 Code Splitting integration with TypeScript 2.4</a>.</li></ul></div><h2 id="typescript-类型系统"><a class="header-anchor" href="#typescript-类型系统" aria-hidden="true">#</a> TypeScript 类型系统</h2><h3 id="概览"><a class="header-anchor" href="#概览" aria-hidden="true">#</a> 概览</h3><h4 id="typescript-类型系统-1"><a class="header-anchor" href="#typescript-类型系统-1" aria-hidden="true">#</a> TypeScript 类型系统</h4><p>TypeScript 类型系统的主要功能。以下是一些关键点：</p><ul><li>TypeScript 的类型系统被设计为可选的，因此，你的 JavaScript 就是 TypeScript;</li><li>TypeScript 不会阻止 JavaScript 的运行，即使存在类型错误也不例外，这能让你的 JavaScript 逐步迁移至 TypeScript。</li></ul><p>现在让我们开始学习 TypeScript 类型系统的语法吧，在这一章节中，你将能给你的代码加上类型注解，并且能看到它的益处。这将为我们进一步了解类型系统做铺垫。</p><h4 id="基本注解"><a class="header-anchor" href="#基本注解" aria-hidden="true">#</a> 基本注解</h4><p>如前文所提及，类型注解使用 <code>:TypeAnnotation</code> 语法。在类型声明空间中可用的任何内容都可以用作类型注解。</p><p>在下面这个例子中，使用了变量、函数参数以及函数返回值的类型注解：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> num<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">identity</span><span class="token punctuation">(</span>num<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="原始类型"><a class="header-anchor" href="#原始类型" aria-hidden="true">#</a> 原始类型</h4><p>JavaScript 原始类型也同样适应于 TypeScript 的类型系统，因此 <code>string</code>、<code>number</code>、<code>boolean</code> 也可以被用作类型注解：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bool<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
num <span class="token operator">=</span> <span class="token number">123.456</span><span class="token punctuation">;</span>
num <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>

str <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span>
str <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>

bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
bool <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
bool <span class="token operator">=</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><h4 id="数组"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h4><p>TypeScript 为数组提供了专用的类型语法，因此你可以很轻易的注解数组。它使用后缀 <code>[]</code>， 接着你可以根据需要补充任何有效的类型注解（如：<code>:boolean[]</code>）。它能让你安全的使用任何有关数组的操作，而且它也能防止一些类似于赋值错误类型给成员的行为。如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> boolArray<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

boolArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boolArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boolArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

boolArray<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
boolArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

boolArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
boolArray <span class="token operator">=</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
boolArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><h4 id="接口"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h4><p>接口是 TypeScript 的一个核心知识，它能合并众多类型声明至一个类型声明：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Name</span> <span class="token punctuation">{</span>
  first<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  second<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> name<span class="token operator">:</span> Name<span class="token punctuation">;</span>
name <span class="token operator">=</span> <span class="token punctuation">{</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  second<span class="token operator">:</span> <span class="token string">&#39;Doe&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error: &#39;Second is missing&#39;</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error: &#39;Second is the wrong type&#39;</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  second<span class="token operator">:</span> <span class="token number">1337</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在这里，我们把类型注解：<code>first: string</code> + <code>second: string</code> 合并到了一个新的类型注解 <code>Name</code> 里，这样能强制对每个成员进行类型检查。接口在 TypeScript 拥有强大的力量，稍后，我们将会用一个内容专门阐述如何更好的使用它。</p><h4 id="内联类型注解"><a class="header-anchor" href="#内联类型注解" aria-hidden="true">#</a> 内联类型注解</h4><p>与创建一个接口不同，你可以使用内联注解语法注解任何内容：<code>:{ /*Structure*/ }</code>：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token punctuation">{</span>
  first<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  second<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  second<span class="token operator">:</span> <span class="token string">&#39;Doe&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error: &#39;Second is missing&#39;</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error: &#39;Second is the wrong type&#39;</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  second<span class="token operator">:</span> <span class="token number">1337</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>内联类型能为你快速的提供一个类型注解。它可以帮助你省去为类型起名的麻烦（你可能会使用一个很糟糕的名称）。然而，如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 <code>type alias</code>，它会在接下来的部分提到）是一个不错的主意。</p><h4 id="特殊类型"><a class="header-anchor" href="#特殊类型" aria-hidden="true">#</a> 特殊类型</h4><p>除了被提到的一些原始类型，在 TypeScript 中，还存在一些特殊的类型，它们是 <code>any</code>、 <code>null</code>、 <code>undefined</code> 以及 <code>void</code>。</p><h5 id="any"><a class="header-anchor" href="#any" aria-hidden="true">#</a> any</h5><p><code>any</code> 类型在 TypeScript 类型系统中占有特殊的地位。它提供给你一个类型系统的「后门」,TypeScript 将会把类型检查关闭。在类型系统里 <code>any</code> 能够兼容所有的类型（包括它自己）。因此，所有类型都能被赋值给它，它也能被赋值给其他任何类型。以下有一个证明例子：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> power<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>

<span class="token comment">// 赋值任意类型</span>
power <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span>
power <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token comment">// 它也兼容任何类型</span>
<span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
power <span class="token operator">=</span> num<span class="token punctuation">;</span>
num <span class="token operator">=</span> power<span class="token punctuation">;</span>
</code></pre></div><p>当你把 JavaScript 迁移至 TypeScript 时，你将会经常性使用 <code>any</code>。但你必须减少对它的依赖，因为你需要确保类型安全。当使用 <code>any</code> 时，你基本上是在告诉 TypeScript 编译器不要进行任何的类型检查。</p><h5 id="null-和-undefined"><a class="header-anchor" href="#null-和-undefined" aria-hidden="true">#</a> null 和 undefined</h5><p>在类型系统中，JavaScript 中的 null 和 undefined 字面量和其他被标注了 <code>any</code> 类型的变量一样，都能被赋值给任意类型的变量，如下例子所示：</p><div class="language-ts"><pre><code><span class="token comment">// strictNullChecks: false</span>

<span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

<span class="token comment">// 这些类型能被赋予</span>
num <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
str <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="void"><a class="header-anchor" href="#void" aria-hidden="true">#</a> void</h5><p>使用 <code>:void</code> 来表示一个函数没有一个返回值</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="范型"><a class="header-anchor" href="#范型" aria-hidden="true">#</a> 范型</h4><p>在计算机科学中，许多算法和数据结构并不会依赖于对象的实际类型。但是，你仍然会想在每个变量里强制提供约束。例如：在一个函数中，它接受一个列表，并且返回这个列表的反向排序，这里的约束是指传入至函数的参数与函数的返回值：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">reverse</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>items<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> toreturn <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    toreturn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> toreturn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> sample <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reversed <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>sample<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reversed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3, 2, 1</span>

<span class="token comment">// Safety</span>
reversed<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
reversed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>

reversed<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
reversed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div><p>在上个例子中，函数 <code>reverse</code> 接受一个类型为 <code>T</code>（注意在 <code>reverse&lt;T&gt;</code> 中的类型参数） 的数组（<code>items: T[]</code>），返回值为类型 <code>T</code> 的一个数组（注意：<code>T[]</code>），函数 <code>reverse</code> 的返回值类型与它接受的参数的类型一样。当你传入 <code>const sample = [1, 2, 3]</code> 时，TypeScript 能推断出 <code>reverse</code> 为 <code>number[]</code> 类型，从而能给你类型安全。与此相似，当你传入一个类型为 <code>string[]</code> 类型的数组时，TypeScript 能推断 <code>reverse</code> 为 <code>string[]</code> 类型，如下例子所示：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> strArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reversedStrs <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>strArr<span class="token punctuation">)</span><span class="token punctuation">;</span>

reversedStrs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>事实上，JavaScript 数组已经拥有了 reverse 的方法，TypeScript 也确实使用了泛型来定义其结构：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>意味着，当你在数组上调用 <code>.reverse</code> 方法时，将会获得类型安全：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> numArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reversedNums <span class="token operator">=</span> numArr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

reversedNums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>当稍后在 <a href="#%E7%8E%AF%E5%A2%83%E5%A3%B0%E6%98%8E">环境声明</a> 章节中提及 <code>lib.d.ts</code> 时，我们会讨论更多关于 <code>Array&lt;T&gt;</code> 的信息。</p><h4 id="联合类型"><a class="header-anchor" href="#联合类型" aria-hidden="true">#</a> 联合类型</h4><p>在 JavaScript 中，你可能希望属性为多种类型之一，如字符串或者数组。这正是 TypeScript 中联合类型能派上用场的地方（它使用 <code>|</code> 作为标记，如 <code>string | number</code>）。关于联合类型，一个常见的用例是一个可以接受字符串数组或单个字符串的函数：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">formatCommandline</span><span class="token punctuation">(</span>command<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> line <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> command <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    line <span class="token operator">=</span> command<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    line <span class="token operator">=</span> command<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39; &#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Do stuff with line: string</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="交叉类型"><a class="header-anchor" href="#交叉类型" aria-hidden="true">#</a> 交叉类型</h4><p>在 JavaScript 中， <code>extend</code> 是一种非常常见的模式，在这种模式中，你可以从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。交叉类型可以让你安全的使用此种模式：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">extend</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>first<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> second<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token constant">U</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> id <span class="token keyword">in</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> first<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> id <span class="token keyword">in</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> second<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 现在 x 拥有了 a 属性与 b 属性</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> x<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> x<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
</code></pre></div><h4 id="元组类型"><a class="header-anchor" href="#元组类型" aria-hidden="true">#</a> 元组类型</h4><p>JavaScript 并不支持元组，开发者们通常只能使用数组来表示元组。而 TypeScript 支持它，开发者可以使用 <code>:[typeofmember1, typeofmember2]</code> 的形式，为元组添加类型注解，元组可以包含任意数量的成员，示例：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> nameNumber<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Ok</span>
nameNumber <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;Jenny&#39;</span><span class="token punctuation">,</span> <span class="token number">221345</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Error</span>
nameNumber <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;Jenny&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;221345&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>将其与 TypeScript 中的解构一起使用：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> nameNumber<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
nameNumber <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;Jenny&#39;</span><span class="token punctuation">,</span> <span class="token number">322134</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> num<span class="token punctuation">]</span> <span class="token operator">=</span> nameNumber<span class="token punctuation">;</span>
</code></pre></div><h4 id="类型别名"><a class="header-anchor" href="#类型别名" aria-hidden="true">#</a> 类型别名</h4><p>TypeScript 提供了为类型注解设置别名的便捷语法，你可以使用 <code>type SomeName = someValidTypeAnnotation</code> 来创建别名：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">StrOrNum</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">let</span> sample<span class="token operator">:</span> StrOrNum<span class="token punctuation">;</span>
sample <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
sample <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 会检查类型</span>
sample <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>与接口不同，你可以为任意的类型注解提供类型别名（在联合类型和交叉类型中比较实用），下面是一些能让你熟悉类型别名语法的示例。</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Text</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">{</span> text<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Coordinates</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Callback</span> <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>如果你需要使用类型注解的层次结构，请使用接口。它能使用 <code>implements</code> 和 <code>extends</code></li><li>为一个简单的对象类型（如上面例子中的 Coordinates）使用类型别名，只需要给它一个语义化的名字即可。另外，当你想给联合类型和交叉类型提供一个语义化的名称时，一个类型别名将会是一个好的选择。</li></ul></div><h4 id="最后"><a class="header-anchor" href="#最后" aria-hidden="true">#</a> 最后</h4><p>现在你已经能够为你的大部分 JavaScript 代码添加类型注解，接着，让我们深入了解 TypeScript 的类型系统吧。</p><h3 id="从javascript-迁移"><a class="header-anchor" href="#从javascript-迁移" aria-hidden="true">#</a> 从JavaScript 迁移</h3><p>首先，假设如下：</p><ul><li>你了解 JavaScript；</li><li>你了解在项目中常用的方式和构建工具（如：webpack）。</li></ul><p>有了以上假设，一般来说，将 JavaScript 代码迁移至 TypeScript 包括以下步骤：</p><ul><li>添加一个 <code>tsconfig.json</code> 文件；</li><li>把文件扩展名从 <code>.js</code> 改成 <code>.ts</code>，开始使用 <code>any</code> 来减少错误；</li><li>开始在 TypeScript 中写代码，尽可能的减少 <code>any</code> 的使用；</li><li>回到旧代码，开始添加类型注解，并修复已识别的错误；</li><li>为第三方 JavaScript 代码定义环境声明。</li></ul><p>让我们进一步讨论其中的几个关键点。</p><p>记住：所有的 JavaScript 代码都是有效的 TypeScript 代码。这意味着，如果让 TypeScript 编译器编译 TypeScript 里的 JavaScript 代码，编译后的结果将会与原始的 JavaScript 代码一模一样。也就是说，把文件扩展名从 <code>.js</code> 改成 <code>.ts</code> 将不会造成任何负面的影响。</p><h4 id="减少错误"><a class="header-anchor" href="#减少错误" aria-hidden="true">#</a> 减少错误</h4><p>代码被迁移至 TypeScript 后，TypeScript 将会立即对你的代码进行类型检查，你的 JavaScript 代码可能并不像想象中那样整齐了，因此你可能会收到一些报错信息。这时，可以使用 any 来解决大部分的报错问题：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token string">&#39;hey&#39;</span><span class="token punctuation">;</span>

bar <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// Error: 不能把 number 类型赋值给 string 类型</span>
</code></pre></div><p>虽然这些错误是有效的，并且在大多数情况下，根据这些错误所推断出的信息比代码库的不同部分的原始作者想象的更好，但是你的重点是在逐步更新旧代码库的同时，用 TypeScript 编写新代码。在这里，你可以使用类型断言来减少此错误：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token string">&#39;hey&#39;</span><span class="token punctuation">;</span>

bar <span class="token operator">=</span> foo <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div><p>从另一方面来说，你可能想用 any 用作类型注解：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token string">&#39;hey&#39;</span><span class="token punctuation">;</span>
bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 不能把一个 number 类型赋值给 string 类型</span>
</code></pre></div><p>减少这种错误：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
  <span class="token comment">// 添加 &#39;any&#39;</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token string">&#39;hey&#39;</span><span class="token punctuation">;</span>
bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>使用此种方式来减少错误是危险的，但是它允许你将注意力转移到你的新 TypeScript 代码错误上。当你进行下一步前，最好要留下 <code>// TODO</code> 的注释。</p></div><h4 id="第三方代码"><a class="header-anchor" href="#第三方代码" aria-hidden="true">#</a> 第三方代码</h4><p>你可以将你的 JavaScript 代码改成 TypeScript 代码，但是你不能让整个世界都使用 TypeScript。这正是 TypeScript 环境声明支持的地方。我建议你以创建一个 <code>vendor.d.ts</code> 文件作为开始（<code>.d.ts</code> 文件扩展名指定这个文件是一个声明文件），然后我向文件里添加东西。或者，你也可以创建一个针对于特定库的声明文件，如为 jquery 创建 <code>jquery.d.ts</code> 文件。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>几乎排名前 90% 的 JavaScript 库的声明文件存在于 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener noreferrer">DefinitelyTyped</a> 仓库里，在创建自己定义的声明文件之前，我们建议你先去仓库中寻找是否有对应的声明文件。尽管如此，创建一个声明文件这种快速但不好的方式是减小使用 TypeScript 初始阻力的重要步骤</p></div><p>根据 <code>jquery</code> 的使用，你可以非常简单快速的为它创建一个定义：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">var</span> $<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre></div><p>有时，你可能想在某些内容（如 <code>jQuery</code>）上添加显式的注解，并且你会在类型声明空间中使用它。你可以通过 type 关键字快速的实现它：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">type</span> <span class="token class-name">JQuery</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">var</span> $<span class="token operator">:</span> JQuery<span class="token punctuation">;</span>
</code></pre></div><p>这提供给你一个更清晰的使用模式。</p><p>一个高质量的 jquery.d.ts 已经在 DefinitelyTyped 中存在。现在你已经知道如何在使用第三方 JavaScript 模块时，快速克服从 JavaScript 至 TypeScript 的阻力了。在接下去的章节，我们将会讨论环境声明。</p><h4 id="第三方的-npm-模块"><a class="header-anchor" href="#第三方的-npm-模块" aria-hidden="true">#</a> 第三方的 NPM 模块</h4><p>与全局变量声明相似，你可以快速的定义一个全局模块，如：对于 jquery，如果你想把它作为一个模块来使用（[NPM(<a href="https://www.npmjs.com/package/jquery" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/jquery</a>)]），可以自己通过以下方式实现：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&#39;jquery&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>然后你就可以在必要时导入它：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> $ <span class="token keyword">from</span> <span class="token string">&#39;jquery&#39;</span><span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>再一次说明，一个高质量的 <code>jquery.d.ts</code> 已经在 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener noreferrer">DefinitelyTyped</a> 中存在，但是可能在你的包里没有，那么，你现在有一个简单快速的方式来继续迁移。</p></div><h4 id="额外的非-javascript-资源"><a class="header-anchor" href="#额外的非-javascript-资源" aria-hidden="true">#</a> 额外的非 JavaScript 资源</h4><p>在 TypeScript 中，甚至可以允许你导入任何文件，例如 <code>.css</code> 文件（如果你使用的是 webpack 样式加载器或 css 模块），你只要添加如下代码（放在 <code>global.d.ts</code>）：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> $ <span class="token keyword">from</span> <span class="token string">&#39;jquery&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>现在你可以使用 <code>import * as foo from &#39;./some/file.css&#39;</code>。</p><p>与此相似，如果你想使用 html 模版（例如：angular），你可以：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&#39;*.html&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="types"><a class="header-anchor" href="#types" aria-hidden="true">#</a> @types</h3><p>毫无疑问，<a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener noreferrer">DefinitelyTyped</a> 是 TypeScript 最大的优势之一，社区已经记录了 90% 的顶级 JavaScript 库。</p><p>这意味着，你可以非常高效地使用这些库，而无须在单独的窗口打开相应文档以确保输入的正确性。</p><h4 id="使用-types"><a class="header-anchor" href="#使用-types" aria-hidden="true">#</a> 使用 <code>@types</code></h4><p>你可以通过 <code>npm</code> 来安装使用 <code>@types</code>，例如为 <code>jquery</code> 添加声明文件：</p><div class="language-shell"><pre><code><span class="token function">npm</span> <span class="token function">install</span> @types/jquery --save-dev
</code></pre></div><p><code>@types</code> 支持全局和模块类型定义。</p><h5 id="全局-types"><a class="header-anchor" href="#全局-types" aria-hidden="true">#</a> 全局 <code>@types</code></h5><p>默认情况下，TypeScript 会自动包含支持全局使用的任何声明定义。例如，对于 jquery，你应该能够在项目中开始全局使用 <code>$</code>。</p><h5 id="模块-types"><a class="header-anchor" href="#模块-types" aria-hidden="true">#</a> 模块 <code>@types</code></h5><p>安装完之后，不需要特别的配置，你就可以像使用模块一样使用它：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> $ <span class="token keyword">from</span> <span class="token string">&#39;jquery&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 现在你可以此模块中任意使用$了 :)</span>
</code></pre></div><h4 id="控制全局"><a class="header-anchor" href="#控制全局" aria-hidden="true">#</a> 控制全局</h4><p>可以看出，对于某些团队而言，拥有允许全局使用的定义是一个问题。因此，你可以通过配置 <code>tsconfig.json</code> 的 <code>compilerOptions.types</code> 选项，引入有意义的类型：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;types&quot;</span> <span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">&quot;jquery&quot;</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上例所示，通过配置 <code>compilerOptions.types: [ &quot;jquery&quot; ]</code> 后，只允许使用 <code>jquery</code> 的 <code>@types</code> 包，即使这个人安装了另一个声明文件，比如 <code>npm install @types/node</code>，它的全局变量（例如 <code>process</code>）也不会泄漏到你的代码中，直到你将它们添加到 <code>tsconfig.json</code> 类型选项。</p><h3 id="环境声明"><a class="header-anchor" href="#环境声明" aria-hidden="true">#</a> 环境声明</h3><blockquote><p>TypeScript 的设计目标之一是让你在 TypeScript 中安全、轻松地使用现有的 JavaScript 库，TypeScript 通过声明文件来做到这一点</p></blockquote><p>环境声明允许你安全地使用现有的 JavaScript 库，并且能让你的 JavaScript、CoffeeScript 或者其他需要编译成 JavaScript 的语言逐步迁移至 TypeScript。</p><p>学习为第三方 JavaScript 库编写环境声明，是一种为 TypeScript 写注解比较好的实践方式</p><h4 id="声明文件"><a class="header-anchor" href="#声明文件" aria-hidden="true">#</a> 声明文件</h4><p>你可以通过 declare 关键字来告诉 TypeScript，你正在试图表述一个其他地方已经存在的代码，如：写在 JavaScript、CoffeeScript 或者是像浏览器和 Node.js 运行环境里的代码：</p><div class="language-ts"><pre><code>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// Error: &#39;foo&#39; is not defined</span>
</code></pre></div><p>和：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">var</span> foo<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// allow</span>
</code></pre></div><p>你可以选择把这些声明放入 <code>.ts</code> 或者 <code>.d.ts</code> 里。在你实际的项目里，我们强烈建议你应该把声明放入独立的 .<code>d.ts</code> 里（可以从一个命名为 <code>global.d.ts</code> 或者 <code>vendor.d.ts</code> 文件开始）。</p><p>如果一个文件有扩展名 <code>.d.ts</code>，这意味着每个根级别的声明都必须以 <code>declare</code> 关键字作为前缀。这有利于让开发者清楚的知道，在这里 TypeScript 将不会把它编译成任何代码，同时开发者需要确保这些在编译时存在。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>环境声明就好像你与编译器之间的一个约定，如果在编译时它们不存在，但是你却使用了它们，程序将会在没有警告的情况下中断。</li><li>环境声明就好像是一个文档。如果源文件更新了，你应该同步更新。所以，当你在运行时有新的行为时，如果没有去更新环境声明，编译器将会报错。</li></ul></div><h4 id="变量"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h4><p>当你想告诉 TypeScript 编辑器关于 process 变量时，你可以这么做：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">let</span> process<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>你并不需要为 <code>process</code> 做这些，因为这已经存在于社区维护的 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/index.d.ts" target="_blank" rel="noopener noreferrer"><code>node.d.ts</code></a></p></div><p>这允许你使用 <code>process</code>，并能成功通过 TypeScript 的编译：</p><div class="language-ts"><pre><code>process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们推荐尽可能的使用接口，例如：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Process</span> <span class="token punctuation">{</span>
  <span class="token function">exit</span><span class="token punctuation">(</span>code<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">let</span> process<span class="token operator">:</span> Process<span class="token punctuation">;</span>
</code></pre></div><p>因为这允许其他人扩充这些全局变量，并且会告诉 TypeScript 有关于这些声明的修改。例如：考虑到以下情况，我们添加一个 <code>exitWithLogging</code> 函数至 <code>process</code>：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Process</span> <span class="token punctuation">{</span>
  <span class="token function">exitWithLogging</span><span class="token punctuation">(</span>code<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

process<span class="token punctuation">.</span><span class="token function-variable function">exitWithLogging</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;exiting&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>process<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>接下来，让我们更详细的了解接口。</p><h3 id="接口-1"><a class="header-anchor" href="#接口-1" aria-hidden="true">#</a> 接口</h3><p>接口运行时的影响为 0。在 TypeScript 接口中有很多方式来声明变量的结构。</p><p>下面两个是等效的声明, 示例 A 使用内联注解，示例 B 使用接口形式：</p><div class="language-ts"><pre><code><span class="token comment">// 示例 A</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> myPoint<span class="token operator">:</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 示例 B</span>
<span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> myPoint<span class="token operator">:</span> Point<span class="token punctuation">;</span>
</code></pre></div><p>示例 B 的好处在于，如果有人创建了一个基于 <code>myPoint</code> 的库来添加新成员, 那么他可以轻松将此成员添加到 <code>myPoint</code> 的现有声明中:</p><div class="language-ts"><pre><code><span class="token comment">// Lib a.d.ts</span>
<span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> myPoint<span class="token operator">:</span> Point

<span class="token comment">// Lib b.d.ts</span>
<span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  z<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span>

<span class="token comment">// Your code</span>
myPoint<span class="token punctuation">.</span>z <span class="token comment">// Allowed!</span>
</code></pre></div><p>TypeScript 接口是开放式的，这是 TypeScript 的一个重要原则，它允许你使用接口来模仿 JavaScript 的可扩展性。</p><h4 id="类可以实现接口"><a class="header-anchor" href="#类可以实现接口" aria-hidden="true">#</a> 类可以实现接口</h4><p>如果你希望在类中使用必须要被遵循的接口（类）或别人定义的对象结构，可以使用 <code>implements</code> 关键字来确保其兼容性：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyPoint</span> <span class="token keyword">implements</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// Same as Point</span>
<span class="token punctuation">}</span>
</code></pre></div><p>基本上，在 <code>implements</code>（实现） 存在的情况下，该外部 <code>Point</code> 接口的任何更改都将导致代码库中的编译错误，因此可以轻松地使其保持同步：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  z<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// New member</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyPoint</span> <span class="token keyword">implements</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token comment">// ERROR : missing member `z`</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>注意，<code>implements</code> 限制了类实例的结构，如下所示:</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo<span class="token operator">:</span> Point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但像 <code>foo: Point = MyPoint</code> 这样的代码，与其并不是一回事。</p><h4 id="注意"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> 注意</h4><h5 id="并非每个接口都是很容易实现的"><a class="header-anchor" href="#并非每个接口都是很容易实现的" aria-hidden="true">#</a> 并非每个接口都是很容易实现的</h5><p>接口旨在声明 JavaScript 中可能存在的任意结构。</p><p>思考以下例子，可以使用 <code>new</code> 调用某些内容：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Crazy</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    hello<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可能会有下面这样的代码：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">CrazyClass</span> <span class="token keyword">implements</span> <span class="token class-name">Crazy</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> hello<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Because</span>
<span class="token keyword">const</span> crazy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CrazyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// crazy would be { hello:123 }</span>

<span class="token comment">// 运行报错，因为TS类型检查不会对constructor检查，只会检查和实例相关的属性和方法</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">正常运行</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Crazy</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    hello<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">ICrazyClass</span> <span class="token punctuation">{</span>
  hello<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">CrazyClass</span> <span class="token keyword">implements</span> <span class="token class-name">Crazy</span> <span class="token punctuation">{</span>
  hello<span class="token operator">:</span> <span class="token builtin">number</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hello <span class="token operator">=</span> <span class="token number">123</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ct1</span><span class="token punctuation">(</span>ct<span class="token operator">:</span> Crazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Because</span>
<span class="token keyword">const</span> crazy <span class="token operator">=</span> <span class="token function">ct1</span><span class="token punctuation">(</span>CrazyClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div><p>你可以使用接口声明所有“疯狂的”的 JavaScript 代码，甚至可以安全地在 TypeScript 中使用它们。但这并不意味着你可以使用 TypeScript 类来实现它们。</p><h3 id="枚举"><a class="header-anchor" href="#枚举" aria-hidden="true">#</a> 枚举</h3><p>枚举是组织收集有关联变量的一种方式，许多程序语言（如：c/c#/Java）都有枚举数据类型。下面是定义一个 TypeScript 枚举类型的方式：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> CardSuit <span class="token punctuation">{</span>
  Clubs<span class="token punctuation">,</span>
  Diamonds<span class="token punctuation">,</span>
  Hearts<span class="token punctuation">,</span>
  Spades
<span class="token punctuation">}</span>

<span class="token comment">// 简单的使用枚举类型</span>
<span class="token keyword">let</span> Card <span class="token operator">=</span> CardSuit<span class="token punctuation">.</span>Clubs<span class="token punctuation">;</span>

<span class="token comment">// 类型安全</span>
Card <span class="token operator">=</span> <span class="token string">&#39;not a member of card suit&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error: string 不能赋值给 `CardSuit` 类型</span>
</code></pre></div><p>这些枚举类型的值都是数字类型，因此它们被称为数字类型枚举。</p><h4 id="数字类型枚举与数字类型"><a class="header-anchor" href="#数字类型枚举与数字类型" aria-hidden="true">#</a> 数字类型枚举与数字类型</h4><p>数字类型枚举，允许我们将数字类型或者其他任何与数字类型兼容的类型赋值给枚举类型的实例。</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
  Red<span class="token punctuation">,</span>
  Green<span class="token punctuation">,</span>
  Blue
<span class="token punctuation">}</span>

<span class="token keyword">let</span> col <span class="token operator">=</span> Color<span class="token punctuation">.</span>Red<span class="token punctuation">;</span>
col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 有效的，这也是 Color.Red</span>
</code></pre></div><h4 id="数字类型枚举与自负床类型"><a class="header-anchor" href="#数字类型枚举与自负床类型" aria-hidden="true">#</a> 数字类型枚举与自负床类型</h4><p>在我们继续深入学习枚举类型之前，先来看看它编译的 JavaScript 吧，以下是一个简单的 TypeScript 枚举类型：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Tristate <span class="token punctuation">{</span>
  False<span class="token punctuation">,</span>
  True<span class="token punctuation">,</span>
  Unknown
<span class="token punctuation">}</span>
</code></pre></div><p>其被编译成 JavaScript 后如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">var</span> Tristate<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Tristate<span class="token punctuation">[</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">[</span><span class="token string">&#39;False&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;False&#39;</span><span class="token punctuation">;</span>
  Tristate<span class="token punctuation">[</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">[</span><span class="token string">&#39;True&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;True&#39;</span><span class="token punctuation">;</span>
  Tristate<span class="token punctuation">[</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">[</span><span class="token string">&#39;Unknown&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;Unknown&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Tristate <span class="token operator">||</span> <span class="token punctuation">(</span>Tristate <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>先让我们聚焦 <code>Tristate[Tristate[&#39;False&#39;] = 0] = &#39;False&#39;</code> 这行代码，其中 <code>Tristate[&#39;False&#39;] = 0</code>的意思是将 <code>Tristate</code> 对象里的 <code>False</code> 成员值设置为 <code>0</code>。注意，JavaScript 赋值运算符返回的值是被赋予的值（在此例子中是 <code>0</code>），因此下一次 JavaScript 运行时执行的代码是 <code>Tristate[0] = &#39;False&#39;</code>。意味着你可以使用 <code>Tristate</code> 变量来把字符串枚举类型改造成一个数字或者是数字类型的枚举类型，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Tristate <span class="token punctuation">{</span>
  False<span class="token punctuation">,</span>
  True<span class="token punctuation">,</span>
  Unknown
<span class="token punctuation">}</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;False&#39;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">[</span><span class="token string">&#39;False&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">[</span>Tristate<span class="token punctuation">.</span>False<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;False&#39; because `Tristate.False == 0`</span>
</code></pre></div><h4 id="改变与数字枚举关联的数字"><a class="header-anchor" href="#改变与数字枚举关联的数字" aria-hidden="true">#</a> 改变与数字枚举关联的数字</h4><p>默认情况下，第一个枚举值是 <code>0</code>，然后每个后续值依次递增 1：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
  Red<span class="token punctuation">,</span> <span class="token comment">// 0</span>
  Green<span class="token punctuation">,</span> <span class="token comment">// 1</span>
  Blue <span class="token comment">// 2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，你可以通过特定的赋值来改变给任何枚举成员关联的数字，如下例子，我们从 3 开始依次递增：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
  DarkRed <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token comment">// 3</span>
  DarkGreen<span class="token punctuation">,</span> <span class="token comment">// 4</span>
  DarkBlue <span class="token comment">// 5</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>我通常用 <code>= 1</code> 初始化，因为在枚举类型值里，它能让你做一个安全可靠的检查。</p></div><h4 id="使用数字类型作为标志"><a class="header-anchor" href="#使用数字类型作为标志" aria-hidden="true">#</a> 使用数字类型作为标志</h4><p>枚举的一个很好用途是使用枚举作为标志。这些标志允许你检查一组条件中的某个条件是否为真。考虑如下代码例子，我们有一组关于 animals 的属性：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> AnimalFlags <span class="token punctuation">{</span>
  None        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  HasClaws    <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span>
  CanFly      <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
  EatsFish    <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>
  Endangered  <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里，我们使用了左移的位运算符，将数字 <code>1</code> 的二进制向左移动位置得到数字 <code>0001</code>、<code>0010</code>、<code>0100</code> 和 <code>1000</code>（换成十进制结果是：1, 2, 4, 8）。当你在使用这种标记的时候，这些位运算符 <code>|</code> (或)、<code>&amp;</code> （和）、<code>~ </code>（非）将会是你最好的朋友：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> AnimalFlags <span class="token punctuation">{</span>
  None        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  HasClaws    <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span>
  CanFly      <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  flags<span class="token operator">:</span> AnimalFlags<span class="token punctuation">;</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">printAnimalAbilities</span><span class="token punctuation">(</span>animal<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> animalFlags <span class="token operator">=</span> animal<span class="token punctuation">.</span>flags<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>animalFlags <span class="token operator">&amp;</span> AnimalFlags<span class="token punctuation">.</span>HasClaws<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;animal has claws&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>animalFlags <span class="token operator">&amp;</span> AnimalFlags<span class="token punctuation">.</span>CanFly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;animal can fly&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>animalFlags <span class="token operator">==</span> AnimalFlags<span class="token punctuation">.</span>None<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;nothing&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span> flags<span class="token operator">:</span> AnimalFlags<span class="token punctuation">.</span>None <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printAnimalAbilities</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// nothing</span>
animal<span class="token punctuation">.</span>flags <span class="token operator">|=</span> AnimalFlags<span class="token punctuation">.</span>HasClaws<span class="token punctuation">;</span>
<span class="token function">printAnimalAbilities</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// animal has claws</span>
animal<span class="token punctuation">.</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>AnimalFlags<span class="token punctuation">.</span>HasClaws<span class="token punctuation">;</span>
<span class="token function">printAnimalAbilities</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// nothing</span>
animal<span class="token punctuation">.</span>flags <span class="token operator">|=</span> AnimalFlags<span class="token punctuation">.</span>HasClaws <span class="token operator">|</span> AnimalFlags<span class="token punctuation">.</span>CanFly<span class="token punctuation">;</span>
<span class="token function">printAnimalAbilities</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// animal has claws, animal can fly</span>
</code></pre></div><p>在这里：</p><ul><li>我们使用 <code>|=</code> 来添加一个标志；</li><li>组合使用 <code>&amp;=</code> 和 <code>~</code> 来清理一个标志；</li><li><code>|</code> 来合并标志。</li></ul><div class="language-ts"><pre><code><span class="token keyword">enum</span> AnimalFlags <span class="token punctuation">{</span>
  None        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
  HasClaws    <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span>
  CanFly      <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
  EatsFish    <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>
  Endangered  <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">,</span>

  EndangeredFlyingClawedFishEating <span class="token operator">=</span> HasClaws <span class="token operator">|</span> CanFly <span class="token operator">|</span> EatsFish <span class="token operator">|</span> Endangered
<span class="token punctuation">}</span>
</code></pre></div><h4 id="字符串枚举"><a class="header-anchor" href="#字符串枚举" aria-hidden="true">#</a> 字符串枚举</h4><p>在上文中，我们只看到了数字类型的枚举，实际上，枚举类型的值，也可以是字符串类型。</p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">enum</span> EvidenceTypeEnum <span class="token punctuation">{</span>
  <span class="token constant">UNKNOWN</span> <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>
  <span class="token constant">PASSPORT_VISA</span> <span class="token operator">=</span> <span class="token string">&#39;passport_visa&#39;</span><span class="token punctuation">,</span>
  <span class="token constant">PASSPORT</span> <span class="token operator">=</span> <span class="token string">&#39;passport&#39;</span><span class="token punctuation">,</span>
  <span class="token constant">SIGHTED_STUDENT_CARD</span> <span class="token operator">=</span> <span class="token string">&#39;sighted_tertiary_edu_id&#39;</span><span class="token punctuation">,</span>
  <span class="token constant">SIGHTED_KEYPASS_CARD</span> <span class="token operator">=</span> <span class="token string">&#39;sighted_keypass_card&#39;</span><span class="token punctuation">,</span>
  <span class="token constant">SIGHTED_PROOF_OF_AGE_CARD</span> <span class="token operator">=</span> <span class="token string">&#39;sighted_proof_of_age_card&#39;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些可以更容易被处理和调试，因为它们提供有意义/可调试的字符串。</p><p>你可以使用它们用于简单的字符串比较：</p><div class="language-ts"><pre><code><span class="token comment">// Where `someStringFromBackend` will be &#39;&#39; | &#39;passport_visa&#39; | &#39;passport&#39; ... etc.</span>
<span class="token keyword">const</span> someStringFromBackend<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;passport&quot;</span>
<span class="token keyword">const</span> value <span class="token operator">=</span> someStringFromBackend <span class="token keyword">as</span> EvidenceTypeEnum<span class="token punctuation">;</span>

<span class="token comment">// Sample use in code</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> EvidenceTypeEnum<span class="token punctuation">.</span><span class="token constant">PASSPORT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;You provided a passport&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// `passport`</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="常量枚举"><a class="header-anchor" href="#常量枚举" aria-hidden="true">#</a> 常量枚举</h4><div class="language-ts"><pre><code><span class="token keyword">enum</span> Tristate <span class="token punctuation">{</span>
  False<span class="token punctuation">,</span>
  True<span class="token punctuation">,</span>
  Unknown
<span class="token punctuation">}</span>

<span class="token keyword">const</span> lie <span class="token operator">=</span> Tristate<span class="token punctuation">.</span>False<span class="token punctuation">;</span>
</code></pre></div><p><code>const lie = Tristate.False</code> 会被编译成 JavaScript <code>let lie = Tristate.False</code> (是的，编译后与编译前，几乎相同)。这意味着在运行执行时，它将会查找变量 <code>Tristate</code> 和 <code>Tristate.False</code>。在此处获得性能提升的一个小技巧是使用常量枚举：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> <span class="token keyword">enum</span> Tristate <span class="token punctuation">{</span>
  False<span class="token punctuation">,</span>
  True<span class="token punctuation">,</span>
  Unknown
<span class="token punctuation">}</span>

<span class="token keyword">const</span> lie <span class="token operator">=</span> Tristate<span class="token punctuation">.</span>False<span class="token punctuation">;</span>
</code></pre></div><p>将会被编译成：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> lie <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p>编译器将会：</p><ul><li>内联枚举的任何用法（<code>0</code> 而不是 <code>Tristate.False</code>）；</li><li>不会为枚举类型编译成任何 JavaScript（在这个例子中，运行时没有 <code>Tristate</code> 变量），因为它使用内联语法。</li></ul><h5 id="常量枚举-preserveconstenums-选项"><a class="header-anchor" href="#常量枚举-preserveconstenums-选项" aria-hidden="true">#</a> 常量枚举 <code>preserveConstEnums</code> 选项</h5><p>使用内联语法对性能有明显的提升作用。运行时没有 <code>Tristate</code> 变量的事实，是因为编译器帮助你把一些在运行时没有用到的不编译成 JavaScript。然而，你可能想让编译器仍然把枚举类型编译成 JavaScript，用于如上例子中从字符串到数字，或者是从数字到字符串的查找。在这种情景下，你可以使用编译选项 <code>--preserveConstEnums</code>，它会编译出 <code>var Tristate</code> 的定义，因此你在运行时，手动使用 <code>Tristate[&#39;False&#39;]</code> 和 <code>Tristate[0]</code>。并且这不会以任何方式影响内联。</p><h4 id="有静态方法的枚举"><a class="header-anchor" href="#有静态方法的枚举" aria-hidden="true">#</a> 有静态方法的枚举</h4><p>你可以使用 <code>enum</code> + <code>namespace</code> 的声明的方式向枚举类型添加静态方法。如下例所示，我们将静态成员 <code>isBusinessDay</code> 添加到枚举上：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Weekday <span class="token punctuation">{</span>
  Monday<span class="token punctuation">,</span>
  Tuesday<span class="token punctuation">,</span>
  Wednesday<span class="token punctuation">,</span>
  Thursday<span class="token punctuation">,</span>
  Friday<span class="token punctuation">,</span>
  Saturday<span class="token punctuation">,</span>
  Sunday
<span class="token punctuation">}</span>

<span class="token keyword">namespace</span> Weekday <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isBusinessDay</span><span class="token punctuation">(</span>day<span class="token operator">:</span> Weekday<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> Weekday<span class="token punctuation">.</span>Saturday<span class="token operator">:</span>
      <span class="token keyword">case</span> Weekday<span class="token punctuation">.</span>Sunday<span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> mon <span class="token operator">=</span> Weekday<span class="token punctuation">.</span>Monday<span class="token punctuation">;</span>
<span class="token keyword">const</span> sun <span class="token operator">=</span> Weekday<span class="token punctuation">.</span>Sunday<span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Weekday<span class="token punctuation">.</span><span class="token function">isBusinessDay</span><span class="token punctuation">(</span>mon<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Weekday<span class="token punctuation">.</span><span class="token function">isBusinessDay</span><span class="token punctuation">(</span>sun<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="开放式枚举"><a class="header-anchor" href="#开放式枚举" aria-hidden="true">#</a> 开放式枚举</h4><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>你只有在不使用模块时，开放式的枚举才有意义，你应该使用模块，因此这部分在文章最后。</p></div><p>让我们再一次看看编译成 JavaScript 的枚举是什么样子：</p><div class="language-ts"><pre><code><span class="token keyword">var</span> Tristate<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Tristate<span class="token punctuation">[</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">[</span><span class="token string">&#39;False&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;False&#39;</span><span class="token punctuation">;</span>
  Tristate<span class="token punctuation">[</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">[</span><span class="token string">&#39;True&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;True&#39;</span><span class="token punctuation">;</span>
  Tristate<span class="token punctuation">[</span><span class="token punctuation">(</span>Tristate<span class="token punctuation">[</span><span class="token string">&#39;Unknown&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;Unknown&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Tristate <span class="token operator">||</span> <span class="token punctuation">(</span>Tristate <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们已经解释了 <code>Tristate[Tristate[&#39;False&#39;] = 0] = &#39;False&#39;</code> 部分，现在我们来看看包裹函数 <code>(function (Tristate) { /* code here */})(Tristate || (Tristate = {}))</code>，特别是 <code>(Tristate || (Tristate = {}))</code> 部分。这捕获了一个局部变量 <code>TriState</code>，它要么指向已经定义的 <code>TriState</code> 值，要么使用一个新的空对象来初始化它。</p><p>这意味着你可以跨多个文件拆分（和扩展）枚举定义，如下所示，你可以把 <code>Color</code> 的定义拆分至两个块中：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
  Red<span class="token punctuation">,</span>
  Green<span class="token punctuation">,</span>
  Blue
<span class="token punctuation">}</span>

<span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
  DarkRed <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
  DarkGreen<span class="token punctuation">,</span>
  DarkBlue
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>你应该在枚举的延续块中，重新初始化第一个成员（此处为 <code>DarkRed = 3</code>），使生成的代码不破坏先前定义的值（即0、1...等值）。如果您仍然不这样做，TypeScript 将会发出警告（错误信息：<code>In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.</code>）。</p></div><h3 id="lib-d-ts"><a class="header-anchor" href="#lib-d-ts" aria-hidden="true">#</a> <code>lib.d.ts</code></h3><p>当你安装 <code>TypeScript</code> 时，会顺带安装一个 <code>lib.d.ts</code> 声明文件。这个文件包含 JavaScript 运行时以及 DOM 中存在各种常见的环境声明。</p><ul><li>它自动包含在 <code>TypeScript</code> 项目的编译上下文中；</li><li>它能让你快速开始书写经过类型检查的 JavaScript 代码。</li></ul><p>你可以通过指定 <code>--noLib</code> 的编译器命令行标志（或者在 <code>tsconfig.json</code> 中指定选项 <code>noLib: true</code>）从上下文中排除此文件。</p><h4 id="使用例子"><a class="header-anchor" href="#使用例子" aria-hidden="true">#</a> 使用例子</h4><p>看如下例子：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码的类型检查正常，因为 <code>lib.d.ts</code> 为所有 JavaScript 对象定义了 <code>toString</code> 方法。</p><p>如果你在 <code>noLib</code> 选项下，使用相同的代码，这将会出现类型检查错误：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 属性 toString 不存在类型 number 上</span>
</code></pre></div><p>现在你已经理解了 <code>lib.d.ts</code> 的重要性，至于它的内容是怎么样的，我们接下来将会解释。</p><h4 id="观察-lib-d-ts-的内容"><a class="header-anchor" href="#观察-lib-d-ts-的内容" aria-hidden="true">#</a> 观察 <code>lib.d.ts</code> 的内容</h4><p><code>lib.d.ts</code> 的内容主要是一些变量声明（如：<code>window</code>、<code>document</code>、<code>math</code>）和一些类似的接口声明（如：<code>Window</code>、<code>Document</code>、<code>Math</code>）。</p><p>寻找代码类型（如：<code>Math.floor</code>）的最简单方式是使用 IDE 的 <code>F12</code>（跳转到定义）。</p><p>让我们来看一个变量声明的示例，如 <code>window</code> 被定义为：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">var</span> window<span class="token operator">:</span> Window<span class="token punctuation">;</span>
</code></pre></div><p>这只是一个简单的 <code>declare var</code>，后面跟一个变量名称（<code>window</code>）和一个用来类型注解的接口（<code>Window</code>），这些变量通常指向一些全局的接口，例如，以下是 <code>Window</code> 接口的一小部分：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Window</span>
  <span class="token keyword">extends</span> <span class="token class-name">EventTarget</span><span class="token punctuation">,</span>
    WindowTimers<span class="token punctuation">,</span>
    WindowSessionStorage<span class="token punctuation">,</span>
    WindowLocalStorage<span class="token punctuation">,</span>
    WindowConsole<span class="token punctuation">,</span>
    GlobalEventHandlers<span class="token punctuation">,</span>
    IDBEnvironment<span class="token punctuation">,</span>
    WindowBase64 <span class="token punctuation">{</span>
  animationStartTime<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  applicationCache<span class="token operator">:</span> ApplicationCache<span class="token punctuation">;</span>
  clientInformation<span class="token operator">:</span> Navigator<span class="token punctuation">;</span>
  closed<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  crypto<span class="token operator">:</span> Crypto<span class="token punctuation">;</span>
  <span class="token comment">// so on and so forth...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可以在这些接口里看到大量的类型信息，当你不使用 TypeScript 时，你需要将它们保存在你的大脑里。现在你可以使用 <code>intellisense</code> 之类东西，从而可以减少对知识的记忆。</p><p>使用这些全局变量是有利的。在不更改 <code>lib.d.ts</code> 的情况下，它可以让你添加额外的属性。接下来，我们将介绍这些概念。</p><h4 id="修改原始类型"><a class="header-anchor" href="#修改原始类型" aria-hidden="true">#</a> 修改原始类型</h4><p>在 TypeScript 中，接口是开放式的，这意味着当你想使用不存在的成员时，只需要将它们添加至 <code>lib.d.ts</code> 中的接口声明中即可，TypeScript 将会自动接收它。注意，你需要在<a href="#%E5%85%A8%E5%B1%80%E6%A8%A1%E5%9D%97">全局模块</a>中做这些修改，以使这些接口与 <code>lib.d.ts</code> 相关联。我们推荐你创建一个称为 <code>global.d.ts</code> 的特殊文件。</p><p>这里有我们需要添加至 <code>Window</code>，<code>Math</code>，<code>Date</code> 的一些例子：</p><h5 id="window"><a class="header-anchor" href="#window" aria-hidden="true">#</a> Window</h5><p>仅仅是添加至 <code>Window</code> 接口：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  <span class="token function">helloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这将允许你以类型安全的形式使用它：</p><div class="language-ts"><pre><code><span class="token comment">// Add it at runtime</span>
window<span class="token punctuation">.</span><span class="token function-variable function">helloWorld</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Call it</span>
window<span class="token punctuation">.</span><span class="token function">helloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 滥用会导致错误</span>
window<span class="token punctuation">.</span><span class="token function">helloWorld</span><span class="token punctuation">(</span><span class="token string">&#39;gracius&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 提供的参数与目标不匹配</span>
</code></pre></div><h5 id="math"><a class="header-anchor" href="#math" aria-hidden="true">#</a> Math</h5><p>全局变量 <code>Math</code> 在 <code>lib.d.ts</code> 中被定义为：</p><div class="language-ts"><pre><code><span class="token comment">/** An intrinsic object that provides basic mathematics functionality and constants. */</span>
<span class="token keyword">declare</span> <span class="token keyword">var</span> Math<span class="token operator">:</span> Math<span class="token punctuation">;</span>
</code></pre></div><p>即变量 Math 是 Math 的一个实例，Math 接口被定义为：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Math</span> <span class="token punctuation">{</span>
  <span class="token constant">E</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token constant">LN10</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token comment">// others ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当你想在 <code>Math</code> 全局变量上添加你需要的属性时，你只需要把它添加到 <code>Math</code> 的全局接口上即可，例如：在<a href="https://www.npmjs.com/package/seedrandom" target="_blank" rel="noopener noreferrer">seedrandom Project</a>项目里，它添加了 <code>seedrandom</code> 函数至全局的 <code>Math</code> 对象上，这很容易被声明：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Math</span> <span class="token punctuation">{</span>
  <span class="token function">seedrandom</span><span class="token punctuation">(</span>seed<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可以像下面一样使用它：</p><div class="language-ts"><pre><code>Math<span class="token punctuation">.</span><span class="token function">seedrandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Math<span class="token punctuation">.</span><span class="token function">seedrandom</span><span class="token punctuation">(</span><span class="token string">&#39;Any string you want&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="date"><a class="header-anchor" href="#date" aria-hidden="true">#</a> Date</h5><p>如果你在 <code>lib.d.ts</code> 中寻找 <code>Date</code> 定义的声明，你将会找到如下代码：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">var</span> Date<span class="token operator">:</span> DateConstructor<span class="token punctuation">;</span>
</code></pre></div><p>接口 <code>DateConstructor</code> 与上文中 <code>Math</code> 和 <code>Window</code> 接口一样，它涵盖了可以使用的 <code>Date</code> 全局变量的成员（如：<code>Date.now()</code>）。除此之外，它还包含了可以让你创建 <code>Date</code> 实例的构造函数签名（如：<code>new Date()</code>）。<code>DateConstructor</code> 接口的一部分代码如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">DateConstructor</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Date<span class="token punctuation">;</span>
  <span class="token comment">// 一些其他的构造函数签名</span>

  <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

  <span class="token comment">// 其他成员函数</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 <a href="https://github.com/abritinthebay/datejs" target="_blank" rel="noopener noreferrer">datejs</a> 里，它在 Date 的全局变量以及 Date 实例上同时添加了成员，因此这个库的 TypeScript 定义看起来像如下所示（社区已经<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/datejs/index.d.ts" target="_blank" rel="noopener noreferrer">定义</a>好了）：</p><div class="language-ts"><pre><code><span class="token comment">// DateJS 公开的静态方法</span>
<span class="token keyword">interface</span> <span class="token class-name">DateConstructor</span> <span class="token punctuation">{</span>
  <span class="token comment">/** Gets a date that is set to the current date. The time is set to the start of the day (00:00 or 12:00 AM) */</span>
  <span class="token function">today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Date<span class="token punctuation">;</span>
  <span class="token comment">// ... so on and so forth</span>
<span class="token punctuation">}</span>

<span class="token comment">// DateJS 公开的实例方法</span>
<span class="token keyword">interface</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>
  <span class="token comment">/** Adds the specified number of milliseconds to this instance. */</span>
  <span class="token function">addMilliseconds</span><span class="token punctuation">(</span>milliseconds<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> Date<span class="token punctuation">;</span>
  <span class="token comment">// ... so on and so forth</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这允许你在类型安全的情况下做：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> today <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> todayAfter1second <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">addMilliseconds</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="string"><a class="header-anchor" href="#string" aria-hidden="true">#</a> string</h5><p>如果你在 <code>lib.d.ts</code> 里寻找 <code>string</code>，你将会找到与 <code>Date</code> 相类似的内容（全局变量 <code>String</code>，StringConstructor 接口，<code>String</code> 接口）。但值得注意的是，<code>String</code> 接口也会影响字符串字面量，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
  <span class="token function">endsWith</span><span class="token punctuation">(</span>suffix<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

String<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">endsWith</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>suffix<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> str <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>suffix<span class="token punctuation">,</span> str<span class="token punctuation">.</span>length <span class="token operator">-</span> suffix<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo bar&#39;</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&#39;bas&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo bas&#39;</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&#39;bas&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h5 id="终极-string"><a class="header-anchor" href="#终极-string" aria-hidden="true">#</a> 终极 string</h5><p>基于可维护性，我们推荐创建一个 <code>global.d.ts</code> 文件。然而，如果你愿意，你可以通过使用 <code>declare global { /* global namespace */ }</code>，从文件模块中进入全局命名空间：</p><div class="language-ts"><pre><code><span class="token comment">// 确保是模块</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">declare</span> global <span class="token punctuation">{</span>
  <span class="token keyword">interface</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token function">endsWith</span><span class="token punctuation">(</span>suffix<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

String<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">endsWith</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>suffix<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> str <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>suffix<span class="token punctuation">,</span> str<span class="token punctuation">.</span>length <span class="token operator">-</span> suffix<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo bar&#39;</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&#39;bas&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo bas&#39;</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&#39;bas&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h4 id="使用你自己定义的-lib-d-ts"><a class="header-anchor" href="#使用你自己定义的-lib-d-ts" aria-hidden="true">#</a> 使用你自己定义的 lib.d.ts</h4><p>正如上文所说，使用 <code>--noLib</code> 编译选项会导致 TypeScript 排除自动包含的 <code>lib.d.ts</code> 文件。为什么这个功能是有效的，我例举了一些常见原因：</p><ul><li>运行的 JavaScript 环境与基于标准浏览器运行时环境有很大不同；</li><li>你希望在代码里严格的控制全局变量，例如：<code>lib.d.ts</code> 将 <code>item</code> 定义为全局变量，你不希望它泄漏到你的代码里。</li></ul><p>一旦你排除了默认的 <code>lib.d.ts</code> 文件，你就可以在编译上下文中包含一个命名相似的文件，TypeScript 将提取该文件进行类型检查。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>小心使用 <code>--noLib</code> 选项，一旦你使用了它，当你把你的项目分享给其他人时，它们也将被迫使用 <code>--noLib</code> 选项，更糟糕的是，如果将这些代码放入你的项目中，你可能需要将它们移植到基于你的代码的 <code>lib</code> 中。</p></div><h4 id="编译目标对-lib-d-ts-的影响"><a class="header-anchor" href="#编译目标对-lib-d-ts-的影响" aria-hidden="true">#</a> 编译目标对 <code>lib.d.ts</code> 的影响</h4><p>设置编译目标为 <code>es6</code> 时，能导致 <code>lib.d.ts</code> 包含更多像 Promise 现代（es6）内容的环境声明。编译器目标的这种作用，改变了代码的环境，这对某些人来说是理想的，但是这对另外一些人来说造成了困扰，因为它将编译出的代码与环境混为一谈。</p><p>当你想对环境进行更细粒的控制时，你应该使用我们接下来将要讨论的 <code>--lib</code> 选项。</p><h4 id="lib-选项"><a class="header-anchor" href="#lib-选项" aria-hidden="true">#</a> <code>--lib</code> 选项</h4><p>有时，你想要解耦编译目标（即生成的 JavaScript 版本）和环境库支持之间的关系。例如对于 Promise，你的编译目标是 <code>--target es5</code>，但是你仍然想使用它，这时，你可以使用 <code>lib</code> 对它进行控制。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>使用 --lib 选项可以将任何 lib 与 --target 解耦。</p></div><p>你可以通过命令行或者在 <code>tsconfig.json</code> 中提供此选项（推荐）：</p><h5 id="命令行"><a class="header-anchor" href="#命令行" aria-hidden="true">#</a> 命令行</h5><div class="language-shell"><pre><code>tsc --target es5 --lib dom,es6
</code></pre></div><h5 id="config-json"><a class="header-anchor" href="#config-json" aria-hidden="true">#</a> config.json</h5><div class="language-json"><pre><code><span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">&quot;lib&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;dom&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es6&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>lib</code> 分类如下：</p><ul><li>JavaScript 功能 <ul><li>es5</li><li>es6</li><li>es2015</li><li>es7</li><li>es2016</li><li>es2017</li><li>esnext</li></ul></li><li>运行环境 <ul><li>dom</li><li>dom.iterable</li><li>webworker</li><li>scripthost</li></ul></li><li>ESNext 功能选项 <ul><li>es2015.core</li><li>es2015.collection</li><li>es2015.generator</li><li>es2015.iterable</li><li>es2015.promise</li><li>es2015.proxy</li><li>es2015.reflect</li><li>es2015.symbol</li><li>es2015.symbol.wellknown</li><li>es2016.array.include</li><li>es2017.object</li><li>es2017.sharedmemory</li><li>esnext.asynciterable</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>--lib</code> 选项提供非常精细的控制，因此你最有可能从运行环境与 JavaScript 功能类别中分别选择一项，如果你没有指定 <code>--lib</code>，则会导入默认库：</p><ul><li><code>--target</code> 选项为 es5 时，会导入 es5, dom, scripthost。</li><li><code>--target</code> 选项为 es6 时，会导入 es6, dom, dom.iterable, scripthost。</li></ul></div><p>我个人的推荐：</p><div class="language-json"><pre><code><span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">&quot;target&quot;</span><span class="token operator">:</span> <span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;lib&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;es6&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dom&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>包括使用 Symbol 的 ES5 使用例子：</p><div class="language-json"><pre><code><span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">&quot;target&quot;</span><span class="token operator">:</span> <span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;lib&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dom&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;scripthost&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es2015.symbol&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="在旧的-javascript-引擎时使用-polyfill"><a class="header-anchor" href="#在旧的-javascript-引擎时使用-polyfill" aria-hidden="true">#</a> 在旧的 JavaScript 引擎时使用 Polyfill</h4><p>要使用一些新功能如 <code>Map</code>、<code>Set</code>、<code>Promise</code>（随着时间推移会变化），你可以使用现代的 <code>lib</code> 选项，并且需要安装 <code>core-js</code>：</p><div class="language-shell"><pre><code><span class="token function">npm</span> <span class="token function">install</span> core-js --save-dev
</code></pre></div><p>接着，在你的项目里导入它：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token string">&#39;core-js&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="函数"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h3><p>函数类型在 TypeScript 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块。</p><h4 id="参数注解"><a class="header-anchor" href="#参数注解" aria-hidden="true">#</a> 参数注解</h4><p>你可以注解函数参数，就像你可以注解其他变量一样:</p><div class="language-ts"><pre><code><span class="token comment">// variable annotation</span>
<span class="token keyword">let</span> sampleVariable<span class="token operator">:</span> <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// function parameter annotation</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>sampleParameter<span class="token operator">:</span> <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>这里我们使用了内联类型注解，除此之外，你还可以使用接口等其他方式。</p><h5 id="返回类型注解"><a class="header-anchor" href="#返回类型注解" aria-hidden="true">#</a> 返回类型注解</h5><p>你可以在函数参数列表之后使用与变量相同的样式来注解返回类型，如例子中 <code>：Foo</code>：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Return type annotated as `: Foo`</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>sample<span class="token operator">:</span> Foo<span class="token punctuation">)</span><span class="token operator">:</span> Foo <span class="token punctuation">{</span>
  <span class="token keyword">return</span> sample<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们在这里使用了一个 <code>interface</code>，但你可以自由地使用其他注解方式，例如内联注解。</p><p>通常，你不需要注解函数的返回类型，因为它可以由编译器推断：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>sample<span class="token operator">:</span> Foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> sample<span class="token punctuation">;</span> <span class="token comment">// inferred return type &#39;Foo&#39;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，添加这些注解以帮助解决错误提示通常是一个好主意，例如：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> fou<span class="token operator">:</span> <span class="token string">&#39;John Doe&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// You might not find this misspelling of `foo` till it&#39;s too late</span>
<span class="token punctuation">}</span>

<span class="token function">sendAsJSON</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你不打算从函数返回任何内容，则可以将其标注为：<code>void</code> 。你通常可以删除 <code>void</code>， TypeScript 能推导出来：</p><h5 id="可选参数"><a class="header-anchor" href="#可选参数" aria-hidden="true">#</a> 可选参数</h5><p>你可以将参数标记为可选:</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bas<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// ..</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>或者，当调用者没有提供该参数时，你可以提供一个默认值（在参数声明后使用 <code>= someValue</code> ）：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bas<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> bas<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123, hello</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">&#39;world&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123, world</span>
</code></pre></div><h5 id="重载"><a class="header-anchor" href="#重载" aria-hidden="true">#</a> 重载</h5><p>TypeScript 允许你声明函数重载。这对于文档 + 类型安全来说很实用。请思考以下代码：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">padding</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> c<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> d<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> d <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">=</span> c <span class="token operator">=</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> d <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">=</span> a<span class="token punctuation">;</span>
    d <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    top<span class="token operator">:</span> a<span class="token punctuation">,</span>
    right<span class="token operator">:</span> b<span class="token punctuation">,</span>
    bottom<span class="token operator">:</span> c<span class="token punctuation">,</span>
    left<span class="token operator">:</span> d
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果仔细查看代码，就会发现 a，b，c，d 的值会根据传入的参数数量而变化。此函数也只需要 1 个，2 个或 4 个参数。可以使用函数重载来<em>强制</em>和<em>记录</em>这些约束。你只需多次声明函数头。最后一个函数头是在函数体内实际处于活动状态但不可用于外部。</p><p>如下所示:</p><div class="language-ts"><pre><code><span class="token comment">// 重载</span>
<span class="token keyword">function</span> <span class="token function">padding</span><span class="token punctuation">(</span>all<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">padding</span><span class="token punctuation">(</span>topAndBottom<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> leftAndRight<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">padding</span><span class="token punctuation">(</span>top<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> right<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> bottom<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> left<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Actual implementation that is a true representation of all the cases the function body needs to handle</span>
<span class="token keyword">function</span> <span class="token function">padding</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> c<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> d<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> d <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">=</span> c <span class="token operator">=</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> d <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">=</span> a<span class="token punctuation">;</span>
    d <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    top<span class="token operator">:</span> a<span class="token punctuation">,</span>
    right<span class="token operator">:</span> b<span class="token punctuation">,</span>
    bottom<span class="token operator">:</span> c<span class="token punctuation">,</span>
    left<span class="token operator">:</span> d
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里前三个函数头可有效调用 <code>padding</code>:</p><div class="language-ts"><pre><code><span class="token function">padding</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Okay: all</span>
<span class="token function">padding</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Okay: topAndBottom, leftAndRight</span>
<span class="token function">padding</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Okay: top, right, bottom, left</span>

<span class="token function">padding</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: Not a part of the available overloads</span>
</code></pre></div><p>当然，最终声明（从函数内部看到的真正声明）与所有重载兼容是很重要的。这是因为这是函数体需要考虑的函数调用的真实性质。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>TypeScript 中的函数重载没有任何运行时开销。它只允许你记录希望调用函数的方式，并且编译器会检查其余代码。</p></div><h5 id="函数声明"><a class="header-anchor" href="#函数声明" aria-hidden="true">#</a> 函数声明</h5><blockquote><p>快速开始：类型注解是你描述现有实现类型的一种方式</p></blockquote><p>在没有提供函数实现的情况下，有两种声明函数类型的方式:</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">LongHand</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">ShortHand</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码中的两个例子完全相同。但是，当你想使用函数重载时，只能用第一种方式:</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">LongHandAllowsOverloadDeclarations</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="可调用的"><a class="header-anchor" href="#可调用的" aria-hidden="true">#</a> 可调用的</h3><p>你可以使用类型别名或者接口来表示一个可被调用的类型注解：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">ReturnString</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它可以表示一个返回值为 <code>string</code> 的函数：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">const</span> foo<span class="token operator">:</span> ReturnString<span class="token punctuation">;</span>

<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar 被推断为一个字符串。</span>
</code></pre></div><h4 id="一个实际的例子"><a class="header-anchor" href="#一个实际的例子" aria-hidden="true">#</a> 一个实际的例子</h4><p>当然，像这样一个可被调用的类型注解，你也可以根据实际来传递任何参数、可选参数以及 rest 参数，这有一个稍微复杂的例子：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Complex</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token operator">...</span>others<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个接口可提供多种调用签名，用以特殊的函数重载：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Overloaded</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实现接口的一个例子：</span>
<span class="token keyword">function</span> <span class="token function">stringOrNumber</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">stringOrNumber</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">stringOrNumber</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> foo <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> foo <span class="token operator">*</span> foo<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> foo <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>foo<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> overloaded<span class="token operator">:</span> Overloaded <span class="token operator">=</span> stringOrNumber<span class="token punctuation">;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token function">overloaded</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// str 被推断为 &#39;string&#39;</span>
<span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token function">overloaded</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// num 被推断为 &#39;number&#39;</span>
</code></pre></div><p>这也可以用于内联注解中：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> overloaded<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="箭头函数"><a class="header-anchor" href="#箭头函数" aria-hidden="true">#</a> 箭头函数</h4><p>为了使指定可调用的类型签名更容易，TypeScript 也允许你使用简单的箭头函数类型注解。例如，在一个以 number 类型为参数，以 string 类型为返回值的函数中，你可以这么写：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> <span class="token function-variable function">simple</span><span class="token operator">:</span> <span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function-variable function">string</span> <span class="token operator">=</span> foo <span class="token operator">=&gt;</span> foo<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>它仅仅只能作为简单的箭头函数，你无法使用重载。如果想使用重载，你必须使用完整的 <code>{ (someArgs): someReturn }</code> 的语法</p></div><h4 id="可实例化"><a class="header-anchor" href="#可实例化" aria-hidden="true">#</a> 可实例化</h4><p>可实例化仅仅是可调用的一种特殊情况，它使用 <code>new</code> 作为前缀。它意味着你需要使用 <code>new</code> 关键字去调用它：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">CallMeWithNewToGetString</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> Foo<span class="token operator">:</span> CallMeWithNewToGetString<span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar 被推断为 string 类型</span>
</code></pre></div><h3 id="类型断言"><a class="header-anchor" href="#类型断言" aria-hidden="true">#</a> 类型断言</h3><p>TypeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」。TypeScript 类型断言用来告诉编译器你比它更了解这个类型，并且它不应该再发出错误。</p><p>类型断言的一个常见用例是当你从 JavaScript 迁移到 TypeScript 时：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// Error: &#39;bar&#39; 属性不存在于 ‘{}’</span>
foo<span class="token punctuation">.</span>bas <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error: &#39;bas&#39; 属性不存在于 &#39;{}&#39;</span>
</code></pre></div><p>这里的代码发出了错误警告，因为 <code>foo</code> 的类型推断为 <code>{}</code>，即没有属性的对象。因此，你不能在它的属性上添加 <code>bar</code> 或 <code>bas</code>，你可以通过类型断言来避免此问题：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  bas<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Foo<span class="token punctuation">;</span>
foo<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span>bas <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="as-foo-与-foo"><a class="header-anchor" href="#as-foo-与-foo" aria-hidden="true">#</a> <code>as foo</code> 与 <code>&lt;foo&gt;</code></h4><p>最初的断言语法如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span>foo<span class="token punctuation">;</span> <span class="token comment">// 现在 bar 的类型是 &#39;string&#39;</span>
</code></pre></div><p>然而，当你在 JSX 中使用 <code>&lt;foo&gt;</code> 的断言语法时，这会与 JSX 的语法存在歧义：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span>bar<span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>因此，为了一致性，我们建议你使用 <code>as foo</code> 的语法来为类型断言。</p><h4 id="类型断言与类型转换"><a class="header-anchor" href="#类型断言与类型转换" aria-hidden="true">#</a> 类型断言与类型转换</h4><p>它之所以不被称为「类型转换」，是因为转换通常意味着某种运行时的支持。但是，类型断言纯粹是一个编译时语法，同时，它也是一种为编译器提供关于如何分析代码的方法。</p><h4 id="类型断言被认为是有害的"><a class="header-anchor" href="#类型断言被认为是有害的" aria-hidden="true">#</a> 类型断言被认为是有害的</h4><p>在很多情景下，断言能让你更容易的从遗留项目中迁移（甚至将其他代码粘贴复制到你的项目中），然而，你应该小心谨慎的使用断言。让我们用最初的代码作为示例，如果你没有按约定添加属性，TypeScript 编译器并不会对此发出错误警告：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  bas<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> Foo<span class="token punctuation">;</span>

<span class="token comment">// ahhh, 忘记了什么？</span>
</code></pre></div><p>另外一个常见的想法是使用类型断言来提供代码的提示：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  bas<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token punctuation">{</span>
  <span class="token comment">// 编译器将会提供关于 Foo 属性的代码提示</span>
  <span class="token comment">// 但是开发人员也很容易忘记添加所有的属性</span>
  <span class="token comment">// 同样，如果 Foo 被重构，这段代码也可能被破坏（例如，一个新的属性被添加）。</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这也会存在一个同样的问题，如果你忘记了某个属性，编译器同样也不会发出错误警告。使用一种更好的方式：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  bas<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 编译器将会提供 Foo 属性的代码提示</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在某些情景下，你可能需要创建一个临时的变量，但至少，你不会使用一个承诺（可能是假的），而是依靠类型推断来检查你的代码。</p><h4 id="双重断言"><a class="header-anchor" href="#双重断言" aria-hidden="true">#</a> 双重断言</h4><p>类型断言，尽管我们已经证明了它并不是那么安全，但它也还是有用武之地。如下一个非常实用的例子所示，当使用者了解传入参数更具体的类型时，类型断言能按预期工作：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> mouseEvent <span class="token operator">=</span> event <span class="token keyword">as</span> MouseEvent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然而，如下例子中的代码将会报错，尽管使用者已经使用了类型断言：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> event <span class="token keyword">as</span> HTMLElement<span class="token punctuation">;</span> <span class="token comment">// Error: &#39;Event&#39; 和 &#39;HTMLElement&#39; 中的任何一个都不能赋值给另外一个</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果你仍然想使用那个类型，你可以使用双重断言。首先断言成兼容所有类型的 <code>any</code>，编译器将不会报错：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">(</span>event <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token keyword">as</span> HTMLElement<span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="typescript-是怎么确定单个判断是否足够"><a class="header-anchor" href="#typescript-是怎么确定单个判断是否足够" aria-hidden="true">#</a> TypeScript 是怎么确定单个判断是否足够</h5><p>当 <code>S</code> 类型是 <code>T</code> 类型的子集，或者 <code>T</code> 类型是 <code>S</code> 类型的子集时，<code>S</code> 能被成功断言成 <code>T</code>。这是为了在进行类型断言时提供额外的安全性，完全毫无根据的断言是危险的，如果你想这么做，你可以使用 <code>any</code>。</p><h3 id="freshness"><a class="header-anchor" href="#freshness" aria-hidden="true">#</a> Freshness</h3><p>为了能让检查对象字面量类型更容易，TypeScript 提供 「<a href="https://github.com/Microsoft/TypeScript/pull/3823" target="_blank" rel="noopener noreferrer">Freshness</a>」 的概念（它也被称为更严格的对象字面量检查）用来确保对象字面量在结构上类型兼容。</p><p>结构类型非常方便。考虑如下例子代码，它可以让你非常便利的从 JavaScript 迁移至 TypeScript，并且会提供类型安全：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">logName</span><span class="token punctuation">(</span>something<span class="token operator">:</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>something<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;matt&#39;</span><span class="token punctuation">,</span> job<span class="token operator">:</span> <span class="token string">&#39;being awesome&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;cow&#39;</span><span class="token punctuation">,</span> diet<span class="token operator">:</span> <span class="token string">&#39;vegan, but has milk of own specie&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> randow <span class="token operator">=</span> <span class="token punctuation">{</span> note<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">I don&#39;t have a name property</span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">logName</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token function">logName</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token function">logName</span><span class="token punctuation">(</span>randow<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 没有 `name` 属性</span>
</code></pre></div><p>但是，结构类型有一个缺点，它能误导你认为某些东西接收的数据比它实际的多。如下例，TypeScript 发出错误警告：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">logName</span><span class="token punctuation">(</span>something<span class="token operator">:</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>something<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">logName</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;matt&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token function">logName</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;matt&#39;</span><span class="token punctuation">,</span> job<span class="token operator">:</span> <span class="token string">&#39;being awesome&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 对象字面量只能指定已知属性，`job` 属性在这里并不存在。</span>
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>请注意，这种错误提示，只会发生在对象字面量上。</p></div><p>如果没有这种错误提示，我们可能会去寻找函数的调用 <code>logName({ name: &#39;matt&#39;, job: &#39;being awesome&#39; })</code>，继而会认为 <code>logName</code> 可能会使用 <code>job</code> 属性做一些事情，然而实际上 <code>logName</code> 并没有使用它。</p><p>另外一个使用比较多的场景是与具有可选成员的接口一起使用，如果没有这样的对象字面量检查，当你输入错误单词的时候，并不会发出错误警告：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">logIfHasName</span><span class="token punctuation">(</span>something<span class="token operator">:</span> <span class="token punctuation">{</span> name<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>something<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>something<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;matt&#39;</span><span class="token punctuation">,</span> job<span class="token operator">:</span> <span class="token string">&#39;being awesome&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;cow&#39;</span><span class="token punctuation">,</span> diet<span class="token operator">:</span> <span class="token string">&#39;vegan, but has milk of own species&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">logIfHasName</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay</span>
<span class="token function">logIfHasName</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay</span>

<span class="token function">logIfHasName</span><span class="token punctuation">(</span><span class="token punctuation">{</span> neme<span class="token operator">:</span> <span class="token string">&#39;I just misspelled name to neme&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 对象字面量只能指定已知属性，`neme` 属性不存在。</span>
</code></pre></div><p>之所以只对对象字面量进行类型检查，因为在这种情况下，那些实际上并没有被使用到的属性有可能会拼写错误或者会被误用。</p><h4 id="允许额外的属性"><a class="header-anchor" href="#允许额外的属性" aria-hidden="true">#</a> 允许额外的属性</h4><p>一个类型能够包含索引签名，以明确表明可以使用额外的属性：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> baz<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ok, &#39;baz&#39; 属性匹配于索引签名</span>
</code></pre></div><h4 id="用例-react-state"><a class="header-anchor" href="#用例-react-state" aria-hidden="true">#</a> 用例: React State</h4><p>Facebook ReactJS 为对象的 Freshness 提供了一个很好的用例，通常在组件中，你只使用少量属性，而不是传入所有，来调用 <code>setState</code>：</p><div class="language-ts"><pre><code><span class="token comment">// 假设</span>
<span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  bar<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 你可能想做：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">&#39;Hello&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 没有属性 &#39;bar&#39;</span>

<span class="token comment">// 因为 state 包含 &#39;foo&#39; 与 &#39;bar&#39;，TypeScript 会强制你这么做：</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">,</span> bar<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>bar <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你想使用 Freshness，你可能需要将所有成员标记为可选，这仍然会捕捉到拼写错误：</p><div class="language-ts"><pre><code><span class="token comment">// 假设</span>
<span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
  foo<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 你可能想做</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">&#39;Hello&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Yay works fine!</span>

<span class="token comment">// 由于 Freshness，你也可以防止错别字</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foos<span class="token operator">:</span> <span class="token string">&#39;Hello&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Error: 对象只能指定已知属性</span>

<span class="token comment">// 仍然会有类型检查</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Error: 无法将 number 类型赋值给 string 类型</span>
</code></pre></div><h3 id="类型保护"><a class="header-anchor" href="#类型保护" aria-hidden="true">#</a> 类型保护</h3><p>类型保护允许你使用更小范围下的对象类型。</p><h4 id="typeof"><a class="header-anchor" href="#typeof" aria-hidden="true">#</a> typeof</h4><p>TypeScript 熟知 JavaScript 中 <code>instanceof</code> 和 <code>typeof</code> 运算符的用法。如果你在一个条件块中使用这些，TypeScript 将会推导出在条件块中的的变量类型。如下例所示，TypeScript 将会辨别 <code>string</code> 上是否存在特定的函数，以及是否发生了拼写错误：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">doSome</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">subtr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: &#39;subtr&#39; 方法并没有存在于 `string` 上</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
  <span class="token punctuation">}</span>

  x<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 无法保证 `x` 是 `string` 类型</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="instanceof"><a class="header-anchor" href="#instanceof" aria-hidden="true">#</a> instanceof</h4><p>这有一个关于 <code>class</code> 和 <code>instanceof</code> 的例子：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
  common <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
  bar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
  common <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg <span class="token keyword">instanceof</span> <span class="token class-name">Bar</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>TypeScript 甚至能够理解 <code>else</code>。当你使用 <code>if</code> 来缩小类型时，TypeScript 知道在其他块中的类型并不是 <code>if</code> 中的类型：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
  bar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这个块中，一定是 &#39;Bar&#39;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="in"><a class="header-anchor" href="#in" aria-hidden="true">#</a> in</h4><p><code>in</code> 操作符可以安全的检查一个对象上是否存在一个属性，它通常也被作为类型保护使用：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span>
  y<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span>q<span class="token operator">:</span> <span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&#39;x&#39;</span> <span class="token keyword">in</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// q: A</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// q: B</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="字面量类型保护"><a class="header-anchor" href="#字面量类型保护" aria-hidden="true">#</a> 字面量类型保护</h4><p>当你在联合类型里使用字面量类型时，你可以检查它们是否有区别：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 字面量类型</span>
  foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Bar</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 字面量类型</span>
  bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 一定是 Bar</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="使用定义的类型保护"><a class="header-anchor" href="#使用定义的类型保护" aria-hidden="true">#</a> 使用定义的类型保护</h4><p>JavaScript 并没有内置非常丰富的、运行时的自我检查机制。当你在使用普通的 JavaScript 对象时（使用结构类型，更有益处），你甚至无法访问 <code>instanceof</code> 和 <code>typeof</code>。在这种情景下，你可以创建<em>用户自定义的类型保护函数</em>，这仅仅是一个返回值为类似于<code>someArgumentName is SomeType</code> 的函数，如下：</p><div class="language-ts"><pre><code><span class="token comment">// 仅仅是一个 interface</span>
<span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  common<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  common<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用户自己定义的类型保护！</span>
<span class="token keyword">function</span> <span class="token function">isFoo</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span><span class="token operator">:</span> arg <span class="token keyword">is</span> Foo <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>arg <span class="token keyword">as</span> Foo<span class="token punctuation">)</span><span class="token punctuation">.</span>foo <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用户自己定义的类型保护使用用例：</span>
<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFoo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> common<span class="token operator">:</span> <span class="token string">&#39;123&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> common<span class="token operator">:</span> <span class="token string">&#39;123&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="字面量类型"><a class="header-anchor" href="#字面量类型" aria-hidden="true">#</a> 字面量类型</h3><p>字面量是 JavaScript 本身提供的一个准确变量。</p><h4 id="字符串字面量"><a class="header-anchor" href="#字符串字面量" aria-hidden="true">#</a> 字符串字面量</h4><p>你可以使用一个字符串字面量作为一个类型：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>在这里，我们创建了一个被称为 <code>foo</code> 变量，它仅接收一个字面量值为 <code>Hello</code> 的变量：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">;</span>
foo <span class="token operator">=</span> <span class="token string">&#39;Bar&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error: &#39;bar&#39; 不能赋值给类型 &#39;Hello&#39;</span>
</code></pre></div><p>它们本身并不是很实用，但是可以在一个联合类型中组合创建一个强大的（实用的）抽象：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">CardinalDirection</span> <span class="token operator">=</span> <span class="token string">&#39;North&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;East&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;South&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;West&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">move</span><span class="token punctuation">(</span>distance<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> direction<span class="token operator">:</span> CardinalDirection<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token function">move</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;North&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token function">move</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;Nurth&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><h4 id="其他字面量类型"><a class="header-anchor" href="#其他字面量类型" aria-hidden="true">#</a> 其他字面量类型</h4><p>TypeScript 同样也提供 <code>boolean</code> 和 <code>number</code> 的字面量类型：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">OneToFive</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Bools</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="推断"><a class="header-anchor" href="#推断" aria-hidden="true">#</a> 推断</h4><p>通常，你会得到一个类似于 <code>Type string is not assignable to type &#39;foo&#39;</code> 的错误，如下：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">iTakeFoo</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">{</span>
  someProp<span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">iTakeFoo</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>someProp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: Argument of type string is not assignable to parameter of type &#39;foo&#39;</span>
</code></pre></div><p>这是由于 <code>test</code> 被推断为 <code>{ someProp: string }</code>，我们可以采用一个简单的类型断言来告诉 TypeScript 你想推断的字面量：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">iTakeFoo</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Test</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  someProp<span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> test<span class="token operator">:</span> Test <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 推断 `someProp` 永远是 &#39;foo&#39;</span>
  someProp<span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">iTakeFoo</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>someProp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div><h4 id="使用用例"><a class="header-anchor" href="#使用用例" aria-hidden="true">#</a> 使用用例</h4><p>TypeScript 枚举类型是基于数字的，你可以使用带字符串字面量的联合类型，来模拟一个基于字符串的枚举类型，就好像上文中提出的 <code>CardinalDirection</code>。你甚至可以使用下面的函数来生成 <code>key: value</code> 的结构：</p><div class="language-ts"><pre><code><span class="token comment">// 用于创建字符串列表映射至 `K: V` 的函数</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">strEnum</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">K</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> o<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后，你就可以使用 <code>keyof</code>、<code>typeof</code> 来生成字符串的联合类型。下面是一个完全的例子：</p><div class="language-ts"><pre><code><span class="token comment">// 用于创建字符串列表映射至 `K: V` 的函数</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">strEnum</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">K</span> <span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> o<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建 K: V</span>
<span class="token keyword">const</span> Direction <span class="token operator">=</span> <span class="token function">strEnum</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;North&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;South&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;East&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;West&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建一个类型</span>
<span class="token keyword">type</span> <span class="token class-name">Direction</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> Direction<span class="token punctuation">;</span>

<span class="token comment">// 简单的使用</span>
<span class="token keyword">let</span> sample<span class="token operator">:</span> Direction<span class="token punctuation">;</span>

sample <span class="token operator">=</span> Direction<span class="token punctuation">.</span>North<span class="token punctuation">;</span> <span class="token comment">// Okay</span>
sample <span class="token operator">=</span> <span class="token string">&#39;North&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Okay</span>
sample <span class="token operator">=</span> <span class="token string">&#39;AnythingElse&#39;</span><span class="token punctuation">;</span> <span class="token comment">// ERROR!</span>
</code></pre></div><h4 id="辨析联合类型"><a class="header-anchor" href="#辨析联合类型" aria-hidden="true">#</a> 辨析联合类型</h4><p>我们将会在此书的稍后章节讲解它。</p><h3 id="readonly"><a class="header-anchor" href="#readonly" aria-hidden="true">#</a> readonly</h3><p>TypeScript 类型系统允许你在一个接口里使用 <code>readonly</code> 来标记属性。它能让你以一种更安全的方式工作（不可预期的改变是很糟糕的）：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>config<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword">readonly</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token keyword">readonly</span> bas<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ..</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> bas<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 现在你能够确保 &#39;config&#39; 不能够被改变了</span>
</code></pre></div><p>当然，你也可以在 <code>interface</code> 和 <code>type</code> 里使用 <code>readonly</code>：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> bas<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化</span>
<span class="token keyword">const</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> bas<span class="token operator">:</span> <span class="token number">456</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 不能被改变</span>
foo<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// Error: foo.bar 为仅读属性</span>
</code></pre></div><p>你也能指定一个类的属性为只读，然后在声明时或者构造函数中初始化它们，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> bar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
  <span class="token keyword">readonly</span> baz<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="readonly-1"><a class="header-anchor" href="#readonly-1" aria-hidden="true">#</a> Readonly</h4><p>这有一个 <code>Readonly</code> 的映射类型，它接收一个泛型 <code>T</code>，用来把它的所有属性标记为只读类型：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  bas<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">FooReadonly</span> <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> bas<span class="token operator">:</span> <span class="token number">456</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fooReadonly<span class="token operator">:</span> FooReadonly <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> bas<span class="token operator">:</span> <span class="token number">456</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
fooReadonly<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// Error: bar 属性只读</span>
</code></pre></div><h4 id="其他的使用用例"><a class="header-anchor" href="#其他的使用用例" aria-hidden="true">#</a> 其他的使用用例</h4><h5 id="reactjs"><a class="header-anchor" href="#reactjs" aria-hidden="true">#</a> ReactJS</h5><p><code>ReactJS</code> 是一个喜欢用不变数据的库，你可以标记你的 <code>Props</code> 和 <code>State</code> 为不可变数据：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Something</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component<span class="token operator">&lt;</span>Props<span class="token punctuation">,</span> State<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 你可以放心，没有人会像下面这么做</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// Error: props 是不可变的</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// Error: 你应该使用 this.setState()</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然而，你并没有必要这么做，<code>React</code> 的声明文件已经标记这些为 <code>readonly</code>（通过传入泛型参数至一个内部包装，来把每个属性标记为 <code>readonly</code>，如上例子所示），</p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Something</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Component<span class="token operator">&lt;</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> baz<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// Error: props 是不可变的</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// Error: 你应该使用 this.setState()</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="绝对的不可变"><a class="header-anchor" href="#绝对的不可变" aria-hidden="true">#</a> 绝对的不可变</h5><p>你甚至可以把索引签名标记为只读：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> <span class="token punctuation">[</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用</span>

<span class="token keyword">const</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token number">345</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok（读取）</span>
foo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// Error: 属性只读</span>
</code></pre></div><p>如果你想以不变的方式使用原生 JavaScript 数组，可以使用 TypeScript 提供的 <code>ReadonlyArray&lt;T&gt;</code> 接口：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo<span class="token operator">:</span> ReadonlyArray<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
foo<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: ReadonlyArray 上不存在 `push`，因为他会改变数组</span>
foo <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, 创建了一个复制</span>
</code></pre></div><h5 id="自动推断"><a class="header-anchor" href="#自动推断" aria-hidden="true">#</a> 自动推断</h5><p>在一些情况下，编译器能把一些特定的属性推断为 <code>readonly</code>，例如在一个 <code>class</code> 中，如果你有一个只含有 <code>getter</code> 但是没有 <code>setter</code> 的属性，他能被推断为只读：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  firstName<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">;</span>
  lastName<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;Doe&#39;</span><span class="token punctuation">;</span>

  <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John Doe</span>
person<span class="token punctuation">.</span>fullName <span class="token operator">=</span> <span class="token string">&#39;Dear Reader&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error, fullName 只读</span>
</code></pre></div><h4 id="与-const-的不同"><a class="header-anchor" href="#与-const-的不同" aria-hidden="true">#</a> 与 <code>const</code> 的不同</h4><p><code>const</code></p><ul><li>用于变量；</li><li>变量不能重新赋值给其他任何事物。</li></ul><p><code>readonly</code></p><ul><li>用于属性；</li><li>用于别名，可以修改属性；</li></ul><p>简单的例子 1：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// 变量</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 属性</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>简单的例子 2：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token number">123</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">iMutateFoo</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  foo<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">iMutateFoo</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 456</span>
</code></pre></div><p><code>readonly</code> 能确保“我”不能修改属性，但是当你把这个属性交给其他并没有这种保证的使用者（允许出于类型兼容性的原因），他们能改变它。当然，如果 <code>iMutateFoo</code> 明确的表示，他们的参数不可修改，那么编译器会发出错误警告：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">readonly</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token number">123</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">iTakeFoo</span><span class="token punctuation">(</span>foo<span class="token operator">:</span> Foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  foo<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// Error: bar 属性只读</span>
<span class="token punctuation">}</span>

<span class="token function">iTakeFoo</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="范型-1"><a class="header-anchor" href="#范型-1" aria-hidden="true">#</a> 范型</h3><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：</p><ul><li>类的实例成员</li><li>类的方法</li><li>函数参数</li><li>函数返回值</li></ul><h4 id="动机和示例"><a class="header-anchor" href="#动机和示例" aria-hidden="true">#</a> 动机和示例</h4><p>下面是对一个先进先出的数据结构——队列，在 <code>TypeScript</code> 和 <code>JavaScript</code> 中的简单实现。</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Queue</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function-variable function">push</span> <span class="token operator">=</span> item <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function-variable function">pop</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上述代码中存在一个问题，它允许你向队列中添加任何类型的数据，当然，当数据被弹出队列时，也可以是任意类型。在下面的示例中，看起来人们可以向队列中添加 <code>string</code> 类型的数据，但是实际上，该用法假定的是只有 <code>number</code> 类型会被添加到队列里。</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Queue</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function-variable function">push</span> <span class="token operator">=</span> item <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function-variable function">pop</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Oops，一个错误</span>

<span class="token comment">// 一个使用者，走入了误区</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RUNTIME ERROR</span>
</code></pre></div><p>一个解决的办法（事实上，这也是不支持泛型类型的唯一解决办法）是为这些约束创建特殊类，如快速创建数字类型的队列：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">QueueNumber</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function-variable function">push</span> <span class="token operator">=</span> <span class="token punctuation">(</span>item<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  pop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueueNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 不能推入一个 `string` 类型，只能是 `number` 类型</span>

<span class="token comment">// 如果该错误得到修复，其他将不会出现问题</span>
</code></pre></div><p>当然，快速也意味着痛苦。例如当你想创建一个字符串的队列时，你将不得不再次修改相当大的代码。我们真正想要的一种方式是无论什么类型被推入队列，被推出的类型都与推入类型一样。当你使用泛型时，这会很容易：</p><div class="language-ts"><pre><code><span class="token comment">// 创建一个泛型类</span>
<span class="token keyword">class</span> <span class="token class-name">Queue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> data<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function-variable function">push</span> <span class="token operator">=</span> <span class="token punctuation">(</span>item<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  pop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 简单的使用</span>
<span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error：不能推入一个 `string`，只有 number 类型被允许</span>
</code></pre></div><p>另外一个我们见过的例子：一个 <code>reverse</code> 函数，现在在这个函数里提供了函数参数与函数返回值的约束：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">reverse</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>items<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> toreturn <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    toreturn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> toreturn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> sample <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reversed <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>sample<span class="token punctuation">)</span><span class="token punctuation">;</span>

reversed<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
reversed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>

reversed<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
reversed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div><p>在此章节中，你已经了解在类和函数上使用泛型的例子。一个值得补充一点的是，你可以为创建的成员函数添加泛型：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Utility</span> <span class="token punctuation">{</span>
  <span class="token generic-function"><span class="token function">reverse</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>items<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> toreturn <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      toreturn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> toreturn<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>你可以随意调用泛型参数，当你使用简单的泛型时，泛型常用 <code>T</code>、<code>U</code>、<code>V</code> 表示。如果在你的参数里，不止拥有一个泛型，你应该使用一个更语义化名称，如 <code>TKey</code> 和 <code>TValue</code> （通常情况下，以 <code>T</code> 作为泛型的前缀，在其他语言如 C++ 里，也被称为模板）</p></div><h4 id="误用的泛型"><a class="header-anchor" href="#误用的泛型" aria-hidden="true">#</a> 误用的泛型</h4><p>我见过开发者使用泛型仅仅是为了它的 hack。当你使用它时，你应该问问自己：你想用它来提供什么样的约束。如果你不能很好的回答它，你可能会误用泛型，如：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
</code></pre></div><p>在这里，泛型完全没有必要使用，因为它仅用于单个参数的位置，使用如下方式可能更好：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="设计模式：方便通用"><a class="header-anchor" href="#设计模式：方便通用" aria-hidden="true">#</a> 设计模式：方便通用</h4><p>考虑如下函数：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">parse</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</code></pre></div><p>在这种情况下，泛型 <code>T</code> 只在一个地方被使用了，它并没有在成员之间提供约束 <code>T</code>。这相当于一个如下的类型断言：</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">parse</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> something <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">&#39;something&#39;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> TypeOfSomething<span class="token punctuation">;</span>
</code></pre></div><p>仅使用一次的泛型并不比一个类型断言来的安全。它们都给你使用 API 提供了便利。</p><p>另一个明显的例子是，一个用于加载 json 返回值函数，它返回你任何传入类型的 <code>Promise</code>：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> getJSON <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>config<span class="token operator">:</span> <span class="token punctuation">{</span> url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> headers<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> fetchConfig <span class="token operator">=</span> <span class="token punctuation">{</span>
    method<span class="token operator">:</span> <span class="token string">&#39;GET&#39;</span><span class="token punctuation">,</span>
    Accept<span class="token operator">:</span> <span class="token string">&#39;application/json&#39;</span><span class="token punctuation">,</span>
    <span class="token string">&#39;Content-Type&#39;</span><span class="token operator">:</span> <span class="token string">&#39;application/json&#39;</span><span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>headers <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>url<span class="token punctuation">,</span> fetchConfig<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">then</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>response <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="配合-axios-使用"><a class="header-anchor" href="#配合-axios-使用" aria-hidden="true">#</a> 配合 axios 使用</h5><p>通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：</p><div class="language-ts"><pre><code><span class="token comment">// 请求接口数据</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ResponseData<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * 状态码
   * @type { number }
   */</span>
  code<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

  <span class="token comment">/**
   * 数据
   * @type { T }
   */</span>
  result<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

  <span class="token comment">/**
   * 消息
   * @type { string }
   */</span>
  message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当我们把 API 单独抽离成单个模块时：</p><div class="language-ts"><pre><code><span class="token comment">// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等</span>
<span class="token keyword">import</span> Ax <span class="token keyword">from</span> <span class="token string">&#39;./axios&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> ResponseData <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./interface.ts&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getUser</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Ax<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>ResponseData<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&#39;/somepath&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接着我们写入返回的数据类型 <code>User</code>，这可以让 TypeScript 顺利推断出我们想要的类型：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// user 被推断出为</span>
  <span class="token comment">// {</span>
  <span class="token comment">//  code: number,</span>
  <span class="token comment">//  result: { name: string, age: number },</span>
  <span class="token comment">//  message: string</span>
  <span class="token comment">// }</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token generic-function"><span class="token function">getUser</span><span class="token generic class-name"><span class="token operator">&lt;</span>User<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="类型推断"><a class="header-anchor" href="#类型推断" aria-hidden="true">#</a> 类型推断</h3><p>TypeScript 能根据一些简单的规则推断（检查）变量的类型，你可以通过实践，很快的了解它们。</p><h4 id="定义变量"><a class="header-anchor" href="#定义变量" aria-hidden="true">#</a> 定义变量</h4><p>变量的类型，由定义推断：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// foo 是 &#39;number&#39;</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// bar 是 &#39;string&#39;</span>

foo <span class="token operator">=</span> bar<span class="token punctuation">;</span> <span class="token comment">// Error: 不能将 &#39;string&#39; 赋值给 `number`</span>
</code></pre></div><p>这是一个从右向左流动类型的示例。</p><h4 id="函数返回类型"><a class="header-anchor" href="#函数返回类型" aria-hidden="true">#</a> 函数返回类型</h4><p>返回类型能被 <code>return</code> 语句推断，如下所示，推断函数返回为一个数字：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是一个从底部流出类型的例子。</p><h4 id="赋值"><a class="header-anchor" href="#赋值" aria-hidden="true">#</a> 赋值</h4><p>函数参数类型/返回值也能通过赋值来推断。如下所示，<code>foo</code> 的类型是 <code>Adder</code>，他能让 <code>foo</code> 的参数 <code>a</code>、<code>b</code> 是 <code>number</code> 类型。</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Adder</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token function-variable function">Adder</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
</code></pre></div><p>这个事实可以用下面的代码来证明，TypeScript 会发出正如你期望发出的错误警告：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Adder</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token function-variable function">Adder</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error：不能把 &#39;string&#39; 类型赋值给 &#39;number&#39; 类型</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这是一个从左向右流动类型的示例。</p><p>如果你创建一个函数，并且函数参数为一个回调函数，相同的赋值规则也适用于它。从 <code>argument</code> 至 <code>parameter</code> 只是变量赋值的另一种形式。</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Adder</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">iTakeAnAdder</span><span class="token punctuation">(</span>adder<span class="token operator">:</span> Adder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">adder</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">iTakeAnAdder</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error: 不能把 &#39;string&#39; 类型赋值给 &#39;number&#39; 类型</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="结构化"><a class="header-anchor" href="#结构化" aria-hidden="true">#</a> 结构化</h4><p>这些简单的规则也适用于结构化的存在（对象字面量），例如在下面这种情况下 foo 的类型被推断为 { a: number, b: number }：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span>
  b<span class="token operator">:</span> <span class="token number">456</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error：不能把 &#39;string&#39; 类型赋值给 &#39;number&#39; 类型</span>
</code></pre></div><p>数组也一样：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
bar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error：不能把 &#39;string&#39; 类型赋值给 &#39;number&#39; 类型</span>
</code></pre></div><h4 id="解构"><a class="header-anchor" href="#解构" aria-hidden="true">#</a> 解构</h4><p>这些也适用于解构中：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span>
  b<span class="token operator">:</span> <span class="token number">456</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> a <span class="token punctuation">}</span> <span class="token operator">=</span> foo<span class="token punctuation">;</span>

a <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error：不能把 &#39;string&#39; 类型赋值给 &#39;number&#39; 类型</span>
</code></pre></div><p>数组中：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> bar<span class="token punctuation">;</span>

a <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error：不能把 &#39;string&#39; 类型赋值给 &#39;number&#39; 类型</span>
</code></pre></div><p>如果函数参数能够被推断出来，那么解构亦是如此。在如下例子中，函数参数能够被解构为 <code>a/b</code> 成员：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Adder</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">number</span><span class="token operator">:</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">iTakeAnAdder</span><span class="token punctuation">(</span>adder<span class="token operator">:</span> Adder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">adder</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">iTakeAnAdder</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// a, b 的类型能被推断出来</span>
  a <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error：不能把 &#39;string&#39; 类型赋值给 &#39;number&#39; 类型</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="类型保护-1"><a class="header-anchor" href="#类型保护-1" aria-hidden="true">#</a> 类型保护</h4><p>在前面章节<a href="#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4">类型保护</a>中，我们已经知道它如何帮助我们改变和缩小类型范围（特别是在联合类型下）。类型保护只是一个块中变量另一种推断形式。</p><h4 id="警告"><a class="header-anchor" href="#警告" aria-hidden="true">#</a> 警告</h4><h5 id="小心使用函数"><a class="header-anchor" href="#小心使用函数" aria-hidden="true">#</a> 小心使用函数</h5><p>如果类型不能被赋值推断出来，类型也将不会流入函数参数中。例如如下的一个例子，编译器并不知道 <code>foo</code> 的类型，所它也就不能推断出 <code>a</code> 或者 <code>b</code> 的类型。</p><div class="language-ts"><pre><code><span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* do something */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>然而，如果 <code>foo</code> 添加了类型注解，函数参数也就能被推断（<code>a</code>，<code>b</code> 都能被推断为 <code>number</code> 类型）：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">TwoNumberFunction</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token function-variable function">TwoNumberFunction</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* do something */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="小心使用返回值"><a class="header-anchor" href="#小心使用返回值" aria-hidden="true">#</a> 小心使用返回值</h5><p>尽管 TypeScript 一般情况下能推断函数的返回值，但是它可能并不是你想要的。例如如下的 <code>foo</code> 函数，它的返回值为 <code>any</code>：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token function">addOne</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 一些使用 JavaScript 库的特殊函数</span>
<span class="token keyword">function</span> <span class="token function">addOne</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是因为返回值的类型被一个缺少类型定义的 <code>addOne</code> 函数所影响（<code>a</code> 是 <code>any</code>，所以 <code>addOne</code> 返回值为 <code>any</code>，<code>foo</code> 的返回值是也是 <code>any</code>）。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>我发现最简单的方式是明确的写上函数返回值，毕竟这些注解是一个定理，而函数是注解的一个证据。</p></div><p>这里还有一些其他可以想象的情景，但是有一个好消息是有编译器选项 <code>noImplicitAny</code> 可以捕获这些 bug。</p><h5 id="noimplicitany"><a class="header-anchor" href="#noimplicitany" aria-hidden="true">#</a> <code>noImplicitAny</code></h5><p>选项 <code>noImplicitAny</code> 用来告诉编译器，当无法推断一个变量时发出一个错误（或者只能推断为一个隐式的 <code>any</code> 类型），你可以：</p><ul><li>通过显式添加 <code>:any</code> 的类型注解，来让它成为一个 <code>any</code> 类型；</li><li>通过一些更正确的类型注解来帮助 TypeScript 推断类型。</li></ul><h3 id="类型兼容性"><a class="header-anchor" href="#类型兼容性" aria-hidden="true">#</a> 类型兼容性</h3><p>类型兼容性用于确定一个类型是否能赋值给其他类型。</p><p>如 <code>string</code> 类型与 <code>number</code> 类型不兼容：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

str <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">// Error: &#39;number&#39; 不能赋值给 &#39;string&#39;</span>
num <span class="token operator">=</span> str<span class="token punctuation">;</span> <span class="token comment">// Error: &#39;string&#39; 不能赋值给 &#39;number&#39;</span>
</code></pre></div><h4 id="安全性"><a class="header-anchor" href="#安全性" aria-hidden="true">#</a> 安全性</h4><p>TypeScript 类型系统设计比较方便，它允许你有一些不正确的行为。例如：任何类型都能被赋值给 <code>any</code>，这意味着告诉编译器你可以做任何你想做的事情：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
foo <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="结构化-1"><a class="header-anchor" href="#结构化-1" aria-hidden="true">#</a> 结构化</h4><p>TypeScript 对象是一种结构类型，这意味着只要结构匹配，名称也就无关紧要了：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token keyword">public</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p<span class="token operator">:</span> Point<span class="token punctuation">;</span>

<span class="token comment">// ok, 因为是结构化的类型</span>
p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point2D</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这允许你动态创建对象（就好像你在 <code>vanilla JS</code> 中使用一样），并且它如果能被推断，该对象仍然具有安全性。</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Point3D</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  z<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> point2D<span class="token operator">:</span> Point2D <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> point3D<span class="token operator">:</span> Point3D <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> z<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">iTakePoint2D</span><span class="token punctuation">(</span>point<span class="token operator">:</span> Point2D<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* do something */</span>
<span class="token punctuation">}</span>

<span class="token function">iTakePoint2D</span><span class="token punctuation">(</span>point2D<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, 完全匹配</span>
<span class="token function">iTakePoint2D</span><span class="token punctuation">(</span>point3D<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 额外的信息，没关系</span>
<span class="token function">iTakePoint2D</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: 没有 &#39;y&#39;</span>
</code></pre></div><h4 id="变体"><a class="header-anchor" href="#变体" aria-hidden="true">#</a> 变体</h4><p>对类型兼容性来说，变体是一个利于理解和重要的概念。</p><p>对一个简单类型 <code>Base</code> 和 Child 来说，如果 <code>Child</code> 是 <code>Base</code> 的子类，<code>Child</code> 的实例能被赋值给 <code>Base</code> 类型的变量。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这是多态性。</p></div><p>在由 <code>Base</code> 和 <code>Child</code> 组合的复杂类型的类型兼容性中，它取决于相同场景下的 <code>Base</code> 与 Child 的变体：</p><ul><li>协变（Covariant）：只在同一个方向；</li><li>逆变（Contravariant）：只在相反的方向；</li><li>双向协变（Bivariant）：包括同一个方向和不同方向；</li><li>不变（Invariant）：如果类型不完全相同，则它们是不兼容的。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>对于存在完全可变数据的健全的类型系统（如 JavaScript），<code>Invariant</code> 是一个唯一的有效可选属性，但是如我们所讨论的，<em>便利性</em>迫使我们作出一些不是很安全的选择。</p></div><p>关于协变和逆变的更多内容，请参考：<a href="#%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">协变与逆变</a></p><h4 id="函数-1"><a class="header-anchor" href="#函数-1" aria-hidden="true">#</a> 函数</h4><p>当你在比较两个函数时，这有一些你需要考虑到的事情。</p><h5 id="返回类型"><a class="header-anchor" href="#返回类型" aria-hidden="true">#</a> 返回类型</h5><p>协变（Covariant）：返回类型必须包含足够的数据。</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Point3D</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  z<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> iMakePoint2D <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Point2D <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> iMakePoint3D <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Point3D <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> z<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

iMakePoint2D <span class="token operator">=</span> iMakePoint3D<span class="token punctuation">;</span>
iMakePoint3D <span class="token operator">=</span> iMakePoint2D<span class="token punctuation">;</span> <span class="token comment">// ERROR: Point2D 不能赋值给 Point3D</span>
</code></pre></div><h5 id="参数数量"><a class="header-anchor" href="#参数数量" aria-hidden="true">#</a> 参数数量</h5><p>更少的参数数量是好的（如：函数能够选择性的忽略一些多余的参数），但是你得保证有足够的参数被使用了：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> <span class="token function-variable function">iTakeSomethingAndPassItAnErr</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function-variable function">x</span><span class="token operator">:</span> <span class="token punctuation">(</span>err<span class="token operator">:</span> Error<span class="token punctuation">,</span> data<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 做一些其他的 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">iTakeSomethingAndPassItAnErr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token function">iTakeSomethingAndPassItAnErr</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token function">iTakeSomethingAndPassItAnErr</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>

<span class="token comment">// Error: 参数类型 `(err: any, data: any, more: any) =&gt; null` 不能赋值给参数类型 `(err: Error, data: any) =&gt; void`</span>
<span class="token function">iTakeSomethingAndPassItAnErr</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">,</span> more<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="可选的和-rest-参数"><a class="header-anchor" href="#可选的和-rest-参数" aria-hidden="true">#</a> 可选的和 rest 参数</h5><p>可选的（预先确定的）和 Rest 参数（任何数量的参数）都是兼容的：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">bas</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

foo <span class="token operator">=</span> bar <span class="token operator">=</span> bas<span class="token punctuation">;</span>
bas <span class="token operator">=</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>可选的（上例子中的 <code>bar</code>）与不可选的（上例子中的 <code>foo</code>）仅在选项为 <code>strictNullChecks</code> 为 <code>false</code> 时兼容。</p></div><h5 id="函数参数类型"><a class="header-anchor" href="#函数参数类型" aria-hidden="true">#</a> 函数参数类型</h5><p>双向协变（Bivariant）：旨在支持常见的事件处理方案。</p><div class="language-ts"><pre><code><span class="token comment">// 事件等级</span>
<span class="token keyword">interface</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>
  timestamp<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">MouseEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">KeyEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>
  keyCode<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 简单的事件监听</span>
<span class="token keyword">enum</span> EventType <span class="token punctuation">{</span>
  Mouse<span class="token punctuation">,</span>
  Keyboard
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">addEventListener</span><span class="token punctuation">(</span>eventType<span class="token operator">:</span> EventType<span class="token punctuation">,</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 不安全，但是有用，常见。函数参数的比较是双向协变。</span>
<span class="token function">addEventListener</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> MouseEvent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">&#39;,&#39;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在安全情景下的一种不好方案</span>
<span class="token function">addEventListener</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MouseEvent<span class="token operator">&gt;</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">&#39;,&#39;</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>MouseEvent<span class="token operator">&gt;</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">addEventListener</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token operator">:</span> MouseEvent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">&#39;,&#39;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 仍然不允许明确的错误，对完全不兼容的类型会强制检查</span>
<span class="token function">addEventListener</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>同样的，你也可以把 <code>Array&lt;Child&gt;</code> 赋值给 <code>Array&lt;Base&gt;</code> （协变），因为函数是兼容的。数组的协变需要所有的函数 <code>Array&lt;Child&gt;</code> 都能赋值给 <code>Array&lt;Base&gt;</code>，例如 <code>push(t: Child)</code> 能被赋值给 <code>push(t: Base)</code>，这都可以通过函数参数双向协变实现。</p><p>下面的代码对于其他语言的开发者来说，可能会感到很困惑，因为他们认为是有错误的，可是 Typescript 并不会报错：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Point2D</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Point3D</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  z<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token function-variable function">iTakePoint2D</span> <span class="token operator">=</span> <span class="token punctuation">(</span>point<span class="token operator">:</span> Point2D<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">iTakePoint3D</span> <span class="token operator">=</span> <span class="token punctuation">(</span>point<span class="token operator">:</span> Point3D<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

iTakePoint3D <span class="token operator">=</span> iTakePoint2D<span class="token punctuation">;</span> <span class="token comment">// ok, 这是合理的</span>
iTakePoint2D <span class="token operator">=</span> iTakePoint3D<span class="token punctuation">;</span> <span class="token comment">// ok，为什么？</span>
</code></pre></div><h4 id="枚举-1"><a class="header-anchor" href="#枚举-1" aria-hidden="true">#</a> 枚举</h4><ul><li>枚举与数字类型相互兼容</li></ul><div class="language-ts"><pre><code><span class="token keyword">enum</span> Status <span class="token punctuation">{</span>
  Ready<span class="token punctuation">,</span>
  Waiting
<span class="token punctuation">}</span>

<span class="token keyword">let</span> status <span class="token operator">=</span> Status<span class="token punctuation">.</span>Ready<span class="token punctuation">;</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

status <span class="token operator">=</span> num<span class="token punctuation">;</span>
num <span class="token operator">=</span> status<span class="token punctuation">;</span>
</code></pre></div><ul><li>来自于不同枚举的枚举变量，被认为是不兼容的：</li></ul><div class="language-ts"><pre><code><span class="token keyword">enum</span> Status <span class="token punctuation">{</span>
  Ready<span class="token punctuation">,</span>
  Waiting
<span class="token punctuation">}</span>
<span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
  Red<span class="token punctuation">,</span>
  Blue<span class="token punctuation">,</span>
  Green
<span class="token punctuation">}</span>

<span class="token keyword">let</span> status <span class="token operator">=</span> Status<span class="token punctuation">.</span>Ready<span class="token punctuation">;</span>
<span class="token keyword">let</span> color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Red<span class="token punctuation">;</span>

status <span class="token operator">=</span> color<span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><h4 id="类"><a class="header-anchor" href="#类" aria-hidden="true">#</a> 类</h4><ul><li>仅仅只有实例成员和方法会相比较，构造函数和静态成员不会被检查。</li></ul><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  feet<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> numFeet<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>
  feet<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>meters<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a<span class="token operator">:</span> Animal<span class="token punctuation">;</span>
<span class="token keyword">let</span> s<span class="token operator">:</span> Size<span class="token punctuation">;</span>

a <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// OK</span>
s <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// OK</span>
</code></pre></div><ul><li>私有的和受保护的成员必须来自于相同的类。</li></ul><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">protected</span> feet<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">let</span> animal<span class="token operator">:</span> Animal<span class="token punctuation">;</span>
<span class="token keyword">let</span> cat<span class="token operator">:</span> Cat<span class="token punctuation">;</span>

animal <span class="token operator">=</span> cat<span class="token punctuation">;</span> <span class="token comment">// ok</span>
cat <span class="token operator">=</span> animal<span class="token punctuation">;</span> <span class="token comment">// ok</span>

<span class="token keyword">class</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>
  <span class="token keyword">protected</span> feet<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> size<span class="token operator">:</span> Size<span class="token punctuation">;</span>

animal <span class="token operator">=</span> size<span class="token punctuation">;</span> <span class="token comment">// ERROR</span>
size <span class="token operator">=</span> animal<span class="token punctuation">;</span> <span class="token comment">// ERROR</span>
</code></pre></div><h4 id="泛型"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h4><p>TypeScript 类型系统基于变量的结构，仅当类型参数在被一个成员使用时，才会影响兼容性。如下例子中，<code>T</code> 对兼容性没有影响：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Empty<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">let</span> x<span class="token operator">:</span> Empty<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span> Empty<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div><p>当 <code>T</code> 被成员使用时，它将在实例化泛型后影响兼容性：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Empty<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> x<span class="token operator">:</span> Empty<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span> Empty<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>如果尚未实例化泛型参数，则在检查兼容性之前将其替换为 <code>any</code>：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> <span class="token function-variable function">identity</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token function-variable function">reverse</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>y<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">U</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

identity <span class="token operator">=</span> reverse<span class="token punctuation">;</span> <span class="token comment">// ok, 因为 `(x: any) =&gt; any` 匹配 `(y: any) =&gt; any`</span>
</code></pre></div><p>类中的泛型兼容性与前文所提及一致：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">List<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token function">add</span><span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ..</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> animals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
animals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
animals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>

<span class="token keyword">const</span> cats <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List<span class="token operator">&lt;</span>Cat<span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cats<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
cats<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div><h4 id="脚注：不变性-invariance"><a class="header-anchor" href="#脚注：不变性-invariance" aria-hidden="true">#</a> 脚注：不变性 (Invariance)</h4><p>我们说过，不变性可能是唯一一个听起来合理的选项，这里有一个关于 <code>contra</code> 和 <code>co</code> 的变体，被认为对数组是不安全的。</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&#39;animal&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">&#39;cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 多态</span>
<span class="token comment">// Animal &lt;= Cat</span>

animal <span class="token operator">=</span> cat<span class="token punctuation">;</span> <span class="token comment">// ok</span>
cat <span class="token operator">=</span> animal<span class="token punctuation">;</span> <span class="token comment">// ERROR: cat 继承于 animal</span>

<span class="token comment">// 演示每个数组形式</span>
<span class="token keyword">let</span> animalArr<span class="token operator">:</span> Animal<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>animal<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> catArr<span class="token operator">:</span> Cat<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>cat<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 明显的坏处，逆变</span>
<span class="token comment">// Animal &lt;= Cat</span>
<span class="token comment">// Animal[] &gt;= Cat[]</span>
catArr <span class="token operator">=</span> animalArr<span class="token punctuation">;</span> <span class="token comment">// ok, 如有有逆变</span>
catArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许，但是会在运行时报错</span>

<span class="token comment">// 另外一个坏处，协变</span>
<span class="token comment">// Animal &lt;= Cat</span>
<span class="token comment">// Animal[] &lt;= Cat[]</span>
animalArr <span class="token operator">=</span> catArr<span class="token punctuation">;</span> <span class="token comment">// ok，协变</span>

animalArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&#39;another animal&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅仅是 push 一个 animal 至 carArr 里</span>
catArr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>c <span class="token operator">=&gt;</span> c<span class="token punctuation">.</span><span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许，但是会在运行时报错。</span>
</code></pre></div><h3 id="never"><a class="header-anchor" href="#never" aria-hidden="true">#</a> Never</h3><p>程序语言的设计确实应该存在一个底部类型的概念，当你在分析代码流的时候，这会是一个理所当然存在的类型。TypeScript 就是这样一种分析代码流的语言（😎），因此它需要一个可靠的，代表永远不会发生的类型。</p><p><code>never</code> 类型是 TypeScript 中的底层类型。它自然被分配的一些例子：</p><ul><li>一个从来不会有返回值的函数（如：如果函数内含有 <code>while(true) {}</code>）；</li><li>一个总是会抛出错误的函数（如：<code>function foo() { throw new Error(&#39;Not Implemented&#39;) }</code>，<code>foo</code> 的返回类型是 <code>never</code>）；</li></ul><p>你也可以将它用做类型注解：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div><p>但是，<code>never</code> 类型仅能被赋值给另外一个 <code>never</code>：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// Error: number 类型不能赋值给 never 类型</span>

<span class="token comment">// ok, 作为函数返回类型的 never</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;Throw my hands in the air like I just dont care&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>很棒，现在让我们看看它的关键用例。</p><h4 id="用例：详细的检查"><a class="header-anchor" href="#用例：详细的检查" aria-hidden="true">#</a> 用例：详细的检查</h4><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 如果不是一个 never 类型，这会报错：</span>
  <span class="token comment">// - 不是所有条件都有返回值 （严格模式下）</span>
  <span class="token comment">// - 或者检查到无法访问的代码</span>
  <span class="token comment">// 但是由于 TypeScript 理解 `fail` 函数返回为 `never` 类型</span>
  <span class="token comment">// 它可以让你调用它，因为你可能会在运行时用它来做安全或者详细的检查。</span>
  <span class="token keyword">return</span> <span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&#39;Unexhaustive&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fail</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>never</code> 仅能被赋值给另外一个 <code>never</code> 类型，因此你可以用它来进行编译时的全面的检查，我们将会在<a href="#%E8%BE%A8%E6%9E%90%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B">辨析联合类型</a>中讲解它。</p><h4 id="与-void-的差异"><a class="header-anchor" href="#与-void-的差异" aria-hidden="true">#</a> 与 <code>void</code> 的差异</h4><p>一旦有人告诉你，<code>never</code> 表示一个从来不会优雅的返回的函数时，你可能马上就会想到与此类似的 <code>void</code>，然而实际上，<code>void</code> 表示没有任何类型，<code>never</code> 表示永远不存在的值的类型。</p><p>当一个函数返回空值时，它的返回值为 <code>void</code> 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 <code>never</code> 类型。<code>void</code> 类型可以被赋值（在 <code>strictNullChecking</code> 为 <code>false</code> 时），但是除了 <code>never</code> 本身以外，其他任何类型不能赋值给 <code>never</code>。</p><h3 id="辨析联合类型-1"><a class="header-anchor" href="#辨析联合类型-1" aria-hidden="true">#</a> 辨析联合类型</h3><p>当类中含有<a href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B">字面量成员</a>时，我们可以用该类的属性来辨析联合类型。</p><p>作为一个例子，考虑 <code>Square</code> 和 <code>Rectangle</code> 的联合类型 <code>Shape</code>。<code>Square</code> 和 <code>Rectangle</code>有共同成员 <code>kind</code>，因此 <code>kind</code> 存在于 <code>Shape</code> 中。</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">&#39;square&#39;</span><span class="token punctuation">;</span>
  size<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">&#39;rectangle&#39;</span><span class="token punctuation">;</span>
  width<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Shape</span> <span class="token operator">=</span> Square <span class="token operator">|</span> Rectangle<span class="token punctuation">;</span>
</code></pre></div><p>如果你使用类型保护风格的检查（<code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>）或者使用具有判断性的属性（在这里是 <code>kind</code>），TypeScript 将会认为你会使用的对象类型一定是拥有特殊字面量的，并且它会为你自动把类型范围变小：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;square&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 现在 TypeScript 知道 s 的类型是 Square</span>
    <span class="token comment">// 所以你现在能安全使用它</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不是一个 square ？因此 TypeScript 将会推算出 s 一定是 Rectangle</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span>width <span class="token operator">*</span> s<span class="token punctuation">.</span>height<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="详细的检查"><a class="header-anchor" href="#详细的检查" aria-hidden="true">#</a> 详细的检查</h4><p>通常，联合类型的成员有一些自己的行为（代码）：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">&#39;square&#39;</span><span class="token punctuation">;</span>
  size<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">&#39;rectangle&#39;</span><span class="token punctuation">;</span>
  width<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 有人仅仅是添加了 `Circle` 类型</span>
<span class="token comment">// 我们可能希望 TypeScript 能在任何被需要的地方抛出错误</span>
<span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">&#39;circle&#39;</span><span class="token punctuation">;</span>
  radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Shape</span> <span class="token operator">=</span> Square <span class="token operator">|</span> Rectangle <span class="token operator">|</span> Circle<span class="token punctuation">;</span>
</code></pre></div><p>一个可能会让你的代码变差的例子：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;square&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;rectangle&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span>width <span class="token operator">*</span> s<span class="token punctuation">.</span>height<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 如果你能让 TypeScript 给你一个错误，这是不是很棒？</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可以通过一个简单的向下思想，来确保块中的类型被推断为与 <code>never</code> 类型兼容的类型。例如，你可以添加一个更详细的检查来捕获错误：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;square&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;rectangle&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span>width <span class="token operator">*</span> s<span class="token punctuation">.</span>height<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Error: &#39;Circle&#39; 不能被赋值给 &#39;never&#39;</span>
    <span class="token keyword">const</span> _exhaustiveCheck<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它将强制你添加一种新的条件：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;square&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;rectangle&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span>width <span class="token operator">*</span> s<span class="token punctuation">.</span>height<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;circle&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// ok</span>
    <span class="token keyword">const</span> _exhaustiveCheck<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="switch"><a class="header-anchor" href="#switch" aria-hidden="true">#</a> Switch</h4><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>你可以通过 <code>switch</code> 来实现以上例子。</p></div><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&#39;square&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&#39;rectangle&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> s<span class="token punctuation">.</span>width <span class="token operator">*</span> s<span class="token punctuation">.</span>height<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&#39;circle&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">const</span> _exhaustiveCheck<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="strictnullchecks"><a class="header-anchor" href="#strictnullchecks" aria-hidden="true">#</a> strictNullChecks</h4><p>如果你使用 <code>strictNullChecks</code> 选项来做详细的检查，你应该返回 <code>_exhaustiveCheck</code> 变量（类型是 <code>never</code>），否则 TypeScript 可能会推断返回值为 <code>undefined</code>：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span>s<span class="token operator">:</span> Shape<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&#39;square&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&#39;rectangle&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> s<span class="token punctuation">.</span>width <span class="token operator">*</span> s<span class="token punctuation">.</span>height<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&#39;circle&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">const</span> _exhaustiveCheck<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>
      <span class="token keyword">return</span> _exhaustiveCheck<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="redux"><a class="header-anchor" href="#redux" aria-hidden="true">#</a> Redux</h4><p>Redux 库正是使用的上述例子。</p><p>以下是添加了 TypeScript 类型注解的<a href="https://github.com/reduxjs/redux#the-gist" target="_blank" rel="noopener noreferrer">redux 要点</a>。</p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;redux&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Action</span> <span class="token operator">=</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span>
      type<span class="token operator">:</span> <span class="token string">&#39;INCREMENT&#39;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token operator">|</span> <span class="token punctuation">{</span>
      type<span class="token operator">:</span> <span class="token string">&#39;DECREMENT&#39;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * This is a reducer, a pure function with (state, action) =&gt; state signature.
 * It describes how an action transforms the state into the next state.
 *
 * The shape of the state is up to you: it can be a primitive, an array, an object,
 * or even an Immutable.js data structure. The only important part is that you should
 * not mutate the state object, but return a new object if the state changes.
 *
 * In this example, we use a `switch` statement and strings, but you can use a helper that
 * follows a different convention (such as function maps) if it makes sense for your
 * project.
 */</span>
<span class="token keyword">function</span> <span class="token function">counter</span><span class="token punctuation">(</span>state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> action<span class="token operator">:</span> Action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&#39;INCREMENT&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&#39;DECREMENT&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Create a Redux store holding the state of your app.</span>
<span class="token comment">// Its API is { subscribe, dispatch, getState }.</span>
<span class="token keyword">let</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// You can use subscribe() to update the UI in response to state changes.</span>
<span class="token comment">// Normally you&#39;d use a view binding library (e.g. React Redux) rather than subscribe() directly.</span>
<span class="token comment">// However it can also be handy to persist the current state in the localStorage.</span>

store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// The only way to mutate the internal state is to dispatch an action.</span>
<span class="token comment">// The actions can be serialized, logged or stored and later replayed.</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">&#39;INCREMENT&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">&#39;INCREMENT&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">&#39;DECREMENT&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1</span>
</code></pre></div><p>与 TypeScript 一起使用可以有效的防止拼写错误，并且能提高重构和书写文档化代码的能力。</p><h3 id="索引签名"><a class="header-anchor" href="#索引签名" aria-hidden="true">#</a> 索引签名</h3><p>可以用字符串访问 JavaScript 中的对象（TypeScript 中也一样），用来保存对其他对象的引用。</p><p>例如：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">[</span><span class="token string">&#39;Hello&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;World&#39;</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">[</span><span class="token string">&#39;Hello&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// World</span>
</code></pre></div><p>我们在键 <code>Hello</code> 下保存了一个字符串 <code>World</code>，除字符串外，它也可以保存任意的 JavaScript 对象，例如一个类的实例。</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">public</span> message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">[</span><span class="token string">&#39;Hello&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token string">&#39;World&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
foo<span class="token punctuation">[</span><span class="token string">&#39;Hello&#39;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// World</span>
</code></pre></div><p>当你传入一个其他对象至索引签名时，JavaScript 会在得到结果之前会先调用 <code>.toString</code> 方法：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;toString called&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">[</span>obj<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;World&#39;</span><span class="token punctuation">;</span> <span class="token comment">// toString called</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">[</span>obj<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// toString called, World</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">[</span><span class="token string">&#39;Hello&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Worldorld</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>只要索引位置使用了 <code>obj</code>，<code>toString</code> 方法都将会被调用。</p></div><p>数组有点稍微不同，对于一个 <code>number</code> 类型的索引签名，JavaScript 引擎将会尝试去优化（这取决于它是否是一个真的数组、存储的项目结构是否匹配等）。因此，<code>number</code> 应该被考虑作为一个有效的对象访问器（这与 <code>string</code> 不同），如下例子：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;World&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// World</span>
</code></pre></div><p>因此，这就是 JavaScript。现在让我们看看 TypeScript 对这些概念更优雅的处理。</p><h4 id="typescript-索引签名"><a class="header-anchor" href="#typescript-索引签名" aria-hidden="true">#</a> TypeScript 索引签名</h4><p>JavaScript 在一个对象类型的索引签名上会隐式调用 · 方法，而在 TypeScript 中，为防止初学者砸伤自己的脚（我总是看到 stackoverflow 上有很多 JavaScript 使用者都会这样。），它将会抛出一个错误。</p><div class="language-ts"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&#39;Hello&#39;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// ERROR: 索引签名必须为 string, number....</span>
foo<span class="token punctuation">[</span>obj<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;World&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// FIX: TypeScript 强制你必须明确这么做：</span>
foo<span class="token punctuation">[</span>obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;World&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>强制用户必须明确的写出 <code>toString()</code> 的原因是：在对象上默认执行的 <code>toString</code> 方法是有害的。例如 v8 引擎上总是会返回 <code>[object Object]</code></p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;World&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// World</span>
</code></pre></div><p>当然，数字类型是被允许的，这是因为：</p><ul><li>需要对数组 / 元组完美的支持；</li><li>即使你在上例中使用 <code>number</code> 类型的值来替代 <code>obj</code>，<code>number</code> 类型默认的 <code>toString</code> 方法实现的很友好（不是 <code>[object Object]</code>）。</li></ul><p>如下所示：</p><div class="language-ts"><pre><code><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>因此，我们有以下结论：</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>TypeScript 的索引签名必须是 <code>string</code> 或者 <code>number</code>。</p><p><code>symbols</code> 也是有效的，TypeScript 支持它。在接下来我们将会讲解它。</p></div><h4 id="声明一个索引签名"><a class="header-anchor" href="#声明一个索引签名" aria-hidden="true">#</a> 声明一个索引签名</h4><p>在上文中，我们通过使用 <code>any</code> 来让 TypeScript 允许我们可以做任意我们想做的事情。实际上，我们可以明确的指定索引签名。例如：假设你想确认存储在对象中任何内容都符合 <code>{ message: string }</code> 的结构，你可以通过 <code>[index: string]: { message: string }</code> 来实现。</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span> message<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 储存的东西必须符合结构</span>
<span class="token comment">// ok</span>
foo<span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> message<span class="token operator">:</span> <span class="token string">&#39;some message&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Error, 必须包含 `message`</span>
foo<span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> messages<span class="token operator">:</span> <span class="token string">&#39;some message&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 读取时，也会有类型检查</span>
<span class="token comment">// ok</span>
foo<span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">]</span><span class="token punctuation">.</span>message<span class="token punctuation">;</span>

<span class="token comment">// Error: messages 不存在</span>
foo<span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">]</span><span class="token punctuation">.</span>messages<span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>索引签名的名称（如：<code>{ [index: string]: { message: string } }</code> 里的 <code>index</code> ）除了可读性外，并没有任何意义。例如：如果有一个用户名，你可以使用 <code>{ username: string}: { message: string }</code>，这有利于下一个开发者理解你的代码。</p></div><p><code>number</code> 类型的索引也支持：<code>{ [count: number]: &#39;SomeOtherTypeYouWantToStoreEgRebate&#39; }</code>。</p><h4 id="所有成员都必须符合字符串的索引签名"><a class="header-anchor" href="#所有成员都必须符合字符串的索引签名" aria-hidden="true">#</a> 所有成员都必须符合字符串的索引签名</h4><p>当你声明一个索引签名时，所有明确的成员都必须符合索引签名：</p><div class="language-ts"><pre><code><span class="token comment">// ok</span>
<span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Error</span>
<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// Error: y 属性必须为 number 类型</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这可以给你提供安全性，任何以字符串的访问都能得到相同结果。</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  y<span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 直接</span>
foo<span class="token punctuation">[</span><span class="token string">&#39;x&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number</span>

<span class="token comment">// 间接</span>
<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token string">&#39;x&#39;</span><span class="token punctuation">;</span>
foo<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre></div><h4 id="使用一组有限的字符串字面量"><a class="header-anchor" href="#使用一组有限的字符串字面量" aria-hidden="true">#</a> 使用一组有限的字符串字面量</h4><p>一个索引签名可以通过映射类型来使索引字符串为联合类型中的一员，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Index</span> <span class="token operator">=</span> <span class="token string">&#39;a&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;b&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">FromIndex</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>k <span class="token keyword">in</span> Index<span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> good<span class="token operator">:</span> FromIndex <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Error:</span>
<span class="token comment">// `{ b: 1, c: 2, d: 3 }` 不能分配给 &#39;FromIndex&#39;</span>
<span class="token comment">// 对象字面量只能指定已知类型，&#39;d&#39; 不存在 &#39;FromIndex&#39; 类型上</span>
<span class="token keyword">const</span> bad<span class="token operator">:</span> FromIndex <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> d<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这通常与 <code>keyof/typeof</code> 一起使用，来获取变量的类型，在下一章节中，我们将解释它。</p><p>变量的规则一般可以延迟被推断：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">FromSomeIndex<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token builtin">string</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="同时拥有-string-和-number-类型的索引签名"><a class="header-anchor" href="#同时拥有-string-和-number-类型的索引签名" aria-hidden="true">#</a> 同时拥有 <code>string</code> 和 <code>number</code> 类型的索引签名</h4><p>这并不是一个常见的用例，但是 TypeScript 支持它。</p><p><code>string</code> 类型的索引签名比 <code>number</code> 类型的索引签名更严格。这是故意设计，它允许你有如下类型：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">ArrStr</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 必须包括所用成员类型</span>
  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 字符串索引类型的子级</span>

  <span class="token comment">// example</span>
  length<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="设计模式：索引签名的嵌套"><a class="header-anchor" href="#设计模式：索引签名的嵌套" aria-hidden="true">#</a> 设计模式：索引签名的嵌套</h4><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>添加索引签名时，需要考虑的 API。</p></div><p>在 JavaScript 社区你将会见到很多滥用索引签名的 API。如 JavaScript 库中使用 CSS 的常见模式：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">NestedCSS</span> <span class="token punctuation">{</span>
  color<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// strictNullChecks=false 时索引签名可为 undefined</span>
  <span class="token punctuation">[</span>selector<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> NestedCSS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> example<span class="token operator">:</span> NestedCSS <span class="token operator">=</span> <span class="token punctuation">{</span>
  color<span class="token operator">:</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">,</span>
  <span class="token string">&#39;.subclass&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    color<span class="token operator">:</span> <span class="token string">&#39;blue&#39;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>尽量不要使用这种把字符串索引签名与有效变量混合使用。如果属性名称中有拼写错误，这个错误不会被捕获到：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> failsSilently<span class="token operator">:</span> NestedCSS <span class="token operator">=</span> <span class="token punctuation">{</span>
  colour<span class="token operator">:</span> <span class="token string">&#39;red&#39;</span> <span class="token comment">// &#39;colour&#39; 不会被捕捉到错误</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>取而代之，我们把索引签名分离到自己的属性里，如命名为 <code>nest</code>（或者 <code>children</code>、<code>subnodes</code> 等）：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">NestedCSS</span> <span class="token punctuation">{</span>
  color<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  nest<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>selector<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> NestedCSS<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> example<span class="token operator">:</span> NestedCSS <span class="token operator">=</span> <span class="token punctuation">{</span>
  color<span class="token operator">:</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">,</span>
  nest<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&#39;.subclass&#39;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      color<span class="token operator">:</span> <span class="token string">&#39;blue&#39;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> failsSliently<span class="token operator">:</span> NestedCSS <span class="token operator">=</span> <span class="token punctuation">{</span>
  colour<span class="token operator">:</span> <span class="token string">&#39;red&#39;</span>  <span class="token comment">// TS Error: 未知属性 &#39;colour&#39;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="索引签名中排除某些属性"><a class="header-anchor" href="#索引签名中排除某些属性" aria-hidden="true">#</a> 索引签名中排除某些属性</h4><p>有时，你需要把属性合并至索引签名（虽然我们并不建议这么做，你应该使用上文中提到的嵌套索引签名的形式），如下例子：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">FieldState</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">FromState</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  isValid<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span> <span class="token comment">// Error: 不符合索引签名</span>
  <span class="token punctuation">[</span>filedName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> FieldState<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>TypeScript 会报错，因为添加的索引签名，并不兼容它原有的类型，使用交叉类型可以解决上述问题：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">FieldState</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">FormState</span> <span class="token operator">=</span> <span class="token punctuation">{</span> isValid<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>fieldName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> FieldState <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>请注意尽管你可以声明它至一个已存在的 TypeScript 类型上，但是你不能创建如下的对象：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">FieldState</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">FormState</span> <span class="token operator">=</span> <span class="token punctuation">{</span> isValid<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>fieldName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> FieldState <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 将它用于从某些地方获取的 JavaScript 对象</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> foo<span class="token operator">:</span> FormState<span class="token punctuation">;</span>

<span class="token keyword">const</span> isValidBool <span class="token operator">=</span> foo<span class="token punctuation">.</span>isValid<span class="token punctuation">;</span>
<span class="token keyword">const</span> somethingFieldState <span class="token operator">=</span> foo<span class="token punctuation">[</span><span class="token string">&#39;something&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 使用它来创建一个对象时，将不会工作</span>
<span class="token keyword">const</span> bar<span class="token operator">:</span> FormState <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// &#39;isValid&#39; 不能赋值给 &#39;FieldState&#39;</span>
  isValid<span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="流动的类型"><a class="header-anchor" href="#流动的类型" aria-hidden="true">#</a> 流动的类型</h3><p>TypeScript 类型系统非常强大，它支持其他任何单一语言无法实现的类型流动和类型片段。</p><p>这是因为 TypeScript 的设计目的之一是让你无缝与像 JavaScript 这类高动态的语言一起工作。在这里，我们介绍一些在 TypeScript 中使用移动类型的技巧。</p><p>关键的动机：当你改变了其中一个时，其他相关的会自动更新，并且当有事情变糟糕时，你会得到一个友好的提示，就好像一个被精心设计过的约束系统。</p><h4 id="复制类型和值"><a class="header-anchor" href="#复制类型和值" aria-hidden="true">#</a> 复制类型和值</h4><p>如果你想移动一个类，你可能会想要做以下事情：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">const</span> Bar <span class="token operator">=</span> Foo<span class="token punctuation">;</span>

<span class="token keyword">let</span> bar<span class="token operator">:</span> Bar<span class="token punctuation">;</span> <span class="token comment">// Error: 不能找到名称 &#39;Bar&#39;</span>
</code></pre></div><p>这会得到一个错误，因为 <code>const</code> 仅仅是复制了 <code>Foo</code> 到一个变量声明空间，因此你无法把 <code>Bar</code> 当作一个类型声明使用。正确的方式是使用 <code>import</code> 关键字，请注意，如果你在使用 <code>namespace</code> 或者 <code>modules</code>，使用 <code>import</code> 是你唯一能用的方式：</p><div class="language-ts"><pre><code><span class="token keyword">namespace</span> importing <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">import</span> Bar <span class="token operator">=</span> importing<span class="token punctuation">.</span>Foo<span class="token punctuation">;</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> Bar<span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div><p>这个 <code>import</code> 技巧，仅适合于类型和变量。</p><h4 id="捕获变量的类型"><a class="header-anchor" href="#捕获变量的类型" aria-hidden="true">#</a> 捕获变量的类型</h4><p>你可以通过 <code>typeof</code> 操作符在类型注解中使用变量。这允许你告诉编译器，一个变量的类型与其他类型相同，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> <span class="token keyword">typeof</span> foo<span class="token punctuation">;</span> <span class="token comment">// &#39;bar&#39; 类型与 &#39;foo&#39; 类型相同（在这里是： &#39;number&#39;）</span>

bar <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
bar <span class="token operator">=</span> <span class="token string">&#39;789&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error: &#39;string&#39; 不能分配给 &#39;number&#39; 类型</span>
</code></pre></div><h4 id="捕获类成员的类型"><a class="header-anchor" href="#捕获类成员的类型" aria-hidden="true">#</a> 捕获类成员的类型</h4><p>与捕获变量的类型相似，你仅仅是需要声明一个变量用来捕获到的类型：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 我们想要捕获的类型</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">let</span> _foo<span class="token operator">:</span> Foo<span class="token punctuation">;</span>

<span class="token comment">// 与之前做法相同</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> <span class="token keyword">typeof</span> _foo<span class="token punctuation">.</span>foo<span class="token punctuation">;</span>
</code></pre></div><h4 id="捕获字符串类型"><a class="header-anchor" href="#捕获字符串类型" aria-hidden="true">#</a> 捕获字符串类型</h4><p>许多 JavaScript 库和框架都使用原始的 JavaScript 字符串，你可以使用 <code>const</code> 定义一个变量捕获它的类型：</p><div class="language-ts"><pre><code><span class="token comment">// 捕获字符串的类型与值</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">&#39;Hello World&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 使用一个捕获的类型</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> <span class="token keyword">typeof</span> foo<span class="token punctuation">;</span>

<span class="token comment">// bar 仅能被赋值 &#39;Hello World&#39;</span>
bar <span class="token operator">=</span> <span class="token string">&#39;Hello World&#39;</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
bar <span class="token operator">=</span> <span class="token string">&#39;anything else&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>在这个例子里，<code>bar</code> 有字面量类型 <code>Hello World</code>，我们在<a href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B">字面量类型</a>章节已经深入讨论。</p><h4 id="捕获键的名称"><a class="header-anchor" href="#捕获键的名称" aria-hidden="true">#</a> 捕获键的名称</h4><p>keyof 操作符能让你捕获一个类型的键。例如，你可以使用它来捕获变量的键名称，在通过使用 typeof 来获取类型之后：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> colors <span class="token operator">=</span> <span class="token punctuation">{</span>
  red<span class="token operator">:</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">,</span>
  blue<span class="token operator">:</span> <span class="token string">&#39;blue&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Colors</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> colors<span class="token punctuation">;</span>

<span class="token keyword">let</span> color<span class="token operator">:</span> Colors<span class="token punctuation">;</span> <span class="token comment">// color 的类型是 &#39;red&#39; | &#39;blue&#39;</span>
color <span class="token operator">=</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
color <span class="token operator">=</span> <span class="token string">&#39;blue&#39;</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
color <span class="token operator">=</span> <span class="token string">&#39;anythingElse&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>这允许你很容易地拥有像字符串枚举+常量这样的类型，如上例所示。</p><h3 id="异常处理"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h3><p>JavaScript 有一个 <code>Error</code> 类，用于处理异常。你可以通过 <code>throw</code> 关键字来抛出一个错误。然后通过 <code>try/catch</code> 块来捕获此错误：</p><div class="language-ts"><pre><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;Something bad happened&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="错误的子类型"><a class="header-anchor" href="#错误的子类型" aria-hidden="true">#</a> 错误的子类型</h4><p>除内置的 <code>Error</code> 类外，还有一些额外的内置错误，它们继承自 <code>Error</code> 类：</p><h5 id="rangeerror"><a class="header-anchor" href="#rangeerror" aria-hidden="true">#</a> RangeError</h5><p>当数字类型变量或者参数超出其有效范围时，出现 <code>RangeError</code> 的错误提示：</p><div class="language-ts"><pre><code><span class="token comment">// 使用过多参数调用 console</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token builtin">console</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span><span class="token number">1000000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RangeError: 数组长度无效</span>
</code></pre></div><h5 id="referenceerror"><a class="header-anchor" href="#referenceerror" aria-hidden="true">#</a> ReferenceError</h5><p>当引用无效时，会出现 <code>ReferenceError</code> 的错误提示：</p><div class="language-ts"><pre><code><span class="token string">&#39;use strict&#39;</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>notValidVar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError: notValidVar 未定义</span>
</code></pre></div><h5 id="syntaxerror"><a class="header-anchor" href="#syntaxerror" aria-hidden="true">#</a> SyntaxError</h5><p>当解析无效 JavaScript 代码时，会出现 <code>SyntaxError</code> 的错误提示：</p><div class="language-ts"><pre><code><span class="token number">1</span> <span class="token operator">**</span><span class="token operator">*</span> <span class="token number">3</span>   <span class="token comment">// SyntaxError: 无效的标记 *</span>
</code></pre></div><h5 id="typeerror"><a class="header-anchor" href="#typeerror" aria-hidden="true">#</a> TypeError</h5><p>变量或者参数不是有效类型时，会出现 <code>TypeError</code> 的错误提示：</p><div class="language-ts"><pre><code><span class="token string">&#39;1.2&#39;</span><span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: &#39;1.2&#39;.toPrecision 不是函数。</span>

</code></pre></div><h5 id="urierror"><a class="header-anchor" href="#urierror" aria-hidden="true">#</a> URIError</h5><p>当传入无效参数至 <code>encodeURI()</code> 和 <code>decodeURI()</code> 时，会出现 <code>URIError</code> 的错误提示：</p><div class="language-ts"><pre><code><span class="token function">decodeURI</span><span class="token punctuation">(</span><span class="token string">&#39;%&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// URIError: URL 异常</span>
</code></pre></div><h4 id="使用-error"><a class="header-anchor" href="#使用-error" aria-hidden="true">#</a> 使用 <code>Error</code></h4><p>JavaScript 初学者可能有时候仅仅是抛出一个原始字符串：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;World&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// World</span>
</code></pre></div><p>**不要这么做，**使用 <code>Error</code> 对象的基本好处是，它能自动跟踪堆栈的属性构建以及生成位置。</p><p>原始字符串会导致极差的调试体验，并且在分析日志时，将会变得错综复杂。</p><h4 id="你并不需要-throw-抛出一个错误"><a class="header-anchor" href="#你并不需要-throw-抛出一个错误" aria-hidden="true">#</a> 你并不需要 <code>throw</code> 抛出一个错误</h4><p>传递一个 <code>Error</code> 对象是没问题的，这种方式在 <code>Node.js</code> 回调函数中非常常见，它用第一个参数作为错误对象进行回调处理</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">myFunction</span> <span class="token punctuation">(</span>callback<span class="token operator">:</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Error<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">doSomethingAsync</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>somethingWrong<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;This is my error&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="优秀的用例"><a class="header-anchor" href="#优秀的用例" aria-hidden="true">#</a> 优秀的用例</h4><p>「Exceptions should be exceptional」是计算机科学中常用用语。这里有一些原因说明在 JavaScript(TypeScript) 中也是如此。</p><h5 id="不清楚从哪里抛出错误"><a class="header-anchor" href="#不清楚从哪里抛出错误" aria-hidden="true">#</a> 不清楚从哪里抛出错误</h5><p>考虑如下代码块：</p><div class="language-ts"><pre><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">runTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">runTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Error:&#39;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>下一个开发者可能并不清楚哪个函数可能会抛出错误。在没有阅读 <code>task1/task2</code> 代码以及他们可能会调用的函数时，对代码 <code>review</code> 的人员可能也不会知道错误会从哪里抛出。</p><h5 id="优雅的错误捕获"><a class="header-anchor" href="#优雅的错误捕获" aria-hidden="true">#</a> 优雅的错误捕获</h5><p>你可以通过为每个可能抛出错误的代码显式捕获，来使其优雅：</p><div class="language-ts"><pre><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">runTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Error:&#39;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">runTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Error:&#39;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是现在，如果你想从第一个任务中传递变量到第二个任务中，代码会变的混乱（注意：foo 变量需要用 let 显式注解它，因为它不能从 <code>runTask1</code> 中返回出来）：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;World&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// World</span>
</code></pre></div><h5 id="没有在类型系统中很好的表示"><a class="header-anchor" href="#没有在类型系统中很好的表示" aria-hidden="true">#</a> 没有在类型系统中很好的表示</h5><p>考虑如下函数：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">validate</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> value <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;Invalid value&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这种情境下使用 <code>Error</code> 不是一个好的主意。因为没有用来验证函数的类型定义（如：<code>(value: number) =&gt; void</code>），取而代之一个更好的方式是创建一个验证方法：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">validate</span><span class="token punctuation">(</span>
  value<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  error<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> value <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> error<span class="token operator">:</span> <span class="token string">&#39;Invalid value&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在它具有类型定义了。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>除非你想用以非常通用（try/catch）的方式处理错误，否则不要抛出错误。</p></div><h3 id="混合"><a class="header-anchor" href="#混合" aria-hidden="true">#</a> 混合</h3><p>TypeScript (和 JavaScript) 类只能严格的单继承，因此你不能做：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">Tagged</span><span class="token punctuation">,</span> Timestamped <span class="token punctuation">{</span> <span class="token comment">// ERROR : 不能多重继承</span>
  <span class="token comment">// ..</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从可重用组件构建类的另一种方式是通过基类来构建它们，这种方式称为混合。</p><p>这个主意是简单的，采用函数 B 接受一个类 A，并且返回一个带有新功能的类的方式来替代 A 类扩展 B 来获取 B 上的功能，前者中的 B 即是混合。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>「混合」是一个函数：</p><ul><li>传入一个构造函数；</li><li>创建一个带有新功能，并且扩展构造函数的新类；</li><li>返回这个新类。</li></ul></div><p>一个完整的例子：</p><div class="language-ts"><pre><code><span class="token comment">// 所有 mixins 都需要</span>
<span class="token keyword">type</span> <span class="token class-name">Constructor<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token comment">/////////////</span>
<span class="token comment">// mixins 例子</span>
<span class="token comment">////////////</span>

<span class="token comment">// 添加属性的混合例子</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">TimesTamped</span><span class="token generic class-name"><span class="token operator">&lt;</span>TBase <span class="token keyword">extends</span> Constructor<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Base<span class="token operator">:</span> TBase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">extends</span></span> Base <span class="token punctuation">{</span>
    timestamp <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 添加属性和方法的混合例子</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">Activatable</span><span class="token generic class-name"><span class="token operator">&lt;</span>TBase <span class="token keyword">extends</span> Constructor<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Base<span class="token operator">:</span> TBase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">extends</span></span> Base <span class="token punctuation">{</span>
    isActivated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token function">activate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>isActivated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">deactivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>isActivated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">///////////</span>
<span class="token comment">// 组合类</span>
<span class="token comment">///////////</span>

<span class="token comment">// 简单的类</span>
<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 添加 TimesTamped 的 User</span>
<span class="token keyword">const</span> TimestampedUser <span class="token operator">=</span> <span class="token function">TimesTamped</span><span class="token punctuation">(</span>User<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Tina TimesTamped 和 Activatable 的类</span>
<span class="token keyword">const</span> TimestampedActivatableUser <span class="token operator">=</span> <span class="token function">TimesTamped</span><span class="token punctuation">(</span><span class="token function">Activatable</span><span class="token punctuation">(</span>User<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//////////</span>
<span class="token comment">// 使用组合类</span>
<span class="token comment">//////////</span>

<span class="token keyword">const</span> timestampedUserExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimestampedUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>timestampedUserExample<span class="token punctuation">.</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> timestampedActivatableUserExample <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimestampedActivatableUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>timestampedActivatableUserExample<span class="token punctuation">.</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>timestampedActivatableUserExample<span class="token punctuation">.</span>isActivated<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>让我们分解这个例子。</p><h4 id="创建一个构造函数"><a class="header-anchor" href="#创建一个构造函数" aria-hidden="true">#</a> 创建一个构造函数</h4><p>混合接受一个类，并且使用新功能扩展它。因此，我们需要定义构造函数的类型：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Constructor<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">;</span>

</code></pre></div><h4 id="扩展一个类并且返回它"><a class="header-anchor" href="#扩展一个类并且返回它" aria-hidden="true">#</a> 扩展一个类并且返回它</h4><div class="language-ts"><pre><code><span class="token comment">// 添加属性的混合例子</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">TimesTamped</span><span class="token generic class-name"><span class="token operator">&lt;</span>TBase <span class="token keyword">extends</span> Constructor<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Base<span class="token operator">:</span> TBase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">extends</span></span> Base <span class="token punctuation">{</span>
    timestamp <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="thistype"><a class="header-anchor" href="#thistype" aria-hidden="true">#</a> ThisType</h3><p>通过 <code>ThisType</code> 我们可以在对象字面量中键入 <code>this</code>，并提供通过上下文类型控制 <code>this</code> 类型的便捷方式。它只有在 <code>--noImplicitThis</code> 的选项下才有效。</p><p>现在，在对象字面量方法中的 <code>this</code> 类型，将由以下决定：</p><ul><li>如果这个方法显式指定了 <code>this</code> 参数，那么 <code>this</code> 具有该参数的类型。（下例子中 <code>bar</code>）</li><li>否则，如果方法由带 <code>this</code> 参数的签名进行上下文键入，那么 <code>this</code> 具有该参数的类型。（下例子中 <code>foo</code>）</li><li>否则，如果 <code>--noImplicitThis</code> 选项已经启用，并且对象字面量中包含由 <code>ThisType&lt;T&gt;</code> 键入的上下文类型，那么 <code>this</code> 的类型为 <code>T</code>。</li><li>否则，如果 <code>--noImplicitThis</code> 选项已经启用，并且对象字面量中不包含由 <code>ThisType&lt;T&gt;</code> 键入的上下文类型，那么 <code>this</code> 的类型为该上下文类型。</li><li>否则，如果 <code>--noImplicitThis</code> 选项已经启用，<code>this</code> 具有该对象字面量的类型。</li><li>否则，<code>this</code> 的类型为 <code>any</code>。</li></ul><p>一些例子：</p><div class="language-ts"><pre><code><span class="token comment">// Compile with --noImplicitThis</span>

<span class="token keyword">type</span> <span class="token class-name">Point</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">moveBy</span><span class="token punctuation">(</span>dx<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> dy<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> p<span class="token operator">:</span> Point <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  y<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  <span class="token function">moveBy</span><span class="token punctuation">(</span>dx<span class="token punctuation">,</span> dy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> dx<span class="token punctuation">;</span> <span class="token comment">// this has type Point</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> dy<span class="token punctuation">;</span> <span class="token comment">// this has type Point</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">,</span>
  <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// { x: string, f(n: number): void }</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">,</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> <span class="token punctuation">{</span> message<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// { message: string }</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>类似的方式，当使用 <code>--noImplicitThis</code> 时，函数表达式赋值给 <code>obj.xxx</code> 或者 <code>obj[xxx]</code> 的目标时，在函数中 <code>this</code> 的类型将会是 <code>obj</code>：</p><div class="language-ts"><pre><code><span class="token comment">// Compile with --noImplicitThis</span>

obj<span class="token punctuation">.</span><span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">-</span> n<span class="token punctuation">;</span> <span class="token comment">// &#39;this&#39; has same type as &#39;obj&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

obj<span class="token punctuation">[</span><span class="token string">&#39;f&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">-</span> n<span class="token punctuation">;</span> <span class="token comment">// &#39;this&#39; has same type as &#39;obj&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>通过 API 转换参数的形式来生成 <code>this</code> 的值的情景下，可以通过创建一个新的 <code>ThisType&lt;T&gt;</code> 标记接口，可用于在上下文中表明转换后的类型。尤其是当字面量中的上下文类型为 <code>ThisType&lt;T&gt;</code> 或者是包含 <code>ThisType&lt;T&gt;</code> 的交集时，显得尤为有效，对象字面量方法中 <code>this</code> 的类型即为 <code>T</code>。</p><div class="language-ts"><pre><code><span class="token comment">// Compile with --noImplicitThis</span>

<span class="token keyword">type</span> <span class="token class-name">ObjectDescriptor<span class="token operator">&lt;</span><span class="token constant">D</span><span class="token punctuation">,</span> <span class="token constant">M</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  data<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">D</span><span class="token punctuation">;</span>
  methods<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">M</span> <span class="token operator">&amp;</span> ThisType<span class="token operator">&lt;</span><span class="token constant">D</span> <span class="token operator">&amp;</span> <span class="token constant">M</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// Type of &#39;this&#39; in methods is D &amp; M</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">makeObject</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">D</span><span class="token punctuation">,</span> <span class="token constant">M</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>desc<span class="token operator">:</span> ObjectDescriptor<span class="token operator">&lt;</span><span class="token constant">D</span><span class="token punctuation">,</span> <span class="token constant">M</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">D</span> <span class="token operator">&amp;</span> <span class="token constant">M</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> data<span class="token operator">:</span> object <span class="token operator">=</span> desc<span class="token punctuation">.</span>data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> methods<span class="token operator">:</span> object <span class="token operator">=</span> desc<span class="token punctuation">.</span>methods <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>data<span class="token punctuation">,</span> <span class="token operator">...</span>methods <span class="token punctuation">}</span> <span class="token keyword">as</span> <span class="token constant">D</span> <span class="token operator">&amp;</span> <span class="token constant">M</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token function">makeObject</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">moveBy</span><span class="token punctuation">(</span>dx<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> dy<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> dx<span class="token punctuation">;</span> <span class="token comment">// Strongly typed this</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> dy<span class="token punctuation">;</span> <span class="token comment">// Strongly typed this</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">moveBy</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在上面的例子中，<code>makeObject</code> 参数中的对象属性 <code>methods</code> 具有包含 <code>ThisType&lt;D &amp; M&gt;</code> 的上下文类型，因此对象中 <code>methods</code> 属性下的方法的 <code>this</code> 类型为 <code>{ x: number, y: number } &amp; { moveBy(dx: number, dy: number): number }</code>。</p><p><code>ThisType&lt;T&gt;</code> 的接口，在 <code>lib.d.ts</code> 只是被声明为空的接口，除了可以在对象字面量上下文中可以被识别以外，该接口的作用等同于任意空接口。</p><h2 id="typescript-编译原理"><a class="header-anchor" href="#typescript-编译原理" aria-hidden="true">#</a> TypeScript 编译原理</h2><h3 id="概览-1"><a class="header-anchor" href="#概览-1" aria-hidden="true">#</a> 概览</h3><p>TypeScript 编译器源文件位于 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/compiler" target="_blank" rel="noopener noreferrer"><code>src/compiler</code></a> 目录下</p><blockquote><p>译注：Typescript Deep Dive 使用的源码应为 2016 年以前的源码。学习时请对照现有的源码</p></blockquote><p>它分为以下几个关键部分：</p><ul><li>Scanner 扫描器（<code>scanner.ts</code>）</li><li>Parser 解析器（<code>parser.ts）</code></li><li>Binder 绑定器（<code>binder.ts）</code></li><li>Checker 检查器（<code>checker.ts</code>）</li><li>Emitter 发射器（<code>emitter.ts</code>）</li></ul><p>每个部分在源文件中均有独立文件，本章稍后会对这些部分做解释。</p><h4 id="byots"><a class="header-anchor" href="#byots" aria-hidden="true">#</a> BYOTS</h4><p>我们有个名为 <a href="https://github.com/basarat/byots" target="_blank" rel="noopener noreferrer">Bring Your Own TypeScript (BYOTS)</a> 的项目，通过暴露内部接口让编译器 API 使用起来更简单。你可以在全局范围上暴露你 TypeScript 应用的本地变量。</p><h4 id="语法和语义"><a class="header-anchor" href="#语法和语义" aria-hidden="true">#</a> 语法和语义</h4><p><strong>语法</strong>正确并不意味着语义上也正确。下面的 TypeScript 代码，语法合法，但是语义却不正确</p><div class="language-ts"><pre><code><span class="token keyword">var</span> foo<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token string">&#39;not a number&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p><code>语义</code> 从自然语言角度意味着有意义，理解这个概念对你很有用。</p><h4 id="处理概览"><a class="header-anchor" href="#处理概览" aria-hidden="true">#</a> 处理概览</h4><p>以下演示简单说明 TypeScript 编译器如何将上述几个关键部分组合在一起：</p><div class="language-shell"><pre><code>SourceCode（源码） ~~ 扫描器 ~~<span class="token operator">&gt;</span> Token 流
</code></pre></div><div class="language-shell"><pre><code>Token 流 ~~ 解析器 ~~<span class="token operator">&gt;</span> AST（抽象语法树）
</code></pre></div><div class="language-shell"><pre><code>AST ~~ 绑定器 ~~<span class="token operator">&gt;</span> Symbols（符号）
</code></pre></div><p>符号（<code>Symbol</code>）是 TypeScript 语义系统的主要构造块。如上所示，符号是绑定的结果。符号将 AST 中的声明节点与相同实体的其他声明相连。</p><p>符号和 AST 是检查器用来验证源代码语义的</p><div class="language-shell"><pre><code>AST + 符号 ~~ 检查器 ~~<span class="token operator">&gt;</span> 类型验证
</code></pre></div><p>最后，需要输出 JavaScript 时：</p><div class="language-shell"><pre><code>AST + 检查器 ~~ 发射器 ~~<span class="token operator">&gt;</span> JavaScript 代码
</code></pre></div><p>TypeScript 编译器中还有一些其他文件，为我们接下来介绍的很多关键部分提供实用工具。</p><h4 id="文件：utilities"><a class="header-anchor" href="#文件：utilities" aria-hidden="true">#</a> 文件：Utilities</h4><p><code>core.ts</code> ：TypeScript 编译器使用的核心工具集，重要的有：</p><ul><li><code>let objectAllocator: ObjectAllocator</code> 是一个定义为全局单例的变量。提供以下定义： <ul><li><code>getNodeConstructor</code>（节点会在解析器 / AST 中介绍）</li><li><code>getSymbolConstructor</code>（符号会在绑定器中介绍）</li><li><code>getTypeConstructor</code>（类型会在检查器中介绍）</li><li><code>getSignatureConstructor</code>（签名是索引，调用和构造签名）</li></ul></li></ul><h4 id="文件：关键数据结构"><a class="header-anchor" href="#文件：关键数据结构" aria-hidden="true">#</a> 文件：关键数据结构</h4><p><code>types.ts</code> 包含整个编译器中使用的关键数据结构和接口，这里列出一些关键部分：</p><ul><li><code>SyntaxKind</code> AST 节点类型通过 <code>SyntaxKind</code> 枚举进行识别</li><li><code>TypeChecker</code> 类型检查器提供此接口</li><li><code>CompilerHost</code> 用于程序（Program）和系统之间的交互</li><li><code>Node</code> AST 节点</li></ul><h4 id="文件：系统"><a class="header-anchor" href="#文件：系统" aria-hidden="true">#</a> 文件：系统</h4><p><code>system.ts</code>，TypeScript 编译器与操作系统的所有交互均通过 <code>System</code> 接口进行。接口及其实现（<code>WScript</code> 和 <code>Node</code>） 均定义在 <code>system.ts</code> 中。你可以将其视为<strong>操作环境（OE, Operating Environment）</strong>。</p><p>现在对主要文件有一个整体了解了，我们继续介绍程序（<code>Program</code>）的概念</p><h3 id="程序"><a class="header-anchor" href="#程序" aria-hidden="true">#</a> 程序</h3><p>程序定义在 <code>program.ts</code> 中。<a href="#%E7%BC%96%E8%AF%91%E4%B8%8A%E4%B8%8B%E6%96%87">编译上下文</a>在 TypeScript 编译器中被视为一个 <code>Program</code>，它包含 <code>SourceFile</code> 和编译选项</p><h4 id="compilerhost-的使用"><a class="header-anchor" href="#compilerhost-的使用" aria-hidden="true">#</a> <code>CompilerHost</code> 的使用</h4><p>CompilerHost 是与操作环境（OE, Operating Enviornment）进行交互的机制：</p><p><code>Program</code> -使用-&gt; <code>CompilerHost</code> -使用-&gt; <code>System</code></p><p>用 <code>CompilerHost</code> 作中间层的原因是可以让接口对 <code>Program</code> 的需求进行细粒度的调整，而无需考虑操作环境的需求。（例如：<code>Program</code> 无需关心 <code>System</code> 的 <code>fileExists</code> 函数）</p><p>对<code>System</code>而言还有其他的使用者（比如测试）</p><h4 id="sourcefile"><a class="header-anchor" href="#sourcefile" aria-hidden="true">#</a> SourceFile</h4><p>程序有个 API，用于获取 SourceFile：<code>getSourceFiles(): SourceFile[];</code>。得到的每个元素均是一棵抽象语法树的根节点（称做 <code>SourceFile</code>）</p><h3 id="抽象语法树"><a class="header-anchor" href="#抽象语法树" aria-hidden="true">#</a> 抽象语法树</h3><h4 id="node-节点"><a class="header-anchor" href="#node-节点" aria-hidden="true">#</a> Node 节点</h4><p>节点是抽象语法树（AST） 的基本构造块。语法上，通常 <code>Node</code> 表示非末端（non-terminals）节点。但是，有些末端节点，如：标识符和字面量也会保留在树中。</p><p>AST 节点文档由两个关键部分构成。一是节点的 <code>SyntaxKind</code> 枚举，用于标识 AST 中的类型。二是其接口，即实例化 AST 时节点提供的 API。</p><p>这里是 <code>interface Node</code> 的一些关键成员：</p><ul><li><code>TextRange</code> 标识该节点在源文件中的起止位置。</li><li><code>parent?: Node</code> 当前节点（在 AST 中）的父节点</li></ul><p><code>Node</code> 还有一些其他的成员，标志（flags）和修饰符（modifiers）等。你可以在源码中搜索 <code>interface Node</code> 来查看，而上面提到对节点的遍历是非常重要的。</p><h5 id="sourcefile-1"><a class="header-anchor" href="#sourcefile-1" aria-hidden="true">#</a> SourceFile</h5><ul><li><code>SyntaxKind.SourceFile</code></li><li><code>interface SourceFile</code></li></ul><p>每个 <code>SourceFile</code> 都是一棵 AST 的顶级节点，它们包含在 <code>Program</code> 中。</p><h4 id="ast-技巧：访问子节点"><a class="header-anchor" href="#ast-技巧：访问子节点" aria-hidden="true">#</a> AST 技巧：访问子节点</h4><p>有个工具函数 <code>ts.forEachChild</code>，可以用来访问 AST 任一节点的所有子节点。</p><p>下面是简化的代码片段，用于演示如何工作：</p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">forEachChild</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">,</span> <span class="token function-variable function">cbNode</span><span class="token operator">:</span> <span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">,</span> cbNodeArray<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span>nodes<span class="token operator">:</span> Node<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>BinaryExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">visitNode</span><span class="token punctuation">(</span>cbNode<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>BinaryExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token function">visitNode</span><span class="token punctuation">(</span>cbNode<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>BinaryExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>operatorToken<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token function">visitNode</span><span class="token punctuation">(</span>cbNode<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>BinaryExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>IfStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">visitNode</span><span class="token punctuation">(</span>cbNode<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>IfStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>expression<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token function">visitNode</span><span class="token punctuation">(</span>cbNode<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>IfStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>thenStatement<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token function">visitNode</span><span class="token punctuation">(</span>cbNode<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>IfStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>elseStatement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// .... 更多</span>
</code></pre></div><p>该函数主要检查 <code>node.kind</code> 并据此判断 node 的接口，然后在其子节点上调用 <code>cbNode</code>。但是，要注意该函数不会为<strong>所有</strong>子节点调用 <code>visitNode</code>（例如：SyntaxKind.SemicolonToken）。想获得某 AST 节点的<strong>所有</strong>子节点，只要调用该节点的成员函数 <code>.getChildren</code>。</p><p>如下函数会打印 AST 节点详细信息：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">printAllChildren</span><span class="token punctuation">(</span>node<span class="token operator">:</span> ts<span class="token punctuation">.</span>Node<span class="token punctuation">,</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;----&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">.</span><span class="token function">syntaxKindToName</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>kind<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>pos<span class="token punctuation">,</span> node<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
  depth<span class="token operator">++</span><span class="token punctuation">;</span>
  node<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>c <span class="token operator">=&gt;</span> <span class="token function">printAllChildren</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们进一步讨论解析器时会看到该函数的使用示例。</p><h4 id="ast-技巧：syntaxkind-枚举"><a class="header-anchor" href="#ast-技巧：syntaxkind-枚举" aria-hidden="true">#</a> AST 技巧：SyntaxKind 枚举</h4><p><code>SyntaxKind</code> 被定义为一个常量枚举，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token keyword">enum</span> SyntaxKind <span class="token punctuation">{</span>
  Unknown<span class="token punctuation">,</span>
  EndOfFileToken<span class="token punctuation">,</span>
  SingleLineCommentTrivia<span class="token punctuation">,</span>
  <span class="token comment">// ... 更多</span>
</code></pre></div><p>这是个<a href="#%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE">常量枚举</a>，方便内联（例如：<code>ts.SyntaxKind.EndOfFileToken</code> 会变为 <code>1</code>），这样在使用 AST 时就不会有处理引用的额外开销。但编译时需要使用 --preserveConstEnums 编译标志，以便枚举<strong>在运行时仍可用</strong>。JavaScript 中你也可以根据需要使用 <code>ts.SyntaxKind.EndOfFileToken</code>。另外，可以用以下函数，将枚举成员转化为可读的字符串：</p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">syntaxKindToName</span><span class="token punctuation">(</span>kind<span class="token operator">:</span> ts<span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span>ts<span class="token punctuation">)</span><span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">[</span>kind<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="ast-杂项"><a class="header-anchor" href="#ast-杂项" aria-hidden="true">#</a> AST 杂项</h4><p>杂项（Trivia）是指源文本中对正常理解代码不太重要的部分，例如：空白，注释，冲突标记。（为了保持轻量）杂项<strong>不会存储</strong>在 AST 中。但是可以视需要使用一些 <code>ts.*</code> API 来获取。</p><p>展示这些 API 前，你需要理解以下内容：</p><h5 id="杂项所有权"><a class="header-anchor" href="#杂项所有权" aria-hidden="true">#</a> 杂项所有权</h5><p>通常：</p><ul><li>token 拥有它后面 同一行 到下一个 token 之前的所有杂项</li><li>该行之后的注释都与下个的 token 相关</li></ul><p>对于文件中的前导（leading）和结束（ending）注释：</p><ul><li>源文件中的第一个 token 拥有所有开始的杂项</li><li>而文件最后的一些列杂项则附加到文件结束符上，该 token 长度为 0</li></ul><h5 id="杂项-api"><a class="header-anchor" href="#杂项-api" aria-hidden="true">#</a> 杂项 API</h5><p>注释在多数基本使用中，都是让人关注的杂项。节点的注释可以通过以下函数获取：</p><table><thead><tr><th style="text-align:center;">函数</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;"><code>ts.getLeadingCommentRanges</code></td><td style="text-align:center;">给定源文本及其位置，返回给定位置后第一个换行符到 token 本身之间的注释范围（可能需要结合 <code>ts.Node.getFullStart</code> 使用）。</td></tr><tr><td style="text-align:center;"><code>ts.getTrailingCommentRanges</code></td><td style="text-align:center;">给定源文本及其位置，返回给定位置后第一个换行符之前的注释范围（可能需要结合 <code>ts.Node.getEnd</code> 使用）。</td></tr></tbody></table><p>假设下面是某个源文件的一部分：</p><div class="language-ts"><pre><code><span class="token keyword">debugger</span><span class="token punctuation">;</span><span class="token comment">/*hello*/</span>
    <span class="token comment">//bye</span>
  <span class="token comment">/*hi*/</span>    <span class="token keyword">function</span>
</code></pre></div><p>对 <code>function</code> <code>而言，getLeadingCommentRanges</code> 仅返回最后的两个注释 <code>//bye</code> 和 <code>/*hi*/</code>。 另外，而在 <code>debugger</code> 语句结束位置调用 <code>getTrailingCommentRanges</code> 会得到注释 <code>/*hello*/</code>。</p><h5 id="token-start-和-full-start-位置"><a class="header-anchor" href="#token-start-和-full-start-位置" aria-hidden="true">#</a> Token Start 和 Full Start 位置</h5><p>节点有所谓的 &quot;token start&quot; 和 &quot;full start&quot; 位置。</p><ul><li>Token Start：比较自然的版本，即文件中一个 token 的文本开始的位置。</li><li>Full Start：是指扫描器从上一个重要 token 开始扫描的位置。</li></ul><p>AST 节点有 <code>getStart</code> 和 <code>getFullStart</code> API 用于获取以上两种位置，还是这个例子：</p><div class="language-ts"><pre><code><span class="token keyword">debugger</span><span class="token punctuation">;</span><span class="token comment">/*hello*/</span>
    <span class="token comment">//bye</span>
  <span class="token comment">/*hi*/</span>    <span class="token keyword">function</span>
</code></pre></div><p>对 <code>function</code> 而言，token start 即 <code>function</code> 的位置，而 <strong>full</strong> start 是 <code>/*hello*/</code> 的位置。要注意，full start 甚至会包含前一节点拥有的杂项。</p><h3 id="扫描器"><a class="header-anchor" href="#扫描器" aria-hidden="true">#</a> 扫描器</h3><p>TypeScript 扫描器的源码均位于 <code>scanner.ts</code>。在内部，由解析器控制扫描器将源码转化为抽象语法树（AST）。期望结果如下：</p><div class="language-shell"><pre><code>SourceCode ~~ 扫描器 ~~<span class="token operator">&gt;</span> Token 流 ~~ 解析器 ~~<span class="token operator">&gt;</span> AST
</code></pre></div><h4 id="解析器对扫描器的使用"><a class="header-anchor" href="#解析器对扫描器的使用" aria-hidden="true">#</a> 解析器对扫描器的使用</h4><p>为避免重复创建扫描器造成的开销，<code>parser.ts</code> 中创建了一个扫描器的<strong>单例</strong>。解析器根据需要使用 <code>initializeState</code> 函数准备该扫描器。</p><p>下面是解析器中的实际代码的简化版，你可以运行它演示以上概念</p><p><code>code/compiler/scanner/runScanner.ts</code></p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> ts <span class="token keyword">from</span> <span class="token string">&#39;ntypescript&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 单例扫描器</span>
<span class="token keyword">const</span> scanner <span class="token operator">=</span> ts<span class="token punctuation">.</span><span class="token function">createScanner</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span>ScriptTarget<span class="token punctuation">.</span>Latest<span class="token punctuation">,</span> <span class="token comment">/* 忽略杂项 */</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 此函数与初始化使用的 `initializeState` 函数相似</span>
<span class="token keyword">function</span> <span class="token function">initializeState</span><span class="token punctuation">(</span>text<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  scanner<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
  scanner<span class="token punctuation">.</span><span class="token function">setOnError</span><span class="token punctuation">(</span><span class="token punctuation">(</span>message<span class="token operator">:</span> ts<span class="token punctuation">.</span>DiagnosticMessage<span class="token punctuation">,</span> length<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  scanner<span class="token punctuation">.</span><span class="token function">setScriptTarget</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span>ScriptTarget<span class="token punctuation">.</span><span class="token constant">ES5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  scanner<span class="token punctuation">.</span><span class="token function">setLanguageVariant</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span>LanguageVariant<span class="token punctuation">.</span>Standard<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用示例</span>
<span class="token function">initializeState</span><span class="token punctuation">(</span>
  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
var foo = 123;
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 开始扫描</span>
<span class="token keyword">var</span> token <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>token <span class="token operator">!=</span> ts<span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">.</span>EndOfFileToken<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span><span class="token function">formatSyntaxKind</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  token <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该段代码输出以下内容：</p><div class="language-shell"><pre><code>VarKeyword
Identifier
FirstAssignment
FirstLiteralToken
SemicolonToken
</code></pre></div><h4 id="扫描器状态"><a class="header-anchor" href="#扫描器状态" aria-hidden="true">#</a> 扫描器状态</h4><p>调用 <code>scan</code> 后，扫描器更新其局部状态（扫描位置，当前 token 详情等）。扫描器提供了一组工具函数获取当前扫描器状态。下例中，我们创建一个扫描器并用它识别 token 以及 token 在代码中的位置。</p><p><code>code/compiler/scanner/runScannerWithPosition.ts</code></p><div class="language-ts"><pre><code><span class="token comment">// 使用示例</span>
<span class="token function">initializeState</span><span class="token punctuation">(</span>
  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
var foo = 123;
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 开始扫描</span>
<span class="token keyword">var</span> token <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>token <span class="token operator">!=</span> ts<span class="token punctuation">.</span>SyntaxKind<span class="token punctuation">.</span>EndOfFileToken<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> currentToken <span class="token operator">=</span> ts<span class="token punctuation">.</span><span class="token function">formatSyntaxKind</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> tokenStart <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">getStartPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  token <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> tokenEnd <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">getStartPos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>currentToken<span class="token punctuation">,</span> tokenStart<span class="token punctuation">,</span> tokenEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该代码输出以下内容：</p><div class="language-shell"><pre><code>VarKeyword <span class="token number">0</span> <span class="token number">3</span>
Identifier <span class="token number">3</span> <span class="token number">7</span>
FirstAssignment <span class="token number">7</span> <span class="token number">9</span>
FirstLiteralToken <span class="token number">9</span> <span class="token number">13</span>
SemicolonToken <span class="token number">13</span> <span class="token number">14</span>
</code></pre></div><h4 id="独立扫描器"><a class="header-anchor" href="#独立扫描器" aria-hidden="true">#</a> 独立扫描器</h4><p>即便 TypeScript 解析器有单例扫描器，你仍可以使用 <code>createScanner</code> 创建独立的扫描器，然后可以用 <code>setText/setTextPos</code> 随意扫描文件的不同位置。</p><h3 id="解析器"><a class="header-anchor" href="#解析器" aria-hidden="true">#</a> 解析器</h3><p>TypeScript 解析器代码均位于 parser.ts 中。在内部，由解析器控制扫描器将源码转化为 AST。其期望结果如下：</p><div class="language-shell"><pre><code>源码 ~~ 扫描器 ~~<span class="token operator">&gt;</span> Token 流 ~~ 解析器 ~~<span class="token operator">&gt;</span> AST
</code></pre></div><p>解析器实现原理是单例模式（其原因类似扫描器，如果能重新初始化就不重新构建）。实际实现成 <code>namespace Parser</code>，包含解析器的各种状态变量和单例扫描器（<code>const scanner</code>）。该扫描器由解析器函数管理。</p><h4 id="程序对解析器的使用"><a class="header-anchor" href="#程序对解析器的使用" aria-hidden="true">#</a> 程序对解析器的使用</h4><p>解析器由程序间接驱动（通过之前提到过的 <code>CompilerHost</code>）。基本上，简化的调用栈如下所示：</p><div class="language-shell"><pre><code>程序 -<span class="token operator">&gt;</span>
  CompilerHost.getSourceFile -<span class="token operator">&gt;</span>
    <span class="token punctuation">(</span>全局函数 parser.ts<span class="token punctuation">)</span>.createSourceFile -<span class="token operator">&gt;</span>
      Parser.parseSourceFile
</code></pre></div><p><code>parseSourceFile</code> 不仅准备好解析器的状态，还调用 <code>initializeState</code> 准备好扫描器的状态。然后使用 <code>parseSourceFileWorker</code> 继续解析源代码。</p><h4 id="使用示例"><a class="header-anchor" href="#使用示例" aria-hidden="true">#</a> 使用示例</h4><p>深入解析器的内部之前，这里有个使用 TypeScript 解析器的示例，（使用 <code>ts.createSourceFile</code>）获取一个源文件的 AST 并打印它。</p><p><code>code/compiler/parser/runParser.ts</code></p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> ts <span class="token keyword">from</span> <span class="token string">&#39;ntypescript&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">printAllChildren</span><span class="token punctuation">(</span>node<span class="token operator">:</span> ts<span class="token punctuation">.</span>Node<span class="token punctuation">,</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;----&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">.</span><span class="token function">formatSyntaxKind</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>kind<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>pos<span class="token punctuation">,</span> node<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
  depth<span class="token operator">++</span><span class="token punctuation">;</span>
  node<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>c <span class="token operator">=&gt;</span> <span class="token function">printAllChildren</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> sourceCode <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
var foo = 123;
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> sourceFile <span class="token operator">=</span> ts<span class="token punctuation">.</span><span class="token function">createSourceFile</span><span class="token punctuation">(</span><span class="token string">&#39;foo.ts&#39;</span><span class="token punctuation">,</span> sourceCode<span class="token punctuation">,</span> ts<span class="token punctuation">.</span>ScriptTarget<span class="token punctuation">.</span><span class="token constant">ES5</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printAllChildren</span><span class="token punctuation">(</span>sourceFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>该段代码会打印以下内容：</p><div class="language-ts"><pre><code>SourceFile <span class="token number">0</span> <span class="token number">14</span>
<span class="token operator">--</span><span class="token operator">--</span> SyntaxList <span class="token number">0</span> <span class="token number">14</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> VariableStatement <span class="token number">0</span> <span class="token number">14</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> VariableDeclarationList <span class="token number">0</span> <span class="token number">13</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> VarKeyword <span class="token number">0</span> <span class="token number">3</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> SyntaxList <span class="token number">3</span> <span class="token number">13</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> VariableDeclaration <span class="token number">3</span> <span class="token number">13</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> Identifier <span class="token number">3</span> <span class="token number">7</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> FirstAssignment <span class="token number">7</span> <span class="token number">9</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> FirstLiteralToken <span class="token number">9</span> <span class="token number">13</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> SemicolonToken <span class="token number">13</span> <span class="token number">14</span>
<span class="token operator">--</span><span class="token operator">--</span> EndOfFileToken <span class="token number">14</span> <span class="token number">14</span>
</code></pre></div><p>如果把头向左倾，这个看起来像棵（右侧）树</p><h4 id="解析器函数"><a class="header-anchor" href="#解析器函数" aria-hidden="true">#</a> 解析器函数</h4><p>如前所述，<code>parseSourceFile</code> 设置初始状态并将工作交给 <code>parseSourceFileWorker</code> 函数。</p><h5 id="parsesourcefileworker"><a class="header-anchor" href="#parsesourcefileworker" aria-hidden="true">#</a> <code>parseSourceFileWorker</code></h5><p>该函数先创建一个 <code>SourceFile</code> AST 节点，然后从 <code>parseStatements</code> 函数开始解析源代码。一旦返回结果，就用额外信息（例如 <code>nodeCount</code>, <code>identifierCount</code>等） 完善 <code>SourceFile</code> 节点。</p><h5 id="parsestatements"><a class="header-anchor" href="#parsestatements" aria-hidden="true">#</a> <code>parseStatements</code></h5><p>是最重要的 <code>parseXXX</code> 系函数之一（概念接下来介绍）。它根据扫描器返回的当前 token 来切换（调用相应的 <code>parseXXX</code> 函数），例如：如果当前 token 是一个 <code>SemicolonToken</code>（分号标记），就会调用 <code>paserEmptyStatement</code> 为空语句创建一个 AST 节点</p><h5 id="节点创建"><a class="header-anchor" href="#节点创建" aria-hidden="true">#</a> 节点创建</h5><p>解析器有一系列 <code>parseXXX</code> 函数用来创建相应类型为XXX的节点，通常在相应类型的节点出现时被（其他解析器函数）调用。该过程的典型示例是解析空语句（例如 <code>;;;;;;</code>）时要用的 <code>parseEmptyStatement()</code> 函数。下面是其全部代码：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">parseEmptyStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Statement <span class="token punctuation">{</span>
  <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token operator">&lt;</span>Statement<span class="token operator">&gt;</span><span class="token function">createNode</span><span class="token punctuation">(</span>SyntaxKind<span class="token punctuation">.</span>EmptyStatement<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">parseExpected</span><span class="token punctuation">(</span>SyntaxKind<span class="token punctuation">.</span>SemicolonToken<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">finishNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它展示了 3 个关键函数 <code>createNode</code>, <code>parseExpected</code> 和 <code>finishNode</code>.</p><h6 id="createnode"><a class="header-anchor" href="#createnode" aria-hidden="true">#</a> <code>createNode</code></h6><p>解析器函数 <code>function createNode(kind: SyntaxKind, pos?: number): Node</code> 负责创建节点，设置传入的 <code>SyntaxKind</code>（语法类别），和初始位置（默认使用当前扫描器状态提供的位置信息）。</p><h6 id="parseexpected"><a class="header-anchor" href="#parseexpected" aria-hidden="true">#</a> <code>parseExpected</code></h6><p>解析器的 <code>parseExpected</code> 函数 <code>function parseExpected(kind: SyntaxKind, diagnosticMessage?: DiagnosticMessage): boolean</code> 会检查解析器状态中的当前 token 是否与指定的 <code>SyntaxKind</code> 匹配。如果不匹配，则会向传入的 <code>diagnosticMessage</code>（诊断消息）报告，未传入则创建某种通用形式 <code>xxx expected</code>。该函数内部用 <code>parseErrorAtPosition</code> 函数（使用扫描位置）提供良好的错误报告。</p><h6 id="finishnode"><a class="header-anchor" href="#finishnode" aria-hidden="true">#</a> <code>finishNode</code></h6><p>解析器的 <code>finishNode</code> 函数 <code>function finishNode&lt;T extends Node&gt;(node: T, end?: number): T</code> 设置节点的 <code>end</code> 位置，并添加一些有用的信息，例如上下文标志（<code>parserContextFlags</code>）以及解析该节点前出现的错误（如果有错的话，就不能在增量解析中重用此 AST 节点）。</p><h3 id="绑定器"><a class="header-anchor" href="#绑定器" aria-hidden="true">#</a> 绑定器</h3><p>大多数的 JavaScript 转译器（transpiler）都比 TypeScript 简单，因为它们几乎没提供代码分析的方法。典型的 JavaScript 转换器只有以下流程：</p><div class="language-shell"><pre><code>源码 ~~扫描器~~<span class="token operator">&gt;</span> Tokens ~~解析器~~<span class="token operator">&gt;</span> AST ~~发射器~~<span class="token operator">&gt;</span> JavaScript
</code></pre></div><p>上述架构确实对于简化 TypeScript 生成 JavaScript 的理解有帮助，但缺失了一个关键功能，即 TypeScript 的语义系统。为了协助（检查器执行）类型检查，绑定器将源码的各部分连接成一个相关的类型系统，供检查器使用。绑定器的主要职责是创建符号（Symbols）。</p><h4 id="符号"><a class="header-anchor" href="#符号" aria-hidden="true">#</a> 符号</h4><p>符号将 AST 中的声明节点与其它声明连接到相同的实体上。符号是语义系统的基本构造块。符号的构造器定义在 <code>core.ts</code>（绑定器实际上通过 <code>objectAllocator.getSymbolConstructor</code> 来获取构造器）。下面是符号构造器：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>flags<span class="token operator">:</span> SymbolFlags<span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>flags <span class="token operator">=</span> flags<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>declarations <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>SymbolFlags</code> 符号标志是个标志枚举，用于识别额外的符号类别（例如：变量作用域标志 <code>FunctionScopedVariable</code> 或 <code>BlockScopedVariable</code> 等）</p><h4 id="检查器对绑定器的使用"><a class="header-anchor" href="#检查器对绑定器的使用" aria-hidden="true">#</a> 检查器对绑定器的使用</h4><p>实际上，绑定器被检查器在内部调用，而检查器又被程序调用。简化的调用栈如下所示：</p><div class="language-ts"><pre><code>program<span class="token punctuation">.</span>getTypeChecker <span class="token operator">-</span><span class="token operator">&gt;</span>
  ts<span class="token punctuation">.</span>createTypeChecker（检查器中）<span class="token operator">-</span><span class="token operator">&gt;</span>
    initializeTypeChecker（检查器中） <span class="token operator">-</span><span class="token operator">&gt;</span>
      <span class="token keyword">for</span> each SourceFile <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">ts.bindSourceFile</span><span class="token template-punctuation string">`</span></span>（绑定器中）
      <span class="token comment">// followed by</span>
      <span class="token keyword">for</span> each SourceFile <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">ts.mergeSymbolTable</span><span class="token template-punctuation string">`</span></span>（检查器中）
</code></pre></div><p>SourceFile 是绑定器的工作单元，<code>binder.ts</code> 由 <code>checker.ts</code> 驱动。</p><h4 id="绑定器函数"><a class="header-anchor" href="#绑定器函数" aria-hidden="true">#</a> 绑定器函数</h4><p><code>bindSourceFile</code> 和 <code>mergeSymbolTable</code> 是两个关键的绑定器函数，我们来看下：</p><h5 id="bindsourcefile"><a class="header-anchor" href="#bindsourcefile" aria-hidden="true">#</a> <code>bindSourceFile</code></h5><p>该函数主要是检查 <code>file.locals</code> 是否定义，如果没有则交给（本地函数） <code>bind</code> 来处理。</p><p>注意：<code>locals</code> 定义在节点上，其类型为 <code>SymbolTable</code>。<code>SourceFile</code> 也是一个节点（事实上是 AST 中的根节点）。</p><p>提示：TypeScript 编译器大量使用本地函数。本地函数很可能使用来自父函数的变量（通过闭包捕获）。例如 <code>bind</code> 是 <code>bindSourceFile</code> 中的一个本地函数，它或它调用的函数会设置 <code>symbolCount</code> 和 <code>classifiableNames</code> 等状态，然后将其存在返回的 <code>SourceFile</code> 中</p><h5 id="bind"><a class="header-anchor" href="#bind" aria-hidden="true">#</a> <code>bind</code></h5><p>bind 能处理任一节点（不只是 <code>SourceFile</code>），它做的第一件事是分配 <code>node.parent</code>（如果 <code>parent</code> 变量已设置，绑定器在 <code>bindChildren</code> 函数的处理中仍会再次设置）， 然后交给 <code>bindWorker</code> 做很多重活。最后调用 <code>bindChildren</code>（该函数简单地将绑定器的状态（如：<code>parent</code>）存入函数本地变量中，接着在每个子节点上调用 <code>bind</code>，然后再将状态转存回绑定器中）。现在我们看下 <code>bindWorker</code>，一个更有趣的函数。</p><h5 id="bindworker"><a class="header-anchor" href="#bindworker" aria-hidden="true">#</a> bindWorker</h5><p>该函数依据 <code>node.kind</code>（<code>SyntaxKind</code>类型）进行切换，并将工作委托给合适的 <code>bindXXX</code> 函数（也定义在<code>binder.ts</code>中）。例如：如果该节点是 <code>SourceFile</code> 则（最终且仅当节点是外部文件模块时）调用 <code>bindAnonymousDeclaration</code></p><h5 id="bindxxx-函数"><a class="header-anchor" href="#bindxxx-函数" aria-hidden="true">#</a> <code>bindXXX</code> 函数</h5><p><code>bindXXX</code> 系函数有一些通用的模式和工具函数。其中最常用的一个是 <code>createSymbol</code> 函数，全部代码展示如下：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">createSymbol</span><span class="token punctuation">(</span>flags<span class="token operator">:</span> SymbolFlags<span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Symbol <span class="token punctuation">{</span>
  symbolCount<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Symbol</span><span class="token punctuation">(</span>flags<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如您所见，它简单地更新 <code>symbolCount</code>（一个 <code>bindSourceFile</code> 的本地变量），并使用指定的参数创建符号。</p><h4 id="绑定器声明"><a class="header-anchor" href="#绑定器声明" aria-hidden="true">#</a> 绑定器声明</h4><h5 id="符号与声明"><a class="header-anchor" href="#符号与声明" aria-hidden="true">#</a> 符号与声明</h5><p>节点和符号间的链接由几个函数执行。其中一个用于绑定 <code>SourceFile</code> 节点到源文件符号（外部模块的情况下）的函数是 <code>addDeclarationToSymbol</code></p><p>注意：外部模块源文件的符号设置方式是 <code>flags : SymbolFlags.ValueModule</code> 和 <code>name: &#39;&quot;&#39; + removeFileExtension(file.fileName) + &#39;&quot;&#39;</code>.</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">addDeclarationToSymbol</span><span class="token punctuation">(</span><span class="token builtin">symbol</span><span class="token operator">:</span> Symbol<span class="token punctuation">,</span> node<span class="token operator">:</span> Declaration<span class="token punctuation">,</span> symbolFlags<span class="token operator">:</span> SymbolFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">symbol</span><span class="token punctuation">.</span>flags <span class="token operator">|=</span> symbolFlags<span class="token punctuation">;</span>

  <span class="token comment">// 创建 AST 节点到 symbol 的连接</span>
  node<span class="token punctuation">.</span><span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token builtin">symbol</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token builtin">symbol</span><span class="token punctuation">.</span>declarations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">symbol</span><span class="token punctuation">.</span>declarations <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将该节点添加为该符号的一个声明</span>
  <span class="token builtin">symbol</span><span class="token punctuation">.</span>declarations<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>symbolFlags <span class="token operator">&amp;</span> SymbolFlags<span class="token punctuation">.</span>HasExports <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token builtin">symbol</span><span class="token punctuation">.</span>exports<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">symbol</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>symbolFlags <span class="token operator">&amp;</span> SymbolFlags<span class="token punctuation">.</span>HasMembers <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token builtin">symbol</span><span class="token punctuation">.</span>members<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">symbol</span><span class="token punctuation">.</span>members <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>symbolFlags <span class="token operator">&amp;</span> SymbolFlags<span class="token punctuation">.</span>Value <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token builtin">symbol</span><span class="token punctuation">.</span>valueDeclaration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">symbol</span><span class="token punctuation">.</span>valueDeclaration <span class="token operator">=</span> node<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述代码主要执行的操作如下：</p><ul><li>创建一个从 AST 节点到符号的链接（<code>node.symbol</code>）</li><li>将节点添加为该符号的一个声明</li></ul><h5 id="声明"><a class="header-anchor" href="#声明" aria-hidden="true">#</a> 声明</h5><p>声明就是一个有可选的名字的节点。下面是 <code>types.ts</code> 中的定义：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Declaration</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
  _declarationBrand<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
  name<span class="token operator">?</span><span class="token operator">:</span> DeclarationName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="绑定器容器"><a class="header-anchor" href="#绑定器容器" aria-hidden="true">#</a> 绑定器容器</h4><p>AST 的节点可以被当作容器。这决定了节点及相关符号的 <code>SymbolTables</code> 的类别。容器是个抽象概念（没有相关的数据结构）。该概念由一些东西决定，<code>ContainerFlags</code> 枚举是其中之一。函数 <code>getContainerFlags</code>（位于 <code>binder.ts</code>） 驱动此标志，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">getContainerFlags</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span><span class="token operator">:</span> ContainerFlags <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ClassExpression<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ClassDeclaration<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>InterfaceDeclaration<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>EnumDeclaration<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TypeLiteral<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ObjectLiteralExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> ContainerFlags<span class="token punctuation">.</span>IsContainer<span class="token punctuation">;</span>

    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>CallSignature<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ConstructSignature<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>IndexSignature<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>MethodDeclaration<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>MethodSignature<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>FunctionDeclaration<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>Constructor<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>GetAccessor<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>SetAccessor<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>FunctionType<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ConstructorType<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>FunctionExpression<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ArrowFunction<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ModuleDeclaration<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>SourceFile<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TypeAliasDeclaration<span class="token operator">:</span>
      <span class="token keyword">return</span> ContainerFlags<span class="token punctuation">.</span>IsContainerWithLocals<span class="token punctuation">;</span>

    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>CatchClause<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ForStatement<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ForInStatement<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ForOfStatement<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>CaseBlock<span class="token operator">:</span>
      <span class="token keyword">return</span> ContainerFlags<span class="token punctuation">.</span>IsBlockScopedContainer<span class="token punctuation">;</span>

    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>Block<span class="token operator">:</span>
      <span class="token comment">// 不要将函数内部的块直接当做块作用域的容器。</span>
      <span class="token comment">// 本块中的本地变量应当置于函数中，否则下例中的 &#39;x&#39; 不会重新声明为一个块作用域的本地变量：</span>
      <span class="token comment">//</span>
      <span class="token comment">//     function foo() {</span>
      <span class="token comment">//         var x;</span>
      <span class="token comment">//         let x;</span>
      <span class="token comment">//     }</span>
      <span class="token comment">//</span>
      <span class="token comment">// 如果将 &#39;var x&#39; 留在函数中，而将 &#39;let x&#39; 放到本块中（函数外），就不会有冲突了。</span>
      <span class="token comment">//</span>
      <span class="token comment">// 如果不在这里创建一个新的块作用域容器，&#39;var x&#39; 和 &#39;let x&#39; 都会进入函数容器本地中，这样就会有碰撞冲突。</span>
      <span class="token keyword">return</span> <span class="token function">isFunctionLike</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">?</span> ContainerFlags<span class="token punctuation">.</span>None <span class="token operator">:</span> ContainerFlags<span class="token punctuation">.</span>IsBlockScopedContainer<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> ContainerFlags<span class="token punctuation">.</span>None<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该函数只在绑定器函数 <code>bindChildren</code> 中调用，会根据 <code>getContainerFlags</code> 的运行结果将节点设为 <code>container</code> 和（或） <code>blockScopedContainer</code>。函数 <code>bindChildren</code> 如下所示：</p><div class="language-ts"><pre><code><span class="token comment">// 所有容器节点都以声明顺序保存在一个链表中。</span>
<span class="token comment">// 类型检查器中的 getLocalNameOfContainer 函数会使用该链表对容器使用的本地名称的唯一性做验证。</span>
<span class="token keyword">function</span> <span class="token function">bindChildren</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在递归到子节点之前，我们先要保存父节点，容器和块容器。处理完弹出的子节点后，再将这些值存回原处。</span>
  <span class="token keyword">let</span> saveParent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
  <span class="token keyword">let</span> saveContainer <span class="token operator">=</span> container<span class="token punctuation">;</span>
  <span class="token keyword">let</span> savedBlockScopeContainer <span class="token operator">=</span> blockScopeContainer<span class="token punctuation">;</span>

  <span class="token comment">// 现在要将这个节点设为父节点，我们要递归它的子节点。</span>
  parent <span class="token operator">=</span> node<span class="token punctuation">;</span>

  <span class="token comment">// 根据节点的类型，需要对当前容器或块容器进行调整。 如果当前节点是个容器，则自动将其视为当前的块容器。</span>
  <span class="token comment">// 由于我们知道容器可能包含本地变量，因此提前初始化 .locals 字段。</span>
  <span class="token comment">// 这样做是因为很可能需要将一些子（节点）置入 .locals 中（例如：函数参数或变量声明）。</span>
  <span class="token comment">//</span>
  <span class="token comment">// 但是，我们不会主动为块容器创建 .locals，因为通常块容器中不会有块作用域变量。</span>
  <span class="token comment">// 我们不想为遇到的每个块都分配一个对象，大多数情况没有必要。</span>
  <span class="token comment">//</span>
  <span class="token comment">// 最后，如果是个块容器，我们就清理该容器中可能存在的 .locals 对象。这种情况常在增量编译场景中发生。</span>
  <span class="token comment">// 由于我们可以重用上次编译的节点，而该节点可能已经创建了 locals 对象。</span>
  <span class="token comment">// 因此必须清理，以免意外地从上次的编译中移动了过时的数据。</span>
  <span class="token keyword">let</span> containerFlags <span class="token operator">=</span> <span class="token function">getContainerFlags</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>containerFlags <span class="token operator">&amp;</span> ContainerFlags<span class="token punctuation">.</span>IsContainer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    container <span class="token operator">=</span> blockScopeContainer <span class="token operator">=</span> node<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>containerFlags <span class="token operator">&amp;</span> ContainerFlags<span class="token punctuation">.</span>HasLocals<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      container<span class="token punctuation">.</span>locals <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">addToContainerChain</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>containerFlags <span class="token operator">&amp;</span> ContainerFlags<span class="token punctuation">.</span>IsBlockScopedContainer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    blockScopeContainer <span class="token operator">=</span> node<span class="token punctuation">;</span>
    blockScopeContainer<span class="token punctuation">.</span>locals <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">forEachChild</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> bind<span class="token punctuation">)</span><span class="token punctuation">;</span>

  container <span class="token operator">=</span> saveContainer<span class="token punctuation">;</span>
  parent <span class="token operator">=</span> saveParent<span class="token punctuation">;</span>
  blockScopeContainer <span class="token operator">=</span> savedBlockScopeContainer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>您可能还记得绑定器函数中的这部分：<code>bindChildren</code> 由 <code>bind</code> 函数调用。我们得到这样的递归绑定：<code>bind</code> 调用 <code>bindChildren</code>，而 bindChildren 又为其每个子节点调用 <code>bind</code></p><h4 id="绑定器符号表"><a class="header-anchor" href="#绑定器符号表" aria-hidden="true">#</a> 绑定器符号表</h4><p>符号表（SymbolTable）是以一个简单的 HashMap 实现的，下面是其接口（<code>types.ts</code>）：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">SymbolTable</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> Symbol<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>符号表通过绑定进行初始化，这里是编译器使用的一些符号表：</p><p>节点上：</p><div class="language-ts"><pre><code>locals<span class="token operator">?</span><span class="token operator">:</span> SymbolTable<span class="token punctuation">;</span>                   <span class="token comment">// 节点相关的本地变量</span>
</code></pre></div><p>符号上：</p><div class="language-ts"><pre><code>members<span class="token operator">?</span><span class="token operator">:</span> SymbolTable<span class="token punctuation">;</span>                  <span class="token comment">// 类，接口或字面量实例成员</span>
exports<span class="token operator">?</span><span class="token operator">:</span> SymbolTable<span class="token punctuation">;</span>                  <span class="token comment">// 模块导出</span>
</code></pre></div><p>请注意：<code>bindChildren</code> 基于 <code>ContainerFlags</code> 初始化 <code>locals</code>（为 <code>{}</code>）</p><h5 id="符号表填充"><a class="header-anchor" href="#符号表填充" aria-hidden="true">#</a> 符号表填充</h5><p>符号表使用符号来填充，主要是通过调用 declareSymbol 来进行，如下所示的是该函数的全部代码：</p><div class="language-ts"><pre><code><span class="token comment">/**
 * 为指定的节点声明一个符号并加入 symbols。标识名冲突时报告错误。
 * @param symbolTable - 要将节点加入进的符号表
 * @param parent - 指定节点的父节点的声明
 * @param node - 要添加到符号表的（节点）声明
 * @param includes - SymbolFlags，指定节点额外的声明类型（例如：export, ambient 等）
 * @param excludes - 不能在符号表中声明的标志，用于报告禁止的声明
 */</span>
<span class="token keyword">function</span> <span class="token function">declareSymbol</span><span class="token punctuation">(</span>
  symbolTable<span class="token operator">:</span> SymbolTable<span class="token punctuation">,</span>
  parent<span class="token operator">:</span> Symbol<span class="token punctuation">,</span>
  node<span class="token operator">:</span> Declaration<span class="token punctuation">,</span>
  includes<span class="token operator">:</span> SymbolFlags<span class="token punctuation">,</span>
  excludes<span class="token operator">:</span> SymbolFlags
<span class="token punctuation">)</span><span class="token operator">:</span> Symbol <span class="token punctuation">{</span>
  Debug<span class="token punctuation">.</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasDynamicName</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 默认导出的函数节点或类节点的符号总是&quot;default&quot;</span>
  <span class="token keyword">let</span> name <span class="token operator">=</span> node<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> NodeFlags<span class="token punctuation">.</span>Default <span class="token operator">&amp;&amp;</span> parent <span class="token operator">?</span> <span class="token string">&#39;default&#39;</span> <span class="token operator">:</span> <span class="token function">getDeclarationName</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> <span class="token builtin">symbol</span><span class="token operator">:</span> Symbol<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查符号表中是否已有同名的符号。若没有，创建此名称的新符号并加入表中。</span>
    <span class="token comment">// 注意，我们尚未给新符号指定任何标志。这可以确保不会和传入的 excludes 标志起冲突。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 如果已存在的一个符号，查看是否与要创建的新符号冲突。</span>
    <span class="token comment">// 例如：同一符号表中，&#39;var&#39; 符号和 &#39;class&#39; 符号会冲突。</span>
    <span class="token comment">// 如果有冲突，报告该问题给该符号的每个声明，然后为该声明创建一个新符号</span>
    <span class="token comment">//</span>
    <span class="token comment">// 如果我们创建的新符号既没在符号表中重名也没和现有符号冲突，就将该节点添加为新符号的唯一声明。</span>
    <span class="token comment">//</span>
    <span class="token comment">// 否则，就要（将新符号）合并进兼容的现有符号中（例如同一容器中有多个同名的 &#39;var&#39; 时）。这种情况下要把该节点添加到符号的声明列表中。</span>
    <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">hasProperty</span><span class="token punctuation">(</span>symbolTable<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
      <span class="token operator">?</span> symbolTable<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
      <span class="token operator">:</span> <span class="token punctuation">(</span>symbolTable<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createSymbol</span><span class="token punctuation">(</span>SymbolFlags<span class="token punctuation">.</span>None<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">&amp;&amp;</span> includes <span class="token operator">&amp;</span> SymbolFlags<span class="token punctuation">.</span>Classifiable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      classifiableNames<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">symbol</span><span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> excludes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>name<span class="token punctuation">.</span>parent <span class="token operator">=</span> node<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 报告每个重复声明的错误位置</span>
      <span class="token comment">// 报告之前遇到的声明错误</span>
      <span class="token keyword">let</span> message <span class="token operator">=</span>
        <span class="token builtin">symbol</span><span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> SymbolFlags<span class="token punctuation">.</span>BlockScopedVariable
          <span class="token operator">?</span> Diagnostics<span class="token punctuation">.</span>Cannot_redeclare_block_scoped_variable_0
          <span class="token operator">:</span> Diagnostics<span class="token punctuation">.</span>Duplicate_identifier_0<span class="token punctuation">;</span>
      <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token builtin">symbol</span><span class="token punctuation">.</span>declarations<span class="token punctuation">,</span> declaration <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        file<span class="token punctuation">.</span>bindDiagnostics<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>
          <span class="token function">createDiagnosticForNode</span><span class="token punctuation">(</span>declaration<span class="token punctuation">.</span>name <span class="token operator">||</span> declaration<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span>declaration<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      file<span class="token punctuation">.</span>bindDiagnostics<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">createDiagnosticForNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>name <span class="token operator">||</span> node<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">createSymbol</span><span class="token punctuation">(</span>SymbolFlags<span class="token punctuation">.</span>None<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">createSymbol</span><span class="token punctuation">(</span>SymbolFlags<span class="token punctuation">.</span>None<span class="token punctuation">,</span> <span class="token string">&#39;__missing&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">addDeclarationToSymbol</span><span class="token punctuation">(</span><span class="token builtin">symbol</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> includes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin">symbol</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token builtin">symbol</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>填充哪个符号表，由此函数的第一个参数决定。例如：添加声明到类型为 <code>SyntaxKind.ClassDeclaration</code> 或 <code>SyntaxKind.ClassExpression</code> 的容器时，将会调用下面的函数 <code>declareClassMember</code>:</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">declareClassMember</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Declaration<span class="token punctuation">,</span> symbolFlags<span class="token operator">:</span> SymbolFlags<span class="token punctuation">,</span> symbolExcludes<span class="token operator">:</span> SymbolFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> node<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> NodeFlags<span class="token punctuation">.</span>Static
    <span class="token operator">?</span> <span class="token function">declareSymbol</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token builtin">symbol</span><span class="token punctuation">.</span>exports<span class="token punctuation">,</span> container<span class="token punctuation">.</span><span class="token builtin">symbol</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> symbolFlags<span class="token punctuation">,</span> symbolExcludes<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">declareSymbol</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token builtin">symbol</span><span class="token punctuation">.</span>members<span class="token punctuation">,</span> container<span class="token punctuation">.</span><span class="token builtin">symbol</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> symbolFlags<span class="token punctuation">,</span> symbolExcludes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="绑定器错误报告"><a class="header-anchor" href="#绑定器错误报告" aria-hidden="true">#</a> 绑定器错误报告</h4><p>绑定错误被添加到源文件的 <code>bindDiagnostics</code> 列表中</p><p>一个绑定时错误检测的例子是在严格模式下使用 <code>eval</code> 或 <code>arguments</code> 作为变量名。下面展示了相关的全部代码（多个位置都会调用<code>checkStrictModeEvalOrArguments</code>，调用栈发自 <code>bindWorker</code>，该函数对不同节点的 <code>SyntaxKind</code> 调用不同的检查函数）：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">checkStrictModeEvalOrArguments</span><span class="token punctuation">(</span>contextNode<span class="token operator">:</span> Node<span class="token punctuation">,</span> name<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">&amp;&amp;</span> name<span class="token punctuation">.</span>kind <span class="token operator">===</span> SyntaxKind<span class="token punctuation">.</span>Identifier<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> identifier <span class="token operator">=</span> <span class="token operator">&lt;</span>Identifier<span class="token operator">&gt;</span>name<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEvalOrArgumentsIdentifier</span><span class="token punctuation">(</span>identifier<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 首先检查名字是否在类声明或者类表达式中，如果是则给出明确消息，否则报告一般性错误</span>
      <span class="token keyword">let</span> span <span class="token operator">=</span> <span class="token function">getErrorSpanForNode</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      file<span class="token punctuation">.</span>bindDiagnostics<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>
        <span class="token function">createFileDiagnostic</span><span class="token punctuation">(</span>
          file<span class="token punctuation">,</span>
          span<span class="token punctuation">.</span>start<span class="token punctuation">,</span>
          span<span class="token punctuation">.</span>length<span class="token punctuation">,</span>
          <span class="token function">getStrictModeEvalOrArgumentsMessage</span><span class="token punctuation">(</span>contextNode<span class="token punctuation">)</span><span class="token punctuation">,</span>
          identifier<span class="token punctuation">.</span>text
        <span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isEvalOrArgumentsIdentifier</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    node<span class="token punctuation">.</span>kind <span class="token operator">===</span> SyntaxKind<span class="token punctuation">.</span>Identifier <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Identifier<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>text <span class="token operator">===</span> <span class="token string">&#39;eval&#39;</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>Identifier<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>text <span class="token operator">===</span> <span class="token string">&#39;arguments&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getStrictModeEvalOrArgumentsMessage</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 向用户提供特定消息，有助他们理解为何会处于严格模式。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getContainingClass</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Diagnostics<span class="token punctuation">.</span>Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span>externalModuleIndicator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Diagnostics<span class="token punctuation">.</span>Invalid_use_of_0_Modules_are_automatically_in_strict_mode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> Diagnostics<span class="token punctuation">.</span>Invalid_use_of_0_in_strict_mode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="检查器"><a class="header-anchor" href="#检查器" aria-hidden="true">#</a> 检查器</h3><p>如前所述，<strong>检查器</strong>使得 TypeScript 更独特，比<strong>其它 JavaScript 转译器</strong>更强大。检查器位于 <code>checker.ts</code> 中，当前有 23k 行以上的代码（编译器中最大的部分）</p><h4 id="程序对检查器的使用"><a class="header-anchor" href="#程序对检查器的使用" aria-hidden="true">#</a> 程序对检查器的使用</h4><p>检查器是由程序初始化，下面是调用栈示意（绑定器一节也展示过）：</p><div class="language-shell"><pre><code>program.getTypeChecker -<span class="token operator">&gt;</span>
  ts.createTypeChecker（检查器中）-<span class="token operator">&gt;</span>
    initializeTypeChecker（检查器中） -<span class="token operator">&gt;</span>
      <span class="token keyword">for</span> each SourceFile <span class="token variable"><span class="token variable">`</span>ts.bindSourceFile<span class="token variable">`</span></span>（绑定器中）
      // 接着
      <span class="token keyword">for</span> each SourceFile <span class="token variable"><span class="token variable">`</span>ts.mergeSymbolTable<span class="token variable">`</span></span>（检查器中）
</code></pre></div><h4 id="与发射器的联系"><a class="header-anchor" href="#与发射器的联系" aria-hidden="true">#</a> 与发射器的联系</h4><p>真正的类型检查会在调用 getDiagnostics 时才发生。该函数被调用时（比如由 Program.emit 请求），检查器返回一个 EmitResolver（由程序调用检查器的 getEmitResolver 函数得到），EmitResolver 是 createTypeChecker 的一个本地函数的集合。介绍发射器时还会再次提到。</p><p>下面是该过程直到 checkSourceFile 的调用栈（checkSourceFile 是 createTypeChecker 的一个本地函数）：</p><div class="language-shell"><pre><code>program.emit -<span class="token operator">&gt;</span>
  emitWorker <span class="token punctuation">(</span>program <span class="token builtin class-name">local</span><span class="token punctuation">)</span> -<span class="token operator">&gt;</span>
    createTypeChecker.getEmitResolver -<span class="token operator">&gt;</span>
      // 第一次调用下面的几个 createTypeChecker 的本地函数
      call getDiagnostics -<span class="token operator">&gt;</span>
          getDiagnosticsWorker -<span class="token operator">&gt;</span>
              checkSourceFile

      // 接着
      <span class="token builtin class-name">return</span> resolver
      // 通过对本地函数 createResolver<span class="token punctuation">(</span><span class="token punctuation">)</span> 的调用，resolver 已在 createTypeChecker 中初始化。
</code></pre></div><h4 id="全局命名空间合并"><a class="header-anchor" href="#全局命名空间合并" aria-hidden="true">#</a> 全局命名空间合并</h4><p><code>initializeTypeChecker</code> 中存在以下代码：</p><div class="language-ts"><pre><code><span class="token comment">// 初始化全局符号表（SymbolTable）。</span>
<span class="token function">forEach</span><span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">getSourceFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> file <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isExternalModule</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mergeSymbolTable</span><span class="token punctuation">(</span>globals<span class="token punctuation">,</span> file<span class="token punctuation">.</span>locals<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>基本上是将所有的 <code>global</code> 符号合并到 <code>let globals: SymbolTable = {}</code> 符号表中（位于 <code>createTypeChecker</code> 中）。 <code>mergeSymbolTable</code> 主要调用 <code>mergeSymbol</code> 函数。</p><h4 id="检查器错误报告"><a class="header-anchor" href="#检查器错误报告" aria-hidden="true">#</a> 检查器错误报告</h4><p>检查器使用本地的 <code>error</code> 函数报告错误，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">error</span><span class="token punctuation">(</span>location<span class="token operator">:</span> Node<span class="token punctuation">,</span> message<span class="token operator">:</span> DiagnosticMessage<span class="token punctuation">,</span> arg0<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> arg1<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> arg2<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> diagnostic <span class="token operator">=</span> location
    <span class="token operator">?</span> <span class="token function">createDiagnosticForNode</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> message<span class="token punctuation">,</span> arg0<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">createCompilerDiagnostic</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> arg0<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  diagnostics<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>diagnostic<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="发射器"><a class="header-anchor" href="#发射器" aria-hidden="true">#</a> 发射器</h3><p>TypeScript 编译器提供了两个发射器：</p><ul><li><code>emitter.ts</code>：可能是你最感兴趣的发射器，它是 TS -&gt; JavaScript 的发射器</li><li><code>declarationEmitter.ts</code>：这个发射器用于为 <strong>TypeScript 源文件（<code>.ts</code>）</strong> 创建<strong>声明文件（<code>.d.ts</code>）</strong></li></ul><p>本节我们介绍 <code>emitter.ts</code></p><h4 id="promgram-对发射器的作用"><a class="header-anchor" href="#promgram-对发射器的作用" aria-hidden="true">#</a> Promgram 对发射器的作用</h4><p>Program 提供了一个 <code>emit</code> 函数。该函数主要将功能委托给 <code>emitter.ts</code> 中的 <code>emitFiles</code> 函数。下面是调用栈：</p><div class="language-shell"><pre><code>Program.emit -<span class="token operator">&gt;</span>
  <span class="token variable"><span class="token variable">`</span>emitWorker<span class="token variable">`</span></span> （在 program.ts 中的 createProgram） -<span class="token operator">&gt;</span>
    <span class="token variable"><span class="token variable">`</span>emitFiles<span class="token variable">`</span></span> （emitter.ts 中的函数）
</code></pre></div><p><code>emitWorker</code>（通过 <code>emitFiles</code> 参数）给发射器提供一个 <code>EmitResolver</code>。 <code>EmitResolver</code> 由程序的 <code>TypeChecker</code> 提供，基本上它是一个来自 createChecker 的本地函数的子集。</p><h4 id="发射器函数"><a class="header-anchor" href="#发射器函数" aria-hidden="true">#</a> 发射器函数</h4><h5 id="emitfiles"><a class="header-anchor" href="#emitfiles" aria-hidden="true">#</a> <code>emitFiles</code></h5><p>定义在 <code>emitter.ts</code> 中，下面是该函数的签名：</p><div class="language-ts"><pre><code><span class="token comment">// targetSourceFile 当用户想发射项目中的某个文件时指定，保存时编译（compileOnSave）功能使用此参数</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">emitFiles</span><span class="token punctuation">(</span>resolver<span class="token operator">:</span> EmitResolver<span class="token punctuation">,</span> host<span class="token operator">:</span> EmitHost<span class="token punctuation">,</span> targetSourceFile<span class="token operator">?</span><span class="token operator">:</span> SourceFile<span class="token punctuation">)</span><span class="token operator">:</span> EmitResult <span class="token punctuation">{</span>
</code></pre></div><p><code>EmitHost</code> 是 <code>CompilerHost</code> 的简化版（运行时，很多用例实际上都是 <code>CompilerHost</code>）</p><p><code>emitFiles</code> 中的最有趣的调用栈如下所示：</p><div class="language-shell"><pre><code>emitFiles -<span class="token operator">&gt;</span>
  emitFile<span class="token punctuation">(</span>jsFilePath, targetSourceFile<span class="token punctuation">)</span> -<span class="token operator">&gt;</span>
    emitJavaScript<span class="token punctuation">(</span>jsFilePath, targetSourceFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="emitjavascript"><a class="header-anchor" href="#emitjavascript" aria-hidden="true">#</a> <code>emitJavaScript</code></h5><p>该函数有良好的注释，我们下面给出它：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">emitJavaScript</span><span class="token punctuation">(</span>jsFilePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> root<span class="token operator">?</span><span class="token operator">:</span> SourceFile<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> writer <span class="token operator">=</span> <span class="token function">createTextWriter</span><span class="token punctuation">(</span>newLine<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> write <span class="token operator">=</span> writer<span class="token punctuation">.</span>write<span class="token punctuation">;</span>
  <span class="token keyword">let</span> writeTextOfNode <span class="token operator">=</span> writer<span class="token punctuation">.</span>writeTextOfNode<span class="token punctuation">;</span>
  <span class="token keyword">let</span> writeLine <span class="token operator">=</span> writer<span class="token punctuation">.</span>writeLine<span class="token punctuation">;</span>
  <span class="token keyword">let</span> increaseIndent <span class="token operator">=</span> writer<span class="token punctuation">.</span>increaseIndent<span class="token punctuation">;</span>
  <span class="token keyword">let</span> decreaseIndent <span class="token operator">=</span> writer<span class="token punctuation">.</span>decreaseIndent<span class="token punctuation">;</span>

  <span class="token keyword">let</span> currentSourceFile<span class="token operator">:</span> SourceFile<span class="token punctuation">;</span>
  <span class="token comment">// 导出器函数的名称，如果文件是个系统外部模块的话</span>
  <span class="token comment">// System.register([...], function (&lt;exporter&gt;) {...})</span>
  <span class="token comment">// System 模块中的导出像这样：</span>
  <span class="token comment">// export var x; ... x = 1</span>
  <span class="token comment">// =&gt;</span>
  <span class="token comment">// var x;... exporter(&quot;x&quot;, x = 1)</span>
  <span class="token keyword">let</span> exportFunctionForFile<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> generatedNameSet<span class="token operator">:</span> Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> nodeToGeneratedName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> computedPropertyNamesToGeneratedNames<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> extendsEmitted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> decorateEmitted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> paramEmitted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> awaiterEmitted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> tempFlags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> tempVariables<span class="token operator">:</span> Identifier<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> tempParameters<span class="token operator">:</span> Identifier<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> externalImports<span class="token operator">:</span> <span class="token punctuation">(</span>ImportDeclaration <span class="token operator">|</span> ImportEqualsDeclaration <span class="token operator">|</span> ExportDeclaration<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> exportSpecifiers<span class="token operator">:</span> Map<span class="token operator">&lt;</span>ExportSpecifier<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> exportEquals<span class="token operator">:</span> ExportAssignment<span class="token punctuation">;</span>
  <span class="token keyword">let</span> hasExportStars<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

  <span class="token comment">/** 将发射输出写入磁盘 */</span>
  <span class="token keyword">let</span> writeEmittedFiles <span class="token operator">=</span> writeJavaScriptFile<span class="token punctuation">;</span>

  <span class="token keyword">let</span> detachedCommentsInfo<span class="token operator">:</span> <span class="token punctuation">{</span> nodePos<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> detachedCommentEndPos<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> writeComment <span class="token operator">=</span> writeCommentRange<span class="token punctuation">;</span>

  <span class="token comment">/** 发射一个节点 */</span>
  <span class="token keyword">let</span> emit <span class="token operator">=</span> emitNodeWithoutSourceMap<span class="token punctuation">;</span>

  <span class="token comment">/** 在发射节点前调用 */</span>
  <span class="token keyword">let</span> <span class="token function-variable function">emitStart</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">/** 发射结点完成后调用 */</span>
  <span class="token keyword">let</span> <span class="token function-variable function">emitEnd</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">/** 从 startPos 位置开始，为指定的 token 发射文本。默认写入的文本由 tokenKind 提供，
   * 但是如果提供了可选的 emitFn 回调，将使用该回调来代替默认方式发射文本。
   * @param tokenKind 要搜索并发射的 token 的类别
   * @param startPos 源码中搜索 token 的起始位置
   * @param emitFn 如果给出，会被调用来进行文本的发射。
   */</span>
  <span class="token keyword">let</span> emitToken <span class="token operator">=</span> emitTokenText<span class="token punctuation">;</span>

  <span class="token comment">/** 该函数由于节点的缘故，在被发射的代码中的函数或类中，会在启用词法作用域前被调用
   * @param scopeDeclaration 启动词法作用域的节点
   * @param scopeName 可选的作用域的名称，默认从节点声明中推导
   */</span>
  <span class="token keyword">let</span> <span class="token function-variable function">scopeEmitStart</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>scopeDeclaration<span class="token operator">:</span> Node<span class="token punctuation">,</span> scopeName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">/** 出了作用域后调用 */</span>
  <span class="token keyword">let</span> <span class="token function-variable function">scopeEmitEnd</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">/** 会被编码的 Sourcemap 数据 */</span>
  <span class="token keyword">let</span> sourceMapData<span class="token operator">:</span> SourceMapData<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>compilerOptions<span class="token punctuation">.</span>sourceMap <span class="token operator">||</span> compilerOptions<span class="token punctuation">.</span>inlineSourceMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initializeEmitterWithSourceMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不要直接调用 emit，那样不会设置 currentSourceFile</span>
    <span class="token function">emitSourceFile</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">forEach</span><span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">getSourceFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sourceFile <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isExternalModuleOrDeclarationFile</span><span class="token punctuation">(</span>sourceFile<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">emitSourceFile</span><span class="token punctuation">(</span>sourceFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">writeLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">writeEmittedFiles</span><span class="token punctuation">(</span>writer<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">/*writeByteOrderMark*/</span> compilerOptions<span class="token punctuation">.</span>emitBOM<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token comment">/// 一批本地函数</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它主要设置了一批本地变量和函数（这些函数构成 <code>emitter.ts</code> 的大部分内容），接着交给本地函数 <code>emitSourceFile</code> 发射文本。<code>emitSourceFile</code> 函数设置 <code>currentSourceFile</code> 然后交给本地函数 <code>emit</code> 去处理。</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">emitSourceFile</span><span class="token punctuation">(</span>sourceFile<span class="token operator">:</span> SourceFile<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  currentSourceFile <span class="token operator">=</span> sourceFile<span class="token punctuation">;</span>
  exportFunctionForFile <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
  <span class="token function">emit</span><span class="token punctuation">(</span>sourceFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>emit</code> 函数处理 <strong>注释</strong> 和 <strong>实际 JavaScript</strong> 的发射。<strong>实际 JavaScript</strong> 的发射是 emitJavaScriptWorker 函数的工作。</p><h5 id="emitjavascriptworker"><a class="header-anchor" href="#emitjavascriptworker" aria-hidden="true">#</a> <code>emitJavaScriptWorker</code></h5><p>完整的函数：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">emitJavaScriptWorker</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 检查节点是否可以忽略 ScriptTarget 发射</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>Identifier<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitIdentifier</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Identifier<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>Parameter<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitParameter</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ParameterDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>MethodDeclaration<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>MethodSignature<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitMethod</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MethodDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>GetAccessor<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>SetAccessor<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitAccessor</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>AccessorDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ThisKeyword<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitThis</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>SuperKeyword<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitSuper</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>NullKeyword<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&#39;null&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TrueKeyword<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&#39;true&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>FalseKeyword<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&#39;false&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>NumericLiteral<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>StringLiteral<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>RegularExpressionLiteral<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>NoSubstitutionTemplateLiteral<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TemplateHead<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TemplateMiddle<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TemplateTail<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitLiteral</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>LiteralExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TemplateExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitTemplateExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>TemplateExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TemplateSpan<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitTemplateSpan</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>TemplateSpan<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>JsxElement<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>JsxSelfClosingElement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitJsxElement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>JsxElement <span class="token operator">|</span> JsxSelfClosingElement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>JsxText<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitJsxText</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>JsxText<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>JsxExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitJsxExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>JsxExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>QualifiedName<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitQualifiedName</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>QualifiedName<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ObjectBindingPattern<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitObjectBindingPattern</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>BindingPattern<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ArrayBindingPattern<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitArrayBindingPattern</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>BindingPattern<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>BindingElement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitBindingElement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>BindingElement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ArrayLiteralExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitArrayLiteral</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ArrayLiteralExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ObjectLiteralExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitObjectLiteral</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ObjectLiteralExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>PropertyAssignment<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitPropertyAssignment</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>PropertyDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ShorthandPropertyAssignment<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitShorthandPropertyAssignment</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ShorthandPropertyAssignment<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ComputedPropertyName<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitComputedPropertyName</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ComputedPropertyName<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>PropertyAccessExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitPropertyAccess</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>PropertyAccessExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ElementAccessExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitIndexedAccess</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ElementAccessExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>CallExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitCallExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>CallExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>NewExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitNewExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>NewExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TaggedTemplateExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitTaggedTemplateExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>TaggedTemplateExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TypeAssertionExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>TypeAssertion<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>AsExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>AsExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ParenthesizedExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitParenExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ParenthesizedExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>FunctionDeclaration<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>FunctionExpression<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ArrowFunction<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitFunctionDeclaration</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>FunctionLikeDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>DeleteExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitDeleteExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>DeleteExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TypeOfExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitTypeOfExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>TypeOfExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>VoidExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitVoidExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VoidExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>AwaitExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitAwaitExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>AwaitExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>PrefixUnaryExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitPrefixUnaryExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>PrefixUnaryExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>PostfixUnaryExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitPostfixUnaryExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>PostfixUnaryExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>BinaryExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitBinaryExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>BinaryExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ConditionalExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitConditionalExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ConditionalExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>SpreadElementExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitSpreadElementExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>SpreadElementExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>YieldExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitYieldExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>YieldExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>OmittedExpression<span class="token operator">:</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>Block<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ModuleBlock<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitBlock</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Block<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>VariableStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitVariableStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VariableStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>EmptyStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&#39;;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ExpressionStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitExpressionStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ExpressionStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>IfStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitIfStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>IfStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>DoStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitDoStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>DoStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>WhileStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitWhileStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>WhileStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ForStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitForStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ForStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ForOfStatement<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ForInStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitForInOrForOfStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ForInStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ContinueStatement<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>BreakStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitBreakOrContinueStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>BreakOrContinueStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ReturnStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitReturnStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ReturnStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>WithStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitWithStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>WithStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>SwitchStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitSwitchStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>SwitchStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>CaseClause<span class="token operator">:</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>DefaultClause<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitCaseOrDefaultClause</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>CaseOrDefaultClause<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>LabeledStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitLabelledStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>LabeledStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ThrowStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitThrowStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ThrowStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>TryStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitTryStatement</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>TryStatement<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>CatchClause<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitCatchClause</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>CatchClause<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>DebuggerStatement<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitDebuggerStatement</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>VariableDeclaration<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitVariableDeclaration</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VariableDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ClassExpression<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitClassExpression</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ClassExpression<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ClassDeclaration<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitClassDeclaration</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ClassDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>InterfaceDeclaration<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitInterfaceDeclaration</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>InterfaceDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>EnumDeclaration<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitEnumDeclaration</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>EnumDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>EnumMember<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitEnumMember</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>EnumMember<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ModuleDeclaration<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitModuleDeclaration</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ModuleDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ImportDeclaration<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitImportDeclaration</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ImportDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ImportEqualsDeclaration<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitImportEqualsDeclaration</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ImportEqualsDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ExportDeclaration<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitExportDeclaration</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ExportDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>ExportAssignment<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitExportAssignment</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>ExportAssignment<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> SyntaxKind<span class="token punctuation">.</span>SourceFile<span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token function">emitSourceFileNode</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>SourceFile<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过简单地调用相应的 <code>emitXXX</code> 函数来完成递归，例如 <code>emitFunctionDeclaration</code></p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">emitFunctionDeclaration</span><span class="token punctuation">(</span>node<span class="token operator">:</span> FunctionLikeDeclaration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">nodeIsMissing</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">emitOnlyPinnedOrTripleSlashComments</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>kind <span class="token operator">!==</span> SyntaxKind<span class="token punctuation">.</span>MethodDeclaration <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>kind <span class="token operator">!==</span> SyntaxKind<span class="token punctuation">.</span>MethodSignature<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 会把注释当做方法声明的一部分去发射。</span>
    <span class="token function">emitLeadingComments</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 目标为 es6 之前时，使用 function 关键字来发射类函数（functions-like）声明，包括箭头函数</span>
  <span class="token comment">// 目标为 es6 时，可以发射原生的 ES6 箭头函数，并使用宽箭头代替 function 关键字.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">shouldEmitAsArrowFunction</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isES6ExportedDeclaration</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&#39;export &#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span> NodeFlags<span class="token punctuation">.</span>Default<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&#39;default &#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>languageVersion <span class="token operator">&gt;=</span> ScriptTarget<span class="token punctuation">.</span><span class="token constant">ES6</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>asteriskToken<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&#39;*&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&#39; &#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldEmitFunctionName</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emitDeclarationName</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">emitSignatureAndBody</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    languageVersion <span class="token operator">&lt;</span> ScriptTarget<span class="token punctuation">.</span><span class="token constant">ES6</span> <span class="token operator">&amp;&amp;</span>
    node<span class="token punctuation">.</span>kind <span class="token operator">===</span> SyntaxKind<span class="token punctuation">.</span>FunctionDeclaration <span class="token operator">&amp;&amp;</span>
    node<span class="token punctuation">.</span>parent <span class="token operator">===</span> currentSourceFile <span class="token operator">&amp;&amp;</span>
    node<span class="token punctuation">.</span>name
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emitExportMemberAssignments</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>FunctionDeclaration<span class="token operator">&gt;</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>kind <span class="token operator">!==</span> SyntaxKind<span class="token punctuation">.</span>MethodDeclaration <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>kind <span class="token operator">!==</span> SyntaxKind<span class="token punctuation">.</span>MethodSignature<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emitTrailingComments</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="发射器源映射（sourcemaps）"><a class="header-anchor" href="#发射器源映射（sourcemaps）" aria-hidden="true">#</a> 发射器源映射（SourceMaps）</h4><p>如前所述 <code>emitter.ts</code> 中的大部分代码是函数 <code>emitJavaScript</code>（我们之前展示过该函数的初始化例程）。 它主要是设置一批本地变量并交给 <code>emitSourceFile</code> 处理。下面我们再看一遍这个函数，这次我们重点关注 <code>SourceMap</code> 的部分：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">emitJavaScript</span><span class="token punctuation">(</span>jsFilePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> root<span class="token operator">?</span><span class="token operator">:</span> SourceFile<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 无关代码 ........... 已移除</span>
    <span class="token keyword">let</span> writeComment <span class="token operator">=</span> writeCommentRange<span class="token punctuation">;</span>

    <span class="token comment">/** 将发射的输出写到磁盘上 */</span>
    <span class="token keyword">let</span> writeEmittedFiles <span class="token operator">=</span> writeJavaScriptFile<span class="token punctuation">;</span>

    <span class="token comment">/** 发射一个节点 */</span>
    <span class="token keyword">let</span> emit <span class="token operator">=</span> emitNodeWithoutSourceMap<span class="token punctuation">;</span>

    <span class="token comment">/** 节点发射前调用 */</span>
    <span class="token keyword">let</span> <span class="token function-variable function">emitStart</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/** 节点发射完成后调用 */</span>
    <span class="token keyword">let</span> <span class="token function-variable function">emitEnd</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/** 从 startPos 位置开始，为指定的 token 发射文本。默认写入的文本由 tokenKind 提供，
      * 但是如果提供了可选的 emitFn 回调，将使用该回调来代替默认方式发射文本。
      * @param tokenKind 要搜索并发射的 token 的类别
      * @param startPos 源码中搜索 token 的起始位置
      * @param emitFn 如果给出，会被调用来进行文本的发射。*/</span>
    <span class="token keyword">let</span> emitToken <span class="token operator">=</span> emitTokenText<span class="token punctuation">;</span>

    <span class="token comment">/** 该函数因为节点，会在发射的代码中于函数或类中启用词法作用域前调用
      * @param scopeDeclaration 启动词法作用域的节点
      * @param scopeName 可选的作用域的名称，而不是从节点声明中推导
      */</span>
    <span class="token keyword">let</span> <span class="token function-variable function">scopeEmitStart</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>scopeDeclaration<span class="token operator">:</span> Node<span class="token punctuation">,</span> scopeName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/** 出了作用域后调用 */</span>
    <span class="token keyword">let</span> <span class="token function-variable function">scopeEmitEnd</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/** 会被编码的 Sourcemap 数据 */</span>
    <span class="token keyword">let</span> sourceMapData<span class="token operator">:</span> SourceMapData<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>compilerOptions<span class="token punctuation">.</span>sourceMap <span class="token operator">||</span> compilerOptions<span class="token punctuation">.</span>inlineSourceMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">initializeEmitterWithSourceMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不要直接调用 emit，那样不会设置 currentSourceFile</span>
        <span class="token function">emitSourceFile</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">forEach</span><span class="token punctuation">(</span>host<span class="token punctuation">.</span><span class="token function">getSourceFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sourceFile <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isExternalModuleOrDeclarationFile</span><span class="token punctuation">(</span>sourceFile<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">emitSourceFile</span><span class="token punctuation">(</span>sourceFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">writeLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">writeEmittedFiles</span><span class="token punctuation">(</span>writer<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">/*writeByteOrderMark*/</span> compilerOptions<span class="token punctuation">.</span>emitBOM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
</code></pre></div><p>重要的函数调用： <code>initializeEmitterWithSourceMaps</code>，该函数是 <code>emitJavaScript</code> 的本地函数，它覆盖了部分已定义的本地函数。 覆盖的函数可以在 <code>initalizeEmitterWithSourceMap</code> 的底部找到：</p><div class="language-ts"><pre><code><span class="token comment">// `initializeEmitterWithSourceMaps` 函数的最后部分</span>

writeEmittedFiles <span class="token operator">=</span> writeJavaScriptAndSourceMapFile<span class="token punctuation">;</span>
emit <span class="token operator">=</span> emitNodeWithSourceMap<span class="token punctuation">;</span>
emitStart <span class="token operator">=</span> recordEmitNodeStartSpan<span class="token punctuation">;</span>
emitEnd <span class="token operator">=</span> recordEmitNodeEndSpan<span class="token punctuation">;</span>
emitToken <span class="token operator">=</span> writeTextWithSpanRecord<span class="token punctuation">;</span>
scopeEmitStart <span class="token operator">=</span> recordScopeNameOfNode<span class="token punctuation">;</span>
scopeEmitEnd <span class="token operator">=</span> recordScopeNameEnd<span class="token punctuation">;</span>
writeComment <span class="token operator">=</span> writeCommentRangeWithMap<span class="token punctuation">;</span>
</code></pre></div><p>就是说大部分的发射器代码不关心 <code>SourceMap</code>，它们以相同的方式使用这些（带或不带 SourceMap 的）本地函数。</p><p><cite><a href="https://jkchao.github.io/typescript-book-chinese/project/compilationContext.html#tsconfig-json" target="_blank" rel="noopener noreferrer">-- 《深入理解 TypeScript》</a></cite></p></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><a class="link" href="https://github.com/QiYoe/c-blog/edit/master/docs/books/typescript-deep-dive.md" target="_blank" rel="noopener noreferrer" data-v-1ed99556>在 GitHub 上编辑此页 <svg class="icon outbound icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-1ed99556><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="updated" data-v-fb8d84c6><p class="last-updated" data-v-fb8d84c6 data-v-5797b537><span class="prefix" data-v-5797b537>最新更新时间:</span><span class="datetime" data-v-5797b537></span></p></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/books/typescript-tutorial" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>TypeScript入门教程</span></a></div><div class="next" data-v-38ede35f><a class="link" href="/books/css-tricks" data-v-38ede35f><span class="text" data-v-38ede35f>CSS揭秘</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"554ba45a\",\"algorithm_index.md\":\"876aa1e3\",\"algorithm_leetcode.md\":\"7925acfc\",\"algorithm_lodash.md\":\"86312aac\",\"books_css-tricks.md\":\"5f3245d5\",\"books_docker-practice.md\":\"9b0ca3a5\",\"books_everything-curl.md\":\"c2f4d906\",\"books_grokking-algorithms.md\":\"5707d126\",\"books_index.md\":\"ad619d1d\",\"books_js-advice.md\":\"b43524bf\",\"books_pro-git.md\":\"ff25185a\",\"books_typescript-deep-dive.md\":\"7d536d5b\",\"books_typescript-tutorial.md\":\"77e199a4\",\"books_you-dont-know-js.md\":\"84344102\",\"devops_index.md\":\"3648c819\",\"devops_jira.md\":\"d66173e9\",\"front-end_index.md\":\"970b33ef\",\"other_30-seconds-of-code.md\":\"0e9722f2\",\"other_computer-tech.md\":\"346e0051\",\"other_index.md\":\"5999a065\",\"other_smart-tools.md\":\"ada4b3e0\",\"other_vanillawebprojects.md\":\"22a5ab03\",\"quotations_index.md\":\"40ff770a\",\"front-end_ast_index.md\":\"4835bfd0\",\"front-end_ast_the-super-tiny-compiler.md\":\"db32d291\",\"front-end_blog-build_aliyun-domin.md\":\"a15d9ca7\",\"front-end_blog-build_baidu-include.md\":\"df6b829b\",\"front-end_blog-build_index.md\":\"7648f957\",\"front-end_blog-build_seo-optimize.md\":\"aea73f77\",\"front-end_css_index.md\":\"8fc6e613\",\"front-end_css_sass.md\":\"544a0075\",\"front-end_css_tailwind.md\":\"f0a8c225\",\"front-end_git_advance.md\":\"8fdb1416\",\"front-end_git_flight-rules.md\":\"0b359c31\",\"front-end_git_index.md\":\"cd841a29\",\"front-end_linux_docker.md\":\"dde1878f\",\"front-end_linux_index.md\":\"1a25d7ca\",\"front-end_linux_jenkins.md\":\"b5161e38\",\"front-end_linux_kubernetes.md\":\"a4ef83f8\",\"front-end_linux_nginx.md\":\"45629853\",\"front-end_swagger-hub_curl.md\":\"3ac65eee\",\"front-end_swagger-hub_index.md\":\"aad2a966\",\"front-end_vue_axios.md\":\"d2c640bc\",\"front-end_vue_index.md\":\"0f10915d\",\"front-end_vue_nuxt.md\":\"5a50a4a2\",\"front-end_vue_typescript.md\":\"cba89df3\",\"front-end_vue_vite.md\":\"9fdb008e\",\"front-end_vue_vue-router.md\":\"34af5d2b\",\"front-end_web-container_index.md\":\"b014402d\",\"front-end_websocket_index.md\":\"0df162ba\"}")</script>
    <script type="module" async src="/assets/app.e09fd7d1.js"></script>
  </body>
</html>