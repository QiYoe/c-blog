<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入理解 TypeScript | 南上康青山</title>
    <meta name="description" content="TypeScript 深入理解 TS">
    <link rel="stylesheet" href="/assets/style.a1cb9c64.css">
    <link rel="modulepreload" href="/assets/Home.410dd335.js">
    <link rel="modulepreload" href="/assets/app.d9b5a45a.js">
    <link rel="modulepreload" href="/assets/books_typescript-deep-dive.md.b63b7849.lean.js">
    <link rel="modulepreload" href="/assets/app.d9b5a45a.js">
    <link rel="image/x-icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="keywords" content="南上康青山, vitepress, 顾青山, blog, 博客, 狗窝, 青山">
    <meta name="baidu-site-verification" content="code-5BMDhSDgSq">
    <meta name="baidu_union_verify" content="acd0eb90461e19817cabd1140c8ffd54">
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1801e4a45f1eecdfe603fc0637120c56";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);

      // 引入谷歌,不需要可删除这段
      var hm1 = document.createElement("script");
      hm1.src = "https://www.googletagmanager.com/gtag/js?id=G-SBNLNM3Q41";
      var s1 = document.getElementsByTagName("script")[0]; 
      s1.parentNode.insertBefore(hm1, s1);
    })();

    // 谷歌加载,不需要可删除
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-SBNLNM3Q41');
  </script>
    <script type="async" src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
    <meta name="keywords" content="TypeScript 深入理解 TS">
    <meta name="twitter:title" content="深入理解 TypeScript | 南上康青山">
    <meta property="og:title" content="深入理解 TypeScript | 南上康青山">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="南上康青山, back to home" data-v-675d8756 data-v-4a583abe><!----> 南上康青山</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="前端" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>前端</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/blog-build/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>博客相关</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/swagger-hub/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>SwaggerHub</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/linux/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Linux相关</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/vue/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vue</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/ast/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>AST</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/css/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>CSS</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/git/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Git</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/websocket/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>WebSocket</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/web-container/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>WebContainer</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="书籍" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>书籍</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/you-dont-know-js" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>你不知道的JavaScript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/js-advice" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>JavaScript深入系列</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/typescript-tutorial" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>TypeScript入门教程</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/books/typescript-deep-dive" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>深入理解TypeScript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/css-tricks" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>CSS揭秘</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/grokking-algorithms" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>算法图解</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/pro-git" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Pro-Git</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/docker-practice" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Docker-从入门到实践</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/everything-curl" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Everything Curl</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="算法" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>算法</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithm/leetcode" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>LeetCode</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithm/lodash" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Lodash</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="DevOps" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>DevOps</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/devops/jira" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Jira</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="其他" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>其他</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/smart-tools" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Markdown</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/computer-tech" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>计算机基础知识</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/30-seconds-of-code" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>30 seconds of code</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/vanillawebprojects" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>vanillawebprojects</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/quotations/" aria-label="摘抄语录" data-v-b8818f8c>摘抄语录 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item isExternal" href="https://github.com/QiYoe/c-blog" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="前端" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>前端</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/blog-build/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>博客相关</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/swagger-hub/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>SwaggerHub</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/linux/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Linux相关</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/vue/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vue</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/ast/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>AST</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/css/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>CSS</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/git/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Git</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/websocket/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>WebSocket</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/front-end/web-container/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>WebContainer</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="书籍" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>书籍</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/you-dont-know-js" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>你不知道的JavaScript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/js-advice" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>JavaScript深入系列</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/typescript-tutorial" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>TypeScript入门教程</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/books/typescript-deep-dive" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>深入理解TypeScript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/css-tricks" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>CSS揭秘</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/grokking-algorithms" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>算法图解</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/pro-git" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Pro-Git</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/docker-practice" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Docker-从入门到实践</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/books/everything-curl" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Everything Curl</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="算法" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>算法</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithm/leetcode" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>LeetCode</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithm/lodash" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Lodash</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="DevOps" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>DevOps</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/devops/jira" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Jira</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-56bf3a3f><button class="button" aria-label="其他" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>其他</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/smart-tools" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Markdown</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/computer-tech" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>计算机基础知识</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/30-seconds-of-code" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>30 seconds of code</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/other/vanillawebprojects" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>vanillawebprojects</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/quotations/" aria-label="摘抄语录" data-v-b8818f8c>摘抄语录 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item isExternal" href="https://github.com/QiYoe/c-blog" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><p class="sidebar-link-item">书籍</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/books/you-dont-know-js">你不知道的JavaScript</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/js-advice">JavaScript深入系列</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/typescript-tutorial">TypeScript入门教程</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/books/typescript-deep-dive">深入理解TypeScript</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript-项目">TypeScript 项目</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#编译上下文">编译上下文</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#声明空间">声明空间</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#模块">模块</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#命名空间">命名空间</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#动态导入表达式">动态导入表达式</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript-类型系统">TypeScript 类型系统</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#概览">概览</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#从javascript-迁移">从JavaScript 迁移</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#types">@types</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#环境声明">环境声明</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#接口-1">接口</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#枚举">枚举</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#lib-d-ts">lib.d.ts</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#函数">函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#可调用的">可调用的</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型断言">类型断言</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#freshness">Freshness</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型保护">类型保护</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#字面量类型">字面量类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#readonly">readonly</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#范型-1">范型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型推断">类型推断</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型兼容性">类型兼容性</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#never">Never</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#辨析联合类型">辨析联合类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#索引签名">索引签名</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#流动的类型">流动的类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#异常处理">异常处理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#混合">混合</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#thistype">ThisType</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#jsx">JSX</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#支持-jsx">支持 JSX</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#react-jsx">React JSX</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#非-react-jsx">非 React JSX</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript-错误提示">TypeScript 错误提示</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#解读-errors">解读 Errors</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#常见的-error">常见的 Error</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tips">TIPs</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#基于字符串的枚举">基于字符串的枚举</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#名义化类型">名义化类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#状态函数">状态函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#bind-是有害的">Bind 是有害的</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#柯里化">柯里化</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#范型的实例化类型">范型的实例化类型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#对象字面量的惰性初始化">对象字面量的惰性初始化</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类是有用的">类是有用的</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#export-default-被认为是有害的">export default 被认为是有害的</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#减少-setter-属性的使用">减少 setter 属性的使用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#创建数组">创建数组</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#谨慎使用-outfile">谨慎使用 --outFile</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript-中的静态构造函数">TypeScript 中的静态构造函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#单例模式">单例模式</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#函数参数">函数参数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#truthy">Truthy</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#构建切换">构建切换</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型安全的-event-emitter">类型安全的 Event Emitter</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-metadata">Reflect Metadata</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#协变与逆变">协变与逆变</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#infer">infer</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript-编译原理">TypeScript 编译原理</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#概览-1">概览</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#程序">程序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#抽象语法树">抽象语法树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#扫描器">扫描器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#解析器">解析器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#绑定器">绑定器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#检查器">检查器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#发射器">发射器</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#typescript-faqs">TypeScript FAQs</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#一些常见的「bug」并不是-bug">一些常见的「bug」并不是 bug</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#一些常见的-feature-需求">一些常见的 Feature 需求</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型系统的行为">类型系统的行为</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#函数-1">函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类">类</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#范型-2">范型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#模块-1">模块</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#枚举-1">枚举</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类型守卫">类型守卫</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#jsx-和-react">JSX 和 React</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#一些不能按预期工作的代码">一些不能按预期工作的代码</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#命令行的行为">命令行的行为</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tsconfig-json-的行为">tsconfig.json 的行为</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/css-tricks">CSS揭秘</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/grokking-algorithms">算法图解</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/pro-git">Pro-Git</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/docker-practice">Docker-从入门到实践</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/books/everything-curl">Everything Curl</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h2 id="typescript-项目"><a class="header-anchor" href="#typescript-项目" aria-hidden="true">#</a> TypeScript 项目</h2><h3 id="编译上下文"><a class="header-anchor" href="#编译上下文" aria-hidden="true">#</a> 编译上下文</h3><p>编译上下文算是一个比较花哨的术语，可以用它来给文件分组，告诉 TypeScript 哪些文件是有效的，哪些是无效的。除了有效文件所携带信息外，编译上下文还包含有正在被使用的编译选项的信息。定义这种逻辑分组，一个比较好的方式是使用 <code>tsconfig.json</code> 文件。</p><h4 id="tsconfig-json"><a class="header-anchor" href="#tsconfig-json" aria-hidden="true">#</a> tsconfig.json</h4><h5 id="基础"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h5><p>开始使用 <code>tsconfig.json</code> 是一件比较容易的事，你仅仅需要写下：</p><div class="language-json"><pre><code><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>例如，在项目的根目录下创建一个空 JSON 文件。通过这种方式，TypeScript 将 会把此目录和子目录下的所有 .ts 文件作为编译上下文的一部分，它还会包含一部分默认的编译选项。</p><h5 id="编译选项"><a class="header-anchor" href="#编译选项" aria-hidden="true">#</a> 编译选项</h5><p>你可以通过 <code>compilerOptions</code> 来定制你的编译选项：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>

    <span class="token comment">/* 基本选项 */</span>
    <span class="token property">&quot;target&quot;</span><span class="token operator">:</span> <span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 指定 ECMAScript 目标版本: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES6&#39;/&#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, or &#39;ESNEXT&#39;</span>
    <span class="token property">&quot;module&quot;</span><span class="token operator">:</span> <span class="token string">&quot;commonjs&quot;</span><span class="token punctuation">,</span>                  <span class="token comment">// 指定使用模块: &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39; or &#39;es2015&#39;</span>
    <span class="token property">&quot;lib&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                             <span class="token comment">// 指定要包含在编译中的库文件</span>
    <span class="token property">&quot;allowJs&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                       <span class="token comment">// 允许编译 javascript 文件</span>
    <span class="token property">&quot;checkJs&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                       <span class="token comment">// 报告 javascript 文件中的错误</span>
    <span class="token property">&quot;jsx&quot;</span><span class="token operator">:</span> <span class="token string">&quot;preserve&quot;</span><span class="token punctuation">,</span>                     <span class="token comment">// 指定 jsx 代码的生成: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39;</span>
    <span class="token property">&quot;declaration&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                   <span class="token comment">// 生成相应的 &#39;.d.ts&#39; 文件</span>
    <span class="token property">&quot;sourceMap&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                     <span class="token comment">// 生成相应的 &#39;.map&#39; 文件</span>
    <span class="token property">&quot;outFile&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 将输出文件合并为一个文件</span>
    <span class="token property">&quot;outDir&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                        <span class="token comment">// 指定输出目录</span>
    <span class="token property">&quot;rootDir&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 用来控制输出目录结构 --outDir.</span>
    <span class="token property">&quot;removeComments&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                <span class="token comment">// 删除编译后的所有的注释</span>
    <span class="token property">&quot;noEmit&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        <span class="token comment">// 不生成输出文件</span>
    <span class="token property">&quot;importHelpers&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 <span class="token comment">// 从 tslib 导入辅助工具函数</span>
    <span class="token property">&quot;isolatedModules&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>               <span class="token comment">// 将每个文件作为单独的模块 （与 &#39;ts.transpileModule&#39; 类似）.</span>

    <span class="token comment">/* 严格的类型检查选项 */</span>
    <span class="token property">&quot;strict&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        <span class="token comment">// 启用所有严格类型检查选项</span>
    <span class="token property">&quot;noImplicitAny&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 <span class="token comment">// 在表达式和声明上有隐含的 any类型时报错</span>
    <span class="token property">&quot;strictNullChecks&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>              <span class="token comment">// 启用严格的 null 检查</span>
    <span class="token property">&quot;noImplicitThis&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                <span class="token comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span>
    <span class="token property">&quot;alwaysStrict&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                  <span class="token comment">// 以严格模式检查每个模块，并在每个文件里加入 &#39;use strict&#39;</span>

    <span class="token comment">/* 额外的检查 */</span>
    <span class="token property">&quot;noUnusedLocals&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                <span class="token comment">// 有未使用的变量时，抛出错误</span>
    <span class="token property">&quot;noUnusedParameters&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token comment">// 有未使用的参数时，抛出错误</span>
    <span class="token property">&quot;noImplicitReturns&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>             <span class="token comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span>
    <span class="token property">&quot;noFallthroughCasesInSwitch&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span>

    <span class="token comment">/* 模块解析选项 */</span>
    <span class="token property">&quot;moduleResolution&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span>            <span class="token comment">// 选择模块解析策略： &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6)</span>
    <span class="token property">&quot;baseUrl&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 用于解析非相对模块名称的基目录</span>
    <span class="token property">&quot;paths&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                           <span class="token comment">// 模块名到基于 baseUrl 的路径映射的列表</span>
    <span class="token property">&quot;rootDirs&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                        <span class="token comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span>
    <span class="token property">&quot;typeRoots&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                       <span class="token comment">// 包含类型声明的文件列表</span>
    <span class="token property">&quot;types&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                           <span class="token comment">// 需要包含的类型声明文件名列表</span>
    <span class="token property">&quot;allowSyntheticDefaultImports&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment">// 允许从没有设置默认导出的模块中默认导入。</span>

    <span class="token comment">/* Source Map Options */</span>
    <span class="token property">&quot;sourceRoot&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                    <span class="token comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span>
    <span class="token property">&quot;mapRoot&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span>
    <span class="token property">&quot;inlineSourceMap&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>               <span class="token comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span>
    <span class="token property">&quot;inlineSources&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 <span class="token comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span>

    <span class="token comment">/* 其他选项 */</span>
    <span class="token property">&quot;experimentalDecorators&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token comment">// 启用装饰器</span>
    <span class="token property">&quot;emitDecoratorMetadata&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>          <span class="token comment">// 为装饰器提供元数据的支持</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>关于这些（或者更多）编译选项，稍后将会讨论。</p><h5 id="typescript-编译"><a class="header-anchor" href="#typescript-编译" aria-hidden="true">#</a> TypeScript 编译</h5><p>好的 IDE 支持对 TypeScript 的即时编译。但是，如果你想在使用 <code>tsconfig.json</code> 时从命令行手动运行 TypeScript 编译器，你可以通过以下方式：</p><p>运行 tsc，它会在当前目录或者是父级目录寻找 <code>tsconfig.json</code> 文件。 运行 <code>tsc -p ./path-to-project-directory</code> 。当然，这个路径可以是绝对路径，也可以是相对于当前目录的相对路径。 你甚至可以使用 <code>tsc -w</code> 来启用 TypeScript 编译器的观测模式，在检测到文件改动之后，它将重新编译。</p><h4 id="制定文件"><a class="header-anchor" href="#制定文件" aria-hidden="true">#</a> 制定文件</h4><p>你也可以显式指定需要编译的文件：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
  <span class="token property">&quot;files&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;./some/file.ts&quot;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你还可以使用 <code>include</code> 和 <code>exclude</code> 选项来指定需要包含的文件和排除的文件：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
  <span class="token property">&quot;include&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;./folder&quot;</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">&quot;exclude&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;./folder/**/*.spec.ts&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;./folder/someSubFolder&quot;</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>使用 <code>globs</code>：<code>**/*</code> （一个示例用法：<code>some/folder/**/*</code>）意味着匹配所有的文件夹和所有文件（扩展名为 <code>.ts/.tsx</code>，当开启了 <code>allowJs: true</code> 选项时，扩展名可以是 <code>.js/.jsx</code>）。</p></div><h3 id="声明空间"><a class="header-anchor" href="#声明空间" aria-hidden="true">#</a> 声明空间</h3><p>在 TypeScript 里存在两种声明空间：类型声明空间与变量声明空间。下文将分别讨论这两个概念。</p><h4 id="类型声明空间"><a class="header-anchor" href="#类型声明空间" aria-hidden="true">#</a> 类型声明空间</h4><p>类型声明空间包含用来当做类型注解的内容，例如下面的类型声明：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Bas</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>你可以将 <code>Foo</code>, <code>Bar</code>, <code>Bas</code> 作为类型注解使用，示例如下：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Bas</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，尽管你定义了 interface Bar，却并不能够把它作为一个变量来使用，因为它没有定义在变量声明空间中。</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> Bar<span class="token punctuation">;</span> <span class="token comment">// Error: &quot;cannot find name &#39;Bar&#39;&quot;</span>
</code></pre></div><p>出现错误提示： <code>cannot find name &#39;Bar&#39;</code> 的原因是名称 <code>Bar</code> 并未定义在变量声明空间。这将带领我们进入下一个主题 -- 变量声明空间。</p><h4 id="变量声明空间"><a class="header-anchor" href="#变量声明空间" aria-hidden="true">#</a> 变量声明空间</h4><p>变量声明空间包含可用作变量的内容，在上文中 <code>Class Foo</code> 提供了一个类型 <code>Foo</code> 到类型声明空间，此外它同样提供了一个变量 Foo 到变量声明空间，如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> someVar <span class="token operator">=</span> Foo<span class="token punctuation">;</span>
<span class="token keyword">const</span> someOtherVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre></div><p>这很棒，尤其是当你想把一个类来当做变量传递时。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>我们并不能把一些如 <code>interface</code> 定义的内容当作变量使用。</p></div><p>与此相似，一些用 <code>var</code> 声明的变量，也只能在变量声明空间使用，不能用作类型注解。</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> foo<span class="token punctuation">;</span> <span class="token comment">// ERROR: &quot;cannot find name &#39;foo&#39;&quot;</span>
</code></pre></div><p>提示 <code>ERROR: &quot;cannot find name &#39;foo&#39;&quot;</code> 原因是，名称 foo 没有定义在类型声明空间里。</p><h3 id="模块"><a class="header-anchor" href="#模块" aria-hidden="true">#</a> 模块</h3><h4 id="全局模块"><a class="header-anchor" href="#全局模块" aria-hidden="true">#</a> 全局模块</h4><p>在默认情况下，当你开始在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中。如在 foo.ts 里的以下代码。</p><div class="language-ts"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre></div><p>如果你在相同的项目里创建了一个新的文件 bar.ts，TypeScript 类型系统将会允许你使用变量 foo，就好像它在全局可用一样：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// allowed</span>
</code></pre></div><p>毋庸置疑，使用全局变量空间是危险的，因为它会与文件内的代码命名冲突。我们推荐使用下文中将要提到的文件模块。</p><h4 id="文件模块"><a class="header-anchor" href="#文件模块" aria-hidden="true">#</a> 文件模块</h4><p>文件模块也被称为外部模块。如果在你的 TypeScript 文件的根级别位置含有 <code>import</code> 或者 <code>export</code>，那么它会在这个文件中创建一个本地的作用域。因此，我们需要把上文 <code>foo.ts</code> 改成如下方式（注意 <code>export</code> 用法）：</p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre></div><p>在全局命名空间里，我们不再有 <code>foo</code>，这可以通过创建一个新文件 <code>bar.ts</code> 来证明：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// ERROR: &quot;cannot find name &#39;foo&#39;&quot;</span>
</code></pre></div><p>如果你想在 <code>bar.ts</code> 里使用来自 <code>foo.ts</code> 的内容，你必须显式地导入它，更新后的 <code>bar.ts</code> 如下所示。</p><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// allow</span>
</code></pre></div><p>在 <code>bar.ts</code> 文件里使用 <code>import</code> 时，它不仅允许你使用从其他文件导入的内容，还会将此文件 <code>bar.ts</code> 标记为一个模块，文件内定义的声明也不会“污染”全局命名空间</p><h4 id="文件模块详情"><a class="header-anchor" href="#文件模块详情" aria-hidden="true">#</a> 文件模块详情</h4><p>文件模块拥有强大的功能和较强的可用性。下面我们来讨论它的功能及一些用法。</p><h5 id="澄清-commonjs-amd-esmodules-others"><a class="header-anchor" href="#澄清-commonjs-amd-esmodules-others" aria-hidden="true">#</a> 澄清: commonjs, amd, esmodules, others</h5><p>首先，我们需要澄清这些模块系统的不一致性。我将会提供给你我当前的建议，以及消除一些你的顾虑。</p><p>你可以根据不同的 <code>module</code> 选项来把 TypeScript 编译成不同的 JavaScript 模块类型，这有一些你可以忽略的东西：</p><ul><li>AMD：不要使用它，它仅能在浏览器工作；</li><li>SystemJS：这是一个好的实验，已经被 ES 模块替代；</li><li>ES 模块：它并没有准备好。</li></ul><p>使用 <code>module: commonjs</code> 选项来替代这些模式，将会是一个好的主意。</p><p>怎么书写 TypeScript 模块呢？，这也是一件让人困惑的事。在今天我们应该这么做：</p><ul><li>放弃使用 <code>import/require</code> 语法即 <code>import foo = require(&#39;foo&#39;)</code> 写法</li><li>推荐使用 ES 模块语法</li></ul><p>这很酷，接下来，让我们看看 ES 模块语法。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>使用 <code>module: commonjs</code> 选项以及使用 ES 模块语法导入、导出、编写模块。</p></div><h5 id="es-模块语法"><a class="header-anchor" href="#es-模块语法" aria-hidden="true">#</a> ES 模块语法</h5><ul><li>使用 <code>export</code> 关键字导出一个变量或类型</li></ul><div class="language-ts"><pre><code><span class="token comment">// foo.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> someVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">someType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>export</code> 的写法除了上面这种，还有另外一种：</li></ul><div class="language-ts"><pre><code><span class="token comment">// foo.ts</span>
<span class="token keyword">const</span> someVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">someType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span> someVar<span class="token punctuation">,</span> someType <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>你也可以用重命名变量的方式导出：</li></ul><div class="language-ts"><pre><code><span class="token comment">// foo.ts</span>
<span class="token keyword">const</span> someVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> someVar <span class="token keyword">as</span> aDifferentName <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>使用 <code>import</code> 关键字导入一个变量或者是一个类型：</li></ul><div class="language-ts"><pre><code><span class="token comment">// bar.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> someVar<span class="token punctuation">,</span> someType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通过重命名的方式导入变量或者类型：</li></ul><div class="language-ts"><pre><code><span class="token comment">// bar.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> someVar <span class="token keyword">as</span> aDifferentName <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面：</li></ul><div class="language-ts"><pre><code><span class="token comment">// bar.ts</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> foo <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
<span class="token comment">// 你可以使用 `foo.someVar` 和 `foo.someType` 以及其他任何从 `foo` 导出的变量或者类型</span>
</code></pre></div><ul><li>只导入模块：</li></ul><div class="language-ts"><pre><code><span class="token keyword">import</span> <span class="token string">&#39;core-js&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 一个普通的 polyfill 库</span>
</code></pre></div><ul><li>从其他模块导入后整体导出：</li></ul><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>从其他模块导入后，部分导出：</li></ul><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token punctuation">{</span> someVar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>通过重命名，部分导出从另一个模块导入的项目：</li></ul><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token punctuation">{</span> someVar <span class="token keyword">as</span> aDifferentName <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h6 id="默认导入／导出"><a class="header-anchor" href="#默认导入／导出" aria-hidden="true">#</a> 默认导入／导出</h6><p>我并不喜欢用默认导出，虽然有默认导出的语法：</p><ul><li>使用 export default <ul><li>在一个变量之前（不需要使用 let/const/var）；</li><li>在一个函数之前；</li><li>在一个类之前。</li></ul></li></ul><div class="language-ts"><pre><code><span class="token comment">// some var</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span>someVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// some function</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// some class</span>
<span class="token class-name"><span class="token keyword">export</span></span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">someClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><ul><li>导入使用 <code>import someName from &#39;someModule&#39;</code> 语法（你可以根据需要为导入命名）：</li></ul><div class="language-ts"><pre><code><span class="token keyword">import</span> someLocalNameForThisFile <span class="token keyword">from</span> <span class="token string">&#39;./foo&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="模块路径"><a class="header-anchor" href="#模块路径" aria-hidden="true">#</a> 模块路径</h5><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果你需要使用 <code>moduleResolution: node</code> 选项，你应该将此选项放入你的配置文件中。如果你使用了 <code>module: commonjs</code> 选项， <code>moduleResolution: node</code> 将会默认开启。</p></div><p>这里存在两种截然不同的模块：</p><ul><li>相对模块路径（路径以 <code>.</code> 开头，例如：<code>./someFile</code> 或者 <code>../../someFolder/someFile</code> 等）；</li><li>其他动态查找模块（如：<code>core-js</code>，<code>typestyle</code>，<code>react</code> 或者甚至是 <code>react/core</code> 等）。</li></ul><p>它们的主要区别在于系统如何解析模块。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>我将会使用一个概念性术语，<code>place</code> -- 将在提及查找模式后解释它。</p></div><h6 id="相对模块路径"><a class="header-anchor" href="#相对模块路径" aria-hidden="true">#</a> 相对模块路径</h6><p>这很简单，仅仅是按照相对路径来就可以了：</p><ul><li>如果文件 <code>bar.ts</code> 中含有 <code>import * as foo from &#39;./foo&#39;</code>，那么 <code>foo</code> 文件必须与 <code>bar.ts</code> 文件存在于相同的文件夹下</li><li>如果文件 <code>bar.ts</code> 中含有 <code>import * as foo from &#39;../foo&#39;</code>，那么 <code>foo</code> 文件所存在的地方必须是 <code>bar.ts</code> 的上一级目录；</li><li>如果文件 <code>bar.ts</code> 中含有 <code>import * as foo from &#39;../someFolder/foo&#39;</code>，那么 <code>foo</code> 文件所在的文件夹 someFolder 必须与 <code>bar.ts</code> 文件所在文件夹在相同的目录下。</li></ul><p>你还可以思考一下其他相对路径导入的场景。😃</p><h6 id="动态查找"><a class="header-anchor" href="#动态查找" aria-hidden="true">#</a> 动态查找</h6><p>当导入路径不是相对路径时，模块解析将会模仿 <a href="https://nodejs.org/api/modules.html#modules_all_together" target="_blank" rel="noopener noreferrer">Node 模块解析策略</a>，下面我将给出一个简单例子：</p><ul><li>当你使用 <code>import * as foo from &#39;foo&#39;</code>，将会按如下顺序查找模块： <ul><li><code>./node_modules/foo</code></li><li><code>../node_modules/foo</code></li><li><code>../../node_modules/foo</code></li><li>直到系统的根目录</li></ul></li><li>当你使用 <code>import * as foo from &#39;something/foo&#39;</code>，将会按照如下顺序查找内容 <ul><li><code>./node_modules/something/foo</code></li><li><code>../node_modules/something/foo</code></li><li><code>../../node_modules/something/foo</code></li><li>直到系统的根目录</li></ul></li></ul><h5 id="什么是-place"><a class="header-anchor" href="#什么是-place" aria-hidden="true">#</a> 什么是 <code>place</code></h5><p>当我提及被检查的 <code>place</code> 时，我想表达的是在这个 <code>place</code> 上，TypeScript 将会检查以下内容（例如一个 <code>foo</code> 的 <code>place</code>）：</p><ul><li>如果这个 <code>place</code> 表示一个文件，如：<code>foo.ts</code>，欢呼！</li><li>否则，如果这个 <code>place</code> 是一个文件夹，并且存在一个文件 <code>foo/index.ts</code>，欢呼！</li><li>否则，如果这个 <code>place</code> 是一个文件夹，并且存在一个 <code>foo/package.json</code> 文件，在该文件中指定 <code>types</code> 的文件存在，那么就欢呼！</li><li>否则，如果这个 <code>place</code> 是一个文件夹，并且存在一个 <code>package.json</code> 文件，在该文件中指定 <code>main</code> 的文件存在，那么就欢呼！</li></ul><p>从文件类型上来说，我实际上是指 <code>.ts</code>， <code>.d.ts</code> 或者 <code>.js</code></p><p>就是这样，现在你已经是一个模块查找专家（这并不是一个小小的成功）。</p><h5 id="重写类型的动态查找"><a class="header-anchor" href="#重写类型的动态查找" aria-hidden="true">#</a> 重写类型的动态查找</h5><p>在你的项目里，你可以通过 <code>declare module &#39;somePath&#39;</code> 声明一个全局模块的方式，来解决查找模块路径的问题。</p><div class="language-ts"><pre><code><span class="token comment">// global.d.ts</span>
<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&#39;foo&#39;</span> <span class="token punctuation">{</span>
  <span class="token comment">// some variable declarations</span>
  <span class="token keyword">export</span> <span class="token keyword">var</span> bar<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接着 ：</p><div class="language-ts"><pre><code><span class="token comment">// anyOtherTsFileInYourProject.ts</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> foo <span class="token keyword">from</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>
<span class="token comment">// TypeScript 将假设（在没有做其他查找的情况下）</span>
<span class="token comment">// foo 是 { bar: number }</span>
</code></pre></div><h5 id="import-require-仅仅是导入类型"><a class="header-anchor" href="#import-require-仅仅是导入类型" aria-hidden="true">#</a> import/require 仅仅是导入类型</h5><p>以下导入语法：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>它实际上只做了两件事：</p><ul><li>导入 foo 模块的所有类型信息；</li><li>确定 foo 模块运行时的依赖关系。</li></ul><p>你可以选择仅加载类型信息，而没有运行时的依赖关系。在继续之前，你可能需要重新阅读本书 <a href="#%E5%A3%B0%E6%98%8E%E7%A9%BA%E9%97%B4">声明空间部分</a>。</p><p>如果你没有把导入的名称当做变量声明空间来用，在编译成 JavaScript 时，导入的模块将会被完全移除。这最好用例子来解释，下面我们将会给出一些示例。</p><h6 id="例子-1"><a class="header-anchor" href="#例子-1" aria-hidden="true">#</a> 例子 1</h6><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>将会编译成 JavaScript：</p><div class="language-js"><pre><code></code></pre></div><p>这是正确的，一个没有被使用的空文件。</p><h6 id="例子-2"><a class="header-anchor" href="#例子-2" aria-hidden="true">#</a> 例子 2</h6><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar<span class="token operator">:</span> foo<span class="token punctuation">;</span>
</code></pre></div><p>将会被编译成：</p><div class="language-js"><pre><code><span class="token keyword">let</span> bar<span class="token punctuation">;</span>
</code></pre></div><p>这是因为 foo （或者其他任何属性如：<code>foo.bas</code>）没有被当做一个变量使用。</p><h6 id="例子-3"><a class="header-anchor" href="#例子-3" aria-hidden="true">#</a> 例子 3</h6><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span>
</code></pre></div><p>将会被编译成（假设是 commonjs）：</p><div class="language-js"><pre><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> foo<span class="token punctuation">;</span>
</code></pre></div><p>这是因为 <code>foo</code> 被当做变量使用了。</p><h6 id="使用例子：懒加载"><a class="header-anchor" href="#使用例子：懒加载" aria-hidden="true">#</a> 使用例子：懒加载</h6><p>类型推断需要提前完成，这意味着，如果你想在 <code>bar</code> 文件里，使用从其他文件 <code>foo</code> 导出的类型，你将不得不这么做：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar<span class="token operator">:</span> foo<span class="token punctuation">.</span>SomeType<span class="token punctuation">;</span>
</code></pre></div><p>然而，在某些情景下，你只想在需要时加载模块 <code>foo</code>，此时你需要仅在类型注解中使用导入的模块名称，而<strong>不</strong>是在变量中使用。在编译成 JavaScript 时，这些将会被移除。接着，你可以手动导入你需要的模块。</p><p>作为一个例子，考虑以下基于 <code>commonjs</code> 的代码，我们仅在一个函数内导入 <code>foo</code> 模块：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">loadFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这是懒加载 foo，原始的加载仅仅用来做类型注解</span>
  <span class="token keyword">const</span> _foo<span class="token operator">:</span> <span class="token keyword">typeof</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 现在，你可以使用 `_foo` 替代 `foo` 来作为一个变量使用</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个同样简单的 <code>amd</code> 模块（使用 requirejs）：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">loadFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这是懒加载 foo，原始的加载仅仅用来做类型注解</span>
  <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>_foo<span class="token operator">:</span> <span class="token keyword">typeof</span> foo<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 现在，你可以使用 `_foo` 替代 `foo` 来作为一个变量使用</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些通常在以下情景使用：</p><ul><li>在 web app 里， 当你在特定路由上加载 JavaScript 时；</li><li>在 node 应用里，当你只想加载特定模块，用来加快启动速度时。</li></ul><h6 id="使用例子：打破循环依赖"><a class="header-anchor" href="#使用例子：打破循环依赖" aria-hidden="true">#</a> 使用例子：打破循环依赖</h6><p>类似于懒加载的使用用例，某些模块加载器（commonjs/node 和 amd/requirejs）不能很好的处理循环依赖。在这种情况下，一方面我们使用延迟加载代码，并在另一方面预先加载模块是很实用的。</p><h6 id="使用例子：确保导入"><a class="header-anchor" href="#使用例子：确保导入" aria-hidden="true">#</a> 使用例子：确保导入</h6><p>当你加载一个模块，只是想引入其附加的作用（如：模块可能会注册一些像 <a href="https://codemirror.net/doc/manual.html#addons" target="_blank" rel="noopener noreferrer">CodeMirror addons</a>）时，然而，如果你仅仅是 <code>import/require</code> （导入）一些并没有与你的模块或者模块加载器有任何依赖的 JavaScript 代码，（如：webpack），经过 TypeScript 编译后，这些将会被完全忽视。在这种情况下，你可以使用一个 <code>ensureImport</code> 变量，来确保编译的 JavaScript 依赖与模块。如：</p><div class="language-ts"><pre><code><span class="token keyword">import</span> foo <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;./foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> bar <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;./bar&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> bas <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">&#39;./bas&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> ensureImport<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> foo <span class="token operator">||</span> bar <span class="token operator">||</span> bas<span class="token punctuation">;</span>
</code></pre></div><h4 id="global-d-ts"><a class="header-anchor" href="#global-d-ts" aria-hidden="true">#</a> global.d.ts</h4><p>在上文中，当我们讨论文件模块时，比较了全局变量与文件模块，并且我们推荐使用基于文件的模块，而不是选择污染全局命名空间。</p><p>然而，如果你的团队里有 TypeScript 初学者，你可以提供他们一个 <code>global.d.ts</code> 文件，用来将一些接口或者类型放入全局命名空间里，这些定义的接口和类型能在你的所有 TypeScript 代码里使用。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>对于任何需要编译成 <code>JavaScript</code> 的代码，我们强烈建议你放入文件模块里。</p></div><ul><li><code>global.d.ts</code> 是一种扩充 <code>lib.d.ts</code> 很好的方式，如果你需要的话。</li><li>当你从 <code>JS</code> 迁移到 <code>TS</code> 时，定义 <code>declare module &quot;some-library-you-dont-care-to-get-defs-for&quot;</code> 能让你快速开始。</li></ul><h3 id="命名空间"><a class="header-anchor" href="#命名空间" aria-hidden="true">#</a> 命名空间</h3><p>在 JavaScript 使用命名空间时， 这有一个常用的、方便的语法：</p><div class="language-js"><pre><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  something<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>something <span class="token operator">||</span> <span class="token punctuation">(</span>something <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>something || (something = {})</code> 允许匿名函数 <code>function (something) {}</code> 向现有对象添加内容，或者创建一个新对象，然后向该对象添加内容。这意味着你可以拥有两个由某些边界拆成的块。</p><div class="language-js"><pre><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  something<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>something <span class="token operator">||</span> <span class="token punctuation">(</span>something <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { foo: 123 }</span>

<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  something<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>something <span class="token operator">||</span> <span class="token punctuation">(</span>something <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { foo: 123, bar: 456 }</span>
</code></pre></div><p>在确保创建的变量不会泄漏至全局命名空间时，这种方式在 JavaScript 中很常见。当基于文件模块使用时，你无须担心这点，但是该模式仍然适用于一组函数的逻辑分组。因此 TypeScript 提供了 <code>namespace</code> 关键字来描述这种分组，如下所示。</p><div class="language-ts"><pre><code><span class="token keyword">namespace</span> Utility <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// usage</span>
Utility<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Call me&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Utility<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&#39;maybe&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>namespace</code> 关键字编译后的 JavaScript 代码，与我们早些时候看到的 JavaScript 代码一样。</p><div class="language-js"><pre><code><span class="token keyword">var</span> Utility<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Utility</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 添加属性至 Utility</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Utility <span class="token operator">||</span> Utility <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>值得注意的一点是，命名空间是支持嵌套的。因此，你可以做一些类似于在 <code>Utility</code> 命名空间下嵌套一个命名空间 <code>Messaging</code> 的事情。</p><p>对于大多数项目，我们建议使用外部模块和命名空间，来快速演示和移植旧的 JavaScript 代码。</p><h3 id="动态导入表达式"><a class="header-anchor" href="#动态导入表达式" aria-hidden="true">#</a> 动态导入表达式</h3><p>动态导入表达式是 ECMAScript 的一个新功能，它允许你在程序的任意位置异步加载一个模块，TC39 JavaScript 委员会有一个提案，目前处于第四阶段，它被称为 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener noreferrer">import() proposal for JavaScript</a>。</p><p>此外，<strong>webpack</strong> bundler 有一个 <code>Code Splitting</code> 功能，它能允许你将代码拆分为许多块，这些块在将来可被异步下载。因此，你可以在程序中首先提供一个最小的程序启动包，并在将来异步加载其他模块。</p><p>这很自然就会让人想到（如果我们工作在 webpack dev 的工作流程中）<a href="https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#dynamic-import-expressions" target="_blank" rel="noopener noreferrer">TypeScript 2.4 dynamic import expressions</a> 将会把你最终生成的 JavaScript 代码自动分割成很多块。但是这似乎并不容易实现，因为它依赖于我们正在使用的 <code>tsconfig.json</code> 配置文件。</p><p>webpack 实现代码分割的方式有两种：使用 <code>import()</code> （首选，ECMAScript 的提案）和 <code>require.ensure()</code> （最后考虑，webpack 具体实现）。因此，我们期望 TypeScript 的输出是保留 <code>import()</code> 语句，而不是将其转化为其他任何代码。</p><p>让我们来看一个例子，在这个例子中，我们演示了如何配置 webpack 和 TypeScript 2.4 +。</p><p>在下面的代码中，我希望懒加载 <code>moment</code> 库，同时我也希望使用代码分割的功能，这意味 <code>moment</code> 会被分割到一个单独的 JavaScript 文件，当它被使用时，会被异步加载。</p><div class="language-ts"><pre><code><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: &quot;momentjs&quot; */</span> <span class="token string">&#39;moment&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>moment <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 懒加载的模块拥有所有的类型，并且能够按期工作</span>
    <span class="token comment">// 类型检查会工作，代码引用也会工作  :100:</span>
    <span class="token keyword">const</span> time <span class="token operator">=</span> <span class="token function">moment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;TypeScript &gt;= 2.4.0 Dynamic Import Expression:&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Failed to load moment&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这是 <code>tsconfig.json</code> 的配置文件：</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;target&quot;</span><span class="token operator">:</span> <span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;module&quot;</span><span class="token operator">:</span> <span class="token string">&quot;esnext&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;lib&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">&quot;dom&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;scripthost&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;es2015.promise&quot;</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">&quot;jsx&quot;</span><span class="token operator">:</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;declaration&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token property">&quot;sourceMap&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">&quot;outDir&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./dist/js&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;strict&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">&quot;moduleResolution&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;typeRoots&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">&quot;./node_modules/@types&quot;</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">&quot;types&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;react&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;react-dom&quot;</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="danger custom-block"><p class="custom-block-title">WARNING</p><ul><li>使用 <code>&quot;module&quot;: &quot;esnext&quot;</code> 选项：TypeScript 保留 <code>import()</code> 语句，该语句用于 Webpack Code Splitting。</li><li>进一步了解有关信息，推荐阅读这篇文章：<a href="https://blog.josequinto.com/2017/06/29/dynamic-import-expressions-and-webpack-code-splitting-integration-with-typescript-2-4/" target="_blank" rel="noopener noreferrer">Dynamic Import Expressions and webpack 2 Code Splitting integration with TypeScript 2.4</a>.</li></ul></div><h2 id="typescript-类型系统"><a class="header-anchor" href="#typescript-类型系统" aria-hidden="true">#</a> TypeScript 类型系统</h2><h3 id="概览"><a class="header-anchor" href="#概览" aria-hidden="true">#</a> 概览</h3><h4 id="typescript-类型系统-1"><a class="header-anchor" href="#typescript-类型系统-1" aria-hidden="true">#</a> TypeScript 类型系统</h4><p>TypeScript 类型系统的主要功能。以下是一些关键点：</p><ul><li>TypeScript 的类型系统被设计为可选的，因此，你的 JavaScript 就是 TypeScript;</li><li>TypeScript 不会阻止 JavaScript 的运行，即使存在类型错误也不例外，这能让你的 JavaScript 逐步迁移至 TypeScript。</li></ul><p>现在让我们开始学习 TypeScript 类型系统的语法吧，在这一章节中，你将能给你的代码加上类型注解，并且能看到它的益处。这将为我们进一步了解类型系统做铺垫。</p><h4 id="基本注解"><a class="header-anchor" href="#基本注解" aria-hidden="true">#</a> 基本注解</h4><p>如前文所提及，类型注解使用 <code>:TypeAnnotation</code> 语法。在类型声明空间中可用的任何内容都可以用作类型注解。</p><p>在下面这个例子中，使用了变量、函数参数以及函数返回值的类型注解：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> num<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">identity</span><span class="token punctuation">(</span>num<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="原始类型"><a class="header-anchor" href="#原始类型" aria-hidden="true">#</a> 原始类型</h4><p>JavaScript 原始类型也同样适应于 TypeScript 的类型系统，因此 <code>string</code>、<code>number</code>、<code>boolean</code> 也可以被用作类型注解：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bool<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
num <span class="token operator">=</span> <span class="token number">123.456</span><span class="token punctuation">;</span>
num <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>

str <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span>
str <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>

bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
bool <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
bool <span class="token operator">=</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><h4 id="数组"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h4><p>TypeScript 为数组提供了专用的类型语法，因此你可以很轻易的注解数组。它使用后缀 <code>[]</code>， 接着你可以根据需要补充任何有效的类型注解（如：<code>:boolean[]</code>）。它能让你安全的使用任何有关数组的操作，而且它也能防止一些类似于赋值错误类型给成员的行为。如下所示：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> boolArray<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

boolArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boolArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boolArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

boolArray<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
boolArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

boolArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
boolArray <span class="token operator">=</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
boolArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><h4 id="接口"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h4><p>接口是 TypeScript 的一个核心知识，它能合并众多类型声明至一个类型声明：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name">Name</span> <span class="token punctuation">{</span>
  first<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  second<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> name<span class="token operator">:</span> Name<span class="token punctuation">;</span>
name <span class="token operator">=</span> <span class="token punctuation">{</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  second<span class="token operator">:</span> <span class="token string">&#39;Doe&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error: &#39;Second is missing&#39;</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error: &#39;Second is the wrong type&#39;</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  second<span class="token operator">:</span> <span class="token number">1337</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在这里，我们把类型注解：<code>first: string</code> + <code>second: string</code> 合并到了一个新的类型注解 <code>Name</code> 里，这样能强制对每个成员进行类型检查。接口在 TypeScript 拥有强大的力量，稍后，我们将会用一个内容专门阐述如何更好的使用它。</p><h4 id="内联类型注解"><a class="header-anchor" href="#内联类型注解" aria-hidden="true">#</a> 内联类型注解</h4><p>与创建一个接口不同，你可以使用内联注解语法注解任何内容：<code>:{ /*Structure*/ }</code>：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token punctuation">{</span>
  first<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  second<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  second<span class="token operator">:</span> <span class="token string">&#39;Doe&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error: &#39;Second is missing&#39;</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error: &#39;Second is the wrong type&#39;</span>
  first<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  second<span class="token operator">:</span> <span class="token number">1337</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>内联类型能为你快速的提供一个类型注解。它可以帮助你省去为类型起名的麻烦（你可能会使用一个很糟糕的名称）。然而，如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 <code>type alias</code>，它会在接下来的部分提到）是一个不错的主意。</p><h4 id="特殊类型"><a class="header-anchor" href="#特殊类型" aria-hidden="true">#</a> 特殊类型</h4><p>除了被提到的一些原始类型，在 TypeScript 中，还存在一些特殊的类型，它们是 <code>any</code>、 <code>null</code>、 <code>undefined</code> 以及 <code>void</code>。</p><h5 id="any"><a class="header-anchor" href="#any" aria-hidden="true">#</a> any</h5><p><code>any</code> 类型在 TypeScript 类型系统中占有特殊的地位。它提供给你一个类型系统的「后门」,TypeScript 将会把类型检查关闭。在类型系统里 <code>any</code> 能够兼容所有的类型（包括它自己）。因此，所有类型都能被赋值给它，它也能被赋值给其他任何类型。以下有一个证明例子：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> power<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>

<span class="token comment">// 赋值任意类型</span>
power <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span>
power <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token comment">// 它也兼容任何类型</span>
<span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
power <span class="token operator">=</span> num<span class="token punctuation">;</span>
num <span class="token operator">=</span> power<span class="token punctuation">;</span>
</code></pre></div><p>当你把 JavaScript 迁移至 TypeScript 时，你将会经常性使用 <code>any</code>。但你必须减少对它的依赖，因为你需要确保类型安全。当使用 <code>any</code> 时，你基本上是在告诉 TypeScript 编译器不要进行任何的类型检查。</p><h5 id="null-和-undefined"><a class="header-anchor" href="#null-和-undefined" aria-hidden="true">#</a> null 和 undefined</h5><p>在类型系统中，JavaScript 中的 null 和 undefined 字面量和其他被标注了 <code>any</code> 类型的变量一样，都能被赋值给任意类型的变量，如下例子所示：</p><div class="language-ts"><pre><code><span class="token comment">// strictNullChecks: false</span>

<span class="token keyword">let</span> num<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

<span class="token comment">// 这些类型能被赋予</span>
num <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
str <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="void"><a class="header-anchor" href="#void" aria-hidden="true">#</a> void</h5><p>使用 <code>:void</code> 来表示一个函数没有一个返回值</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="范型"><a class="header-anchor" href="#范型" aria-hidden="true">#</a> 范型</h4><p>在计算机科学中，许多算法和数据结构并不会依赖于对象的实际类型。但是，你仍然会想在每个变量里强制提供约束。例如：在一个函数中，它接受一个列表，并且返回这个列表的反向排序，这里的约束是指传入至函数的参数与函数的返回值：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">reverse</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>items<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> toreturn <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    toreturn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> toreturn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> sample <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reversed <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>sample<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reversed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3, 2, 1</span>

<span class="token comment">// Safety</span>
reversed<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
reversed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>

reversed<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
reversed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
</code></pre></div><p>在上个例子中，函数 <code>reverse</code> 接受一个类型为 <code>T</code>（注意在 <code>reverse&lt;T&gt;</code> 中的类型参数） 的数组（<code>items: T[]</code>），返回值为类型 <code>T</code> 的一个数组（注意：<code>T[]</code>），函数 <code>reverse</code> 的返回值类型与它接受的参数的类型一样。当你传入 <code>const sample = [1, 2, 3]</code> 时，TypeScript 能推断出 <code>reverse</code> 为 <code>number[]</code> 类型，从而能给你类型安全。与此相似，当你传入一个类型为 <code>string[]</code> 类型的数组时，TypeScript 能推断 <code>reverse</code> 为 <code>string[]</code> 类型，如下例子所示：</p><div class="language-ts"><pre><code><span class="token keyword">const</span> strArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reversedStrs <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>strArr<span class="token punctuation">)</span><span class="token punctuation">;</span>

reversedStrs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>事实上，JavaScript 数组已经拥有了 reverse 的方法，TypeScript 也确实使用了泛型来定义其结构：</p><div class="language-ts"><pre><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>意味着，当你在数组上调用 <code>.reverse</code> 方法时，将会获得类型安全：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> numArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reversedNums <span class="token operator">=</span> numArr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

reversedNums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>当稍后在 <a href="#%E7%8E%AF%E5%A2%83%E5%A3%B0%E6%98%8E">环境声明</a> 章节中提及 <code>lib.d.ts</code> 时，我们会讨论更多关于 <code>Array&lt;T&gt;</code> 的信息。</p><h4 id="联合类型"><a class="header-anchor" href="#联合类型" aria-hidden="true">#</a> 联合类型</h4><p>在 JavaScript 中，你可能希望属性为多种类型之一，如字符串或者数组。这正是 TypeScript 中联合类型能派上用场的地方（它使用 <code>|</code> 作为标记，如 <code>string | number</code>）。关于联合类型，一个常见的用例是一个可以接受字符串数组或单个字符串的函数：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token function">formatCommandline</span><span class="token punctuation">(</span>command<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> line <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> command <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    line <span class="token operator">=</span> command<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    line <span class="token operator">=</span> command<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39; &#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Do stuff with line: string</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="交叉类型"><a class="header-anchor" href="#交叉类型" aria-hidden="true">#</a> 交叉类型</h4><p>在 JavaScript 中， <code>extend</code> 是一种非常常见的模式，在这种模式中，你可以从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。交叉类型可以让你安全的使用此种模式：</p><div class="language-ts"><pre><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">extend</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>first<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> second<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token constant">U</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> id <span class="token keyword">in</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> first<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> id <span class="token keyword">in</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> second<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 现在 x 拥有了 a 属性与 b 属性</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> x<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> x<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
</code></pre></div><h4 id="元组类型"><a class="header-anchor" href="#元组类型" aria-hidden="true">#</a> 元组类型</h4><p>JavaScript 并不支持元组，开发者们通常只能使用数组来表示元组。而 TypeScript 支持它，开发者可以使用 <code>:[typeofmember1, typeofmember2]</code> 的形式，为元组添加类型注解，元组可以包含任意数量的成员，示例：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> nameNumber<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Ok</span>
nameNumber <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;Jenny&#39;</span><span class="token punctuation">,</span> <span class="token number">221345</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Error</span>
nameNumber <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;Jenny&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;221345&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>将其与 TypeScript 中的解构一起使用：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> nameNumber<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
nameNumber <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;Jenny&#39;</span><span class="token punctuation">,</span> <span class="token number">322134</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> num<span class="token punctuation">]</span> <span class="token operator">=</span> nameNumber<span class="token punctuation">;</span>
</code></pre></div><h4 id="类型别名"><a class="header-anchor" href="#类型别名" aria-hidden="true">#</a> 类型别名</h4><p>TypeScript 提供了为类型注解设置别名的便捷语法，你可以使用 <code>type SomeName = someValidTypeAnnotation</code> 来创建别名：</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">StrOrNum</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">let</span> sample<span class="token operator">:</span> StrOrNum<span class="token punctuation">;</span>
sample <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
sample <span class="token operator">=</span> <span class="token string">&#39;123&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 会检查类型</span>
sample <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>与接口不同，你可以为任意的类型注解提供类型别名（在联合类型和交叉类型中比较实用），下面是一些能让你熟悉类型别名语法的示例。</p><div class="language-ts"><pre><code><span class="token keyword">type</span> <span class="token class-name">Text</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">{</span> text<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Coordinates</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Callback</span> <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>如果你需要使用类型注解的层次结构，请使用接口。它能使用 <code>implements</code> 和 <code>extends</code></li><li>为一个简单的对象类型（如上面例子中的 Coordinates）使用类型别名，只需要给它一个语义化的名字即可。另外，当你想给联合类型和交叉类型提供一个语义化的名称时，一个类型别名将会是一个好的选择。</li></ul></div><h4 id="最后"><a class="header-anchor" href="#最后" aria-hidden="true">#</a> 最后</h4><p>现在你已经能够为你的大部分 JavaScript 代码添加类型注解，接着，让我们深入了解 TypeScript 的类型系统吧。</p><h3 id="从javascript-迁移"><a class="header-anchor" href="#从javascript-迁移" aria-hidden="true">#</a> 从JavaScript 迁移</h3><p>首先，假设如下：</p><ul><li>你了解 JavaScript；</li><li>你了解在项目中常用的方式和构建工具（如：webpack）。</li></ul><p>有了以上假设，一般来说，将 JavaScript 代码迁移至 TypeScript 包括以下步骤：</p><ul><li>添加一个 <code>tsconfig.json</code> 文件；</li><li>把文件扩展名从 <code>.js</code> 改成 <code>.ts</code>，开始使用 <code>any</code> 来减少错误；</li><li>开始在 TypeScript 中写代码，尽可能的减少 <code>any</code> 的使用；</li><li>回到旧代码，开始添加类型注解，并修复已识别的错误；</li><li>为第三方 JavaScript 代码定义环境声明。</li></ul><p>让我们进一步讨论其中的几个关键点。</p><p>记住：所有的 JavaScript 代码都是有效的 TypeScript 代码。这意味着，如果让 TypeScript 编译器编译 TypeScript 里的 JavaScript 代码，编译后的结果将会与原始的 JavaScript 代码一模一样。也就是说，把文件扩展名从 <code>.js</code> 改成 <code>.ts</code> 将不会造成任何负面的影响。</p><h4 id="减少错误"><a class="header-anchor" href="#减少错误" aria-hidden="true">#</a> 减少错误</h4><h4 id="第三方代码"><a class="header-anchor" href="#第三方代码" aria-hidden="true">#</a> 第三方代码</h4><h4 id="第三方的-npm-模块"><a class="header-anchor" href="#第三方的-npm-模块" aria-hidden="true">#</a> 第三方的 NPM 模块</h4><h4 id="额外的非-javascript-资源"><a class="header-anchor" href="#额外的非-javascript-资源" aria-hidden="true">#</a> 额外的非 JavaScript 资源</h4><h3 id="types"><a class="header-anchor" href="#types" aria-hidden="true">#</a> @types</h3><h3 id="环境声明"><a class="header-anchor" href="#环境声明" aria-hidden="true">#</a> 环境声明</h3><h3 id="接口-1"><a class="header-anchor" href="#接口-1" aria-hidden="true">#</a> 接口</h3><h3 id="枚举"><a class="header-anchor" href="#枚举" aria-hidden="true">#</a> 枚举</h3><h3 id="lib-d-ts"><a class="header-anchor" href="#lib-d-ts" aria-hidden="true">#</a> lib.d.ts</h3><h3 id="函数"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h3><h3 id="可调用的"><a class="header-anchor" href="#可调用的" aria-hidden="true">#</a> 可调用的</h3><h3 id="类型断言"><a class="header-anchor" href="#类型断言" aria-hidden="true">#</a> 类型断言</h3><h3 id="freshness"><a class="header-anchor" href="#freshness" aria-hidden="true">#</a> Freshness</h3><h3 id="类型保护"><a class="header-anchor" href="#类型保护" aria-hidden="true">#</a> 类型保护</h3><h3 id="字面量类型"><a class="header-anchor" href="#字面量类型" aria-hidden="true">#</a> 字面量类型</h3><h3 id="readonly"><a class="header-anchor" href="#readonly" aria-hidden="true">#</a> readonly</h3><h3 id="范型-1"><a class="header-anchor" href="#范型-1" aria-hidden="true">#</a> 范型</h3><h3 id="类型推断"><a class="header-anchor" href="#类型推断" aria-hidden="true">#</a> 类型推断</h3><h3 id="类型兼容性"><a class="header-anchor" href="#类型兼容性" aria-hidden="true">#</a> 类型兼容性</h3><h3 id="never"><a class="header-anchor" href="#never" aria-hidden="true">#</a> Never</h3><h3 id="辨析联合类型"><a class="header-anchor" href="#辨析联合类型" aria-hidden="true">#</a> 辨析联合类型</h3><h3 id="索引签名"><a class="header-anchor" href="#索引签名" aria-hidden="true">#</a> 索引签名</h3><h3 id="流动的类型"><a class="header-anchor" href="#流动的类型" aria-hidden="true">#</a> 流动的类型</h3><h3 id="异常处理"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h3><h3 id="混合"><a class="header-anchor" href="#混合" aria-hidden="true">#</a> 混合</h3><h3 id="thistype"><a class="header-anchor" href="#thistype" aria-hidden="true">#</a> ThisType</h3><h2 id="jsx"><a class="header-anchor" href="#jsx" aria-hidden="true">#</a> JSX</h2><h3 id="支持-jsx"><a class="header-anchor" href="#支持-jsx" aria-hidden="true">#</a> 支持 JSX</h3><h3 id="react-jsx"><a class="header-anchor" href="#react-jsx" aria-hidden="true">#</a> React JSX</h3><h3 id="非-react-jsx"><a class="header-anchor" href="#非-react-jsx" aria-hidden="true">#</a> 非 React JSX</h3><h2 id="typescript-错误提示"><a class="header-anchor" href="#typescript-错误提示" aria-hidden="true">#</a> TypeScript 错误提示</h2><h3 id="解读-errors"><a class="header-anchor" href="#解读-errors" aria-hidden="true">#</a> 解读 Errors</h3><h3 id="常见的-error"><a class="header-anchor" href="#常见的-error" aria-hidden="true">#</a> 常见的 Error</h3><h2 id="tips"><a class="header-anchor" href="#tips" aria-hidden="true">#</a> TIPs</h2><h3 id="基于字符串的枚举"><a class="header-anchor" href="#基于字符串的枚举" aria-hidden="true">#</a> 基于字符串的枚举</h3><h3 id="名义化类型"><a class="header-anchor" href="#名义化类型" aria-hidden="true">#</a> 名义化类型</h3><h3 id="状态函数"><a class="header-anchor" href="#状态函数" aria-hidden="true">#</a> 状态函数</h3><h3 id="bind-是有害的"><a class="header-anchor" href="#bind-是有害的" aria-hidden="true">#</a> Bind 是有害的</h3><h3 id="柯里化"><a class="header-anchor" href="#柯里化" aria-hidden="true">#</a> 柯里化</h3><h3 id="范型的实例化类型"><a class="header-anchor" href="#范型的实例化类型" aria-hidden="true">#</a> 范型的实例化类型</h3><h3 id="对象字面量的惰性初始化"><a class="header-anchor" href="#对象字面量的惰性初始化" aria-hidden="true">#</a> 对象字面量的惰性初始化</h3><h3 id="类是有用的"><a class="header-anchor" href="#类是有用的" aria-hidden="true">#</a> 类是有用的</h3><h3 id="export-default-被认为是有害的"><a class="header-anchor" href="#export-default-被认为是有害的" aria-hidden="true">#</a> export default 被认为是有害的</h3><h3 id="减少-setter-属性的使用"><a class="header-anchor" href="#减少-setter-属性的使用" aria-hidden="true">#</a> 减少 setter 属性的使用</h3><h3 id="创建数组"><a class="header-anchor" href="#创建数组" aria-hidden="true">#</a> 创建数组</h3><h3 id="谨慎使用-outfile"><a class="header-anchor" href="#谨慎使用-outfile" aria-hidden="true">#</a> 谨慎使用 --outFile</h3><h3 id="typescript-中的静态构造函数"><a class="header-anchor" href="#typescript-中的静态构造函数" aria-hidden="true">#</a> TypeScript 中的静态构造函数</h3><h3 id="单例模式"><a class="header-anchor" href="#单例模式" aria-hidden="true">#</a> 单例模式</h3><h3 id="函数参数"><a class="header-anchor" href="#函数参数" aria-hidden="true">#</a> 函数参数</h3><h3 id="truthy"><a class="header-anchor" href="#truthy" aria-hidden="true">#</a> Truthy</h3><h3 id="构建切换"><a class="header-anchor" href="#构建切换" aria-hidden="true">#</a> 构建切换</h3><h3 id="类型安全的-event-emitter"><a class="header-anchor" href="#类型安全的-event-emitter" aria-hidden="true">#</a> 类型安全的 Event Emitter</h3><h3 id="reflect-metadata"><a class="header-anchor" href="#reflect-metadata" aria-hidden="true">#</a> Reflect Metadata</h3><h3 id="协变与逆变"><a class="header-anchor" href="#协变与逆变" aria-hidden="true">#</a> 协变与逆变</h3><h3 id="infer"><a class="header-anchor" href="#infer" aria-hidden="true">#</a> infer</h3><h2 id="typescript-编译原理"><a class="header-anchor" href="#typescript-编译原理" aria-hidden="true">#</a> TypeScript 编译原理</h2><h3 id="概览-1"><a class="header-anchor" href="#概览-1" aria-hidden="true">#</a> 概览</h3><h3 id="程序"><a class="header-anchor" href="#程序" aria-hidden="true">#</a> 程序</h3><h3 id="抽象语法树"><a class="header-anchor" href="#抽象语法树" aria-hidden="true">#</a> 抽象语法树</h3><h3 id="扫描器"><a class="header-anchor" href="#扫描器" aria-hidden="true">#</a> 扫描器</h3><h3 id="解析器"><a class="header-anchor" href="#解析器" aria-hidden="true">#</a> 解析器</h3><h3 id="绑定器"><a class="header-anchor" href="#绑定器" aria-hidden="true">#</a> 绑定器</h3><h3 id="检查器"><a class="header-anchor" href="#检查器" aria-hidden="true">#</a> 检查器</h3><h3 id="发射器"><a class="header-anchor" href="#发射器" aria-hidden="true">#</a> 发射器</h3><h2 id="typescript-faqs"><a class="header-anchor" href="#typescript-faqs" aria-hidden="true">#</a> TypeScript FAQs</h2><h3 id="一些常见的「bug」并不是-bug"><a class="header-anchor" href="#一些常见的「bug」并不是-bug" aria-hidden="true">#</a> 一些常见的「bug」并不是 bug</h3><h3 id="一些常见的-feature-需求"><a class="header-anchor" href="#一些常见的-feature-需求" aria-hidden="true">#</a> 一些常见的 Feature 需求</h3><h3 id="类型系统的行为"><a class="header-anchor" href="#类型系统的行为" aria-hidden="true">#</a> 类型系统的行为</h3><h3 id="函数-1"><a class="header-anchor" href="#函数-1" aria-hidden="true">#</a> 函数</h3><h3 id="类"><a class="header-anchor" href="#类" aria-hidden="true">#</a> 类</h3><h3 id="范型-2"><a class="header-anchor" href="#范型-2" aria-hidden="true">#</a> 范型</h3><h3 id="模块-1"><a class="header-anchor" href="#模块-1" aria-hidden="true">#</a> 模块</h3><h3 id="枚举-1"><a class="header-anchor" href="#枚举-1" aria-hidden="true">#</a> 枚举</h3><h3 id="类型守卫"><a class="header-anchor" href="#类型守卫" aria-hidden="true">#</a> 类型守卫</h3><h3 id="jsx-和-react"><a class="header-anchor" href="#jsx-和-react" aria-hidden="true">#</a> JSX 和 React</h3><h3 id="一些不能按预期工作的代码"><a class="header-anchor" href="#一些不能按预期工作的代码" aria-hidden="true">#</a> 一些不能按预期工作的代码</h3><h3 id="命令行的行为"><a class="header-anchor" href="#命令行的行为" aria-hidden="true">#</a> 命令行的行为</h3><h3 id="tsconfig-json-的行为"><a class="header-anchor" href="#tsconfig-json-的行为" aria-hidden="true">#</a> tsconfig.json 的行为</h3><p><cite><a href="https://jkchao.github.io/typescript-book-chinese/project/compilationContext.html#tsconfig-json" target="_blank" rel="noopener noreferrer">-- 《深入理解 TypeScript》</a></cite></p></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><a class="link" href="https://github.com/QiYoe/c-blog/edit/master/docs/books/typescript-deep-dive.md" target="_blank" rel="noopener noreferrer" data-v-1ed99556>在 GitHub 上编辑此页 <svg class="icon outbound icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-1ed99556><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="updated" data-v-fb8d84c6><p class="last-updated" data-v-fb8d84c6 data-v-5797b537><span class="prefix" data-v-5797b537>最新更新时间:</span><span class="datetime" data-v-5797b537></span></p></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/books/typescript-tutorial" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>TypeScript入门教程</span></a></div><div class="next" data-v-38ede35f><a class="link" href="/books/css-tricks" data-v-38ede35f><span class="text" data-v-38ede35f>CSS揭秘</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"84125733\",\"algorithm_index.md\":\"bb49b603\",\"algorithm_leetcode.md\":\"4eec5396\",\"algorithm_lodash.md\":\"2676d769\",\"books_css-tricks.md\":\"f36e81d7\",\"books_docker-practice.md\":\"b6b9749b\",\"books_everything-curl.md\":\"c7b87996\",\"books_grokking-algorithms.md\":\"3e2363c3\",\"books_index.md\":\"edb4350e\",\"books_js-advice.md\":\"adb15b16\",\"books_pro-git.md\":\"036aacdb\",\"books_typescript-deep-dive.md\":\"b63b7849\",\"books_typescript-tutorial.md\":\"d719d8cd\",\"books_you-dont-know-js.md\":\"0ae62620\",\"devops_index.md\":\"a0415a9a\",\"devops_jira.md\":\"8f57b1bd\",\"front-end_index.md\":\"6c0e6e03\",\"other_30-seconds-of-code.md\":\"b501bdec\",\"other_computer-tech.md\":\"5101e0d7\",\"other_index.md\":\"291c0e02\",\"other_smart-tools.md\":\"bb6c9c27\",\"other_vanillawebprojects.md\":\"9830ccc8\",\"quotations_index.md\":\"f7a9a772\",\"front-end_ast_index.md\":\"85d6553b\",\"front-end_ast_the-super-tiny-compiler.md\":\"f0cd1bf1\",\"front-end_blog-build_aliyun-domin.md\":\"819b0260\",\"front-end_blog-build_baidu-include.md\":\"91d8369f\",\"front-end_blog-build_index.md\":\"10a8a4f6\",\"front-end_blog-build_seo-optimize.md\":\"c3e31b21\",\"front-end_css_index.md\":\"ef70f9e0\",\"front-end_css_sass.md\":\"63dbdd5f\",\"front-end_css_tailwind.md\":\"6ef1bf4b\",\"front-end_git_advance.md\":\"f999d679\",\"front-end_git_flight-rules.md\":\"633ad856\",\"front-end_git_index.md\":\"f2a66369\",\"front-end_linux_docker.md\":\"beeb9cf6\",\"front-end_linux_index.md\":\"268ea766\",\"front-end_linux_jenkins.md\":\"e100a2eb\",\"front-end_linux_kubernetes.md\":\"27b4a17f\",\"front-end_linux_nginx.md\":\"bb5df541\",\"front-end_swagger-hub_curl.md\":\"9d08e327\",\"front-end_swagger-hub_index.md\":\"86bed527\",\"front-end_vue_axios.md\":\"b8c48e83\",\"front-end_vue_index.md\":\"e70f658d\",\"front-end_vue_nuxt.md\":\"5fb9e19c\",\"front-end_vue_typescript.md\":\"aaae908d\",\"front-end_vue_vite.md\":\"4c9d8749\",\"front-end_vue_vue-router.md\":\"787de4a8\",\"front-end_web-container_index.md\":\"df3101d7\",\"front-end_websocket_index.md\":\"83cdc383\"}")</script>
    <script type="module" async src="/assets/app.d9b5a45a.js"></script>
  </body>
</html>