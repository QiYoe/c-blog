<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Nginx配置详解 | 南上康青山</title>
    <meta name="description" content="Nginx配置详解">
    <link rel="stylesheet" href="/assets/style.021c40aa.css">
    <link rel="modulepreload" href="/assets/Home.686f732e.js">
    <link rel="modulepreload" href="/assets/app.f03f2116.js">
    <link rel="modulepreload" href="/assets/front-end_linux_nginx.md.95e1ef2b.lean.js">
    <link rel="modulepreload" href="/assets/app.f03f2116.js">
    <link rel="image/x-icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="keywords" content="南上康青山, vitepress, 顾青山, blog, 博客, 狗窝, 青山">
    <meta name="baidu-site-verification" content="code-5BMDhSDgSq">
    <meta name="baidu_union_verify" content="acd0eb90461e19817cabd1140c8ffd54">
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1801e4a45f1eecdfe603fc0637120c56";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);

      // 引入谷歌,不需要可删除这段
      var hm1 = document.createElement("script");
      hm1.src = "https://www.googletagmanager.com/gtag/js?id=G-SBNLNM3Q41";
      var s1 = document.getElementsByTagName("script")[0]; 
      s1.parentNode.insertBefore(hm1, s1);
    })();

    // 谷歌加载,不需要可删除
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-SBNLNM3Q41');
  </script>
    <meta name="keywords" content="Linux Ubuntu CentOS Nginx Nginx配置">
    <meta name="twitter:title" content="Nginx配置详解 | 南上康青山">
    <meta property="og:title" content="Nginx配置详解 | 南上康青山">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-7161a24b><div class="sidebar-button" data-v-7161a24b><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="南上康青山, back to home" data-v-7161a24b data-v-4a583abe><!----> 南上康青山</a><div class="flex-grow" data-v-7161a24b></div><div class="nav" data-v-7161a24b><nav class="nav-links" data-v-7161a24b data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-641633f9><a class="item" href="/" data-v-641633f9>首页 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="前端" data-v-90f2c308><span class="button-text" data-v-90f2c308>前端</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/blog-build/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>博客相关</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/swagger-hub/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>SwaggerHub</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item active" href="/front-end/linux/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Linux相关</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/vue/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Vue</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/ast/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>AST</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/git/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Git</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/websocket/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>WebSocket</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/web-container/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>WebContainer</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="书籍" data-v-90f2c308><span class="button-text" data-v-90f2c308>书籍</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/you-dont-know-js" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>你不知道的JavaScript</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/js-advice" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>JavaScript深入系列</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/css-secrets" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>CSS揭秘</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/grokking-algorithms" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>算法图解</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/pro-git" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Pro-Git</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/docker-practice" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Docker-从入门到实践</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="算法" data-v-90f2c308><span class="button-text" data-v-90f2c308>算法</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/algorithm/leetcode" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>LeetCode</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/algorithm/lodash" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Lodash</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="DevOps" data-v-90f2c308><span class="button-text" data-v-90f2c308>DevOps</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/devops/jira" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Jira</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="其他" data-v-90f2c308><span class="button-text" data-v-90f2c308>其他</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/other/smart-tools" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Markdown</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/other/computer-tech" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>计算机基础知识</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/other/30-seconds-of-code" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>30 seconds of code</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/other/vanillawebprojects" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>vanillawebprojects</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-641633f9><a class="item" href="/quotations/" aria-label="摘抄语录" data-v-641633f9>摘抄语录 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-641633f9><a class="item isExternal" href="https://github.com/QiYoe/c-blog" target="_blank" rel="noopener noreferrer" data-v-641633f9>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-641633f9><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-6b49cdcd><nav class="nav-links nav" data-v-6b49cdcd data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-641633f9><a class="item" href="/" data-v-641633f9>首页 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="前端" data-v-90f2c308><span class="button-text" data-v-90f2c308>前端</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/blog-build/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>博客相关</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/swagger-hub/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>SwaggerHub</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item active" href="/front-end/linux/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Linux相关</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/vue/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Vue</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/ast/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>AST</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/git/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Git</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/websocket/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>WebSocket</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/front-end/web-container/" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>WebContainer</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="书籍" data-v-90f2c308><span class="button-text" data-v-90f2c308>书籍</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/you-dont-know-js" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>你不知道的JavaScript</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/js-advice" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>JavaScript深入系列</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/css-secrets" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>CSS揭秘</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/grokking-algorithms" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>算法图解</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/pro-git" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Pro-Git</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/books/docker-practice" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Docker-从入门到实践</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="算法" data-v-90f2c308><span class="button-text" data-v-90f2c308>算法</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/algorithm/leetcode" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>LeetCode</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/algorithm/lodash" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Lodash</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="DevOps" data-v-90f2c308><span class="button-text" data-v-90f2c308>DevOps</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/devops/jira" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Jira</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-dropdown-link" data-v-15acbf05 data-v-90f2c308><button class="button" aria-label="其他" data-v-90f2c308><span class="button-text" data-v-90f2c308>其他</span><span class="right button-arrow" data-v-90f2c308></span></button><ul class="dialog" data-v-90f2c308><!--[--><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/other/smart-tools" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>Markdown</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/other/computer-tech" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>计算机基础知识</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/other/30-seconds-of-code" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>30 seconds of code</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><li class="dialog-item" data-v-90f2c308><div class="nav-dropdown-link-item" data-v-90f2c308 data-v-57d767ef><a class="item" href="/other/vanillawebprojects" data-v-57d767ef><span class="arrow" data-v-57d767ef></span><span class="text" data-v-57d767ef>vanillawebprojects</span><span class="icon" data-v-57d767ef><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-641633f9><a class="item" href="/quotations/" aria-label="摘抄语录" data-v-641633f9>摘抄语录 <!----></a></div></div><!--]--><!----><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-641633f9><a class="item isExternal" href="https://github.com/QiYoe/c-blog" target="_blank" rel="noopener noreferrer" data-v-641633f9>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-641633f9><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-6b49cdcd><!--[--><li class="sidebar-link"><p class="sidebar-link-item">博客相关</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/blog-build/">博客搭建</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/blog-build/baidu-include">百度收录</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/blog-build/seo-optimize">SEO优化</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/blog-build/aliyun-domin">阿里云域名</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">SwaggerHub</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/swagger-hub/">SwaggerHub使用教程</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/swagger-hub/curl">Curl</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">Linux相关</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/linux/">Linux启动Nginx服务</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/front-end/linux/nginx">Nginx</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#为什么nginx？">为什么Nginx？</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#安装">安装</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#centos（安装nginx预生成包版）">CentOS（安装nginx预生成包版）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#ubuntu（安装nginx预生成包版）">Ubuntu（安装nginx预生成包版）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）">从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#在docker上部署nginx">在Docker上部署NGINX</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#在docker上运行nginx">在Docker上运行NGINX</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#管理内容和配置文件">管理内容和配置文件</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#管理日志">管理日志</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#控制-nginx">控制 NGINX</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#基本功能">基本功能</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#master-and-worker-processes">Master and Worker Processes</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#控制-nginx-命令">控制 NGINX 命令</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#创建-nginx-配置文件">创建 NGINX 配置文件</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#http-load-balancing（负载均衡）">HTTP Load Balancing（负载均衡）</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#overview（概览）">Overview（概览）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#proxying-http-traffic-to-a-group-of-servers">Proxying HTTP Traffic to a Group of Servers</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#选择负载平衡方法">选择负载平衡方法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#server-weights">Server Weights</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tcp-and-udp-load-balancing">TCP and UDP Load Balancing</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#配置反向代理">配置反向代理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#configuring-tcp-or-udp-load-balancing">Configuring TCP or UDP Load Balancing</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#example-of-tcp-and-udp-load-balancing-configuration">Example of TCP and UDP Load-Balancing Configuration</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#http-health-checks">HTTP Health Checks</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#introduction">Introduction</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#passive-health-checks（被动健康检查）">Passive Health Checks（被动健康检查）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tcp-health-checks">TCP Health Checks</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#udp-health-checks">UDP Health Checks</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#web-server">Web Server</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#setting-up-virtual-servers">Setting Up Virtual Servers</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#configuring-locations">Configuring Locations</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#rewriting-http-responses">Rewriting HTTP Responses</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#handling-errors">Handling Errors</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#root-directory-and-index-files-根目录和索引文件">Root Directory and Index Files(根目录和索引文件)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#trying-several-options-尝试几种选择">Trying Several Options (尝试几种选择)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#passing-request-headers">Passing Request Headers</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#configuring-buffers-配置缓冲区">Configuring Buffers(配置缓冲区)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#choosing-an-outgoing-ip-address-选择传出-ip-地址">Choosing an Outgoing IP Address(选择传出 IP 地址)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#enabling-compression-启用压缩功能">Enabling Compression(启用压缩功能)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#enabling-decompression-启用解压缩">Enabling Decompression(启用解压缩)</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#security-controls">Security Controls</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#setting-up-an-https-server">Setting up an HTTPS Server</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#ocsp-validation-of-client-certificates-客户端证书的-ocsp-验证">OCSP Validation of Client Certificates(客户端证书的 OCSP 验证)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#https-server-optimization-服务器优化">HTTPS Server Optimization(服务器优化)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#ssl-certificate-chains-ssl-证书链">SSL Certificate Chains(SSL 证书链)</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#a-single-http-https-server">A Single HTTP/HTTPS Server</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/linux/docker">Docker</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">Vue</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/">Vue3学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/axios">Axios学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/vue-router">VueRouter学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/typescript">TS学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/vite">Vite学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/nuxt">Nuxt学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/sass">Sass学习笔记</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">AST</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/ast/">AST详解</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">Git</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/git/">git入门指南</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/git/advance">git进阶</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/git/flight-rules">git飞行规则</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">WebSocket</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/websocket/">WebSocket</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">WebContainer</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/web-container/">webContainer详解</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h2 id="为什么nginx？"><a class="header-anchor" href="#为什么nginx？" aria-hidden="true">#</a> 为什么Nginx？</h2><p><a href="http://nginx.org/en/" target="_blank" rel="noopener noreferrer">Nginx官网</a></p><p><a href="https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/" target="_blank" rel="noopener noreferrer">Nginx文档官网</a></p><p>官方版：Nginx时轻量级Web服务器，它不仅时一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POPS/SMTP代理服务器。</p><p>通俗版：轻量、简单、流行</p><h2 id="安装"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h2><h3 id="centos（安装nginx预生成包版）"><a class="header-anchor" href="#centos（安装nginx预生成包版）" aria-hidden="true">#</a> CentOS（安装nginx预生成包版）</h3><p>两种安装方式：</p><ul><li>Installing a Prebuilt CentOS/RHEL Package from an OS Repository（使用yum更新源安装）</li></ul><div class="language-bash"><pre><code><span class="token comment"># 安装 EPEL 存储库</span>
<span class="token function">sudo</span> yum <span class="token function">install</span> epel-release

<span class="token comment"># 更新存储库</span>
<span class="token function">sudo</span> yum update

<span class="token comment"># 安装 NGINX 开放源码</span>
<span class="token function">sudo</span> yum <span class="token function">install</span> nginx

<span class="token comment"># 验证安装</span>
<span class="token function">sudo</span> nginx -v
</code></pre></div><ul><li>Installing a Prebuilt CentOS/RHEL Package from the Official NGINX Repository（源码直接编译之后安装）</li></ul><div class="language-bash"><pre><code><span class="token comment"># 通过在/etc/yum.repop.d 中创建 nginx.repo 文件，为 CentOS 设置 yum 存储库，例如使用 vi</span>
<span class="token function">sudo</span> <span class="token function">vi</span> /etc/yum.repos.d/nginx.repo

<span class="token comment"># 在 nginx.repo 中添加以下行</span>
<span class="token punctuation">[</span>nginx<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>nginx repo
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>https://nginx.org/packages/mainline/centos/7/<span class="token variable">$basearch</span>/
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>

<span class="token comment"># 保存更改并退出 vi (按 ESC 并在提示符处:键入 wq)</span>

<span class="token comment"># 更新存储库</span>
<span class="token function">sudo</span> yum update

<span class="token comment"># 启动NGINX</span>
<span class="token function">sudo</span> nginx

<span class="token comment"># 确认 NGINX 开放源码已经启动并运行</span>
<span class="token function">curl</span> -I <span class="token number">127.0</span>.0.1
</code></pre></div><h3 id="ubuntu（安装nginx预生成包版）"><a class="header-anchor" href="#ubuntu（安装nginx预生成包版）" aria-hidden="true">#</a> Ubuntu（安装nginx预生成包版）</h3><p>两种安装方式：</p><ul><li>Installing a Prebuilt Ubuntu Package from an Ubuntu Repository（使用apt-get更新源安装）</li></ul><div class="language-bash"><pre><code><span class="token comment"># 更新 Ubuntu 存储库</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> update

<span class="token comment"># 安装软件包</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> nginx

<span class="token comment"># 验证安装</span>
<span class="token function">sudo</span> nginx -v
</code></pre></div><ul><li>Installing a Prebuilt Ubuntu Package from the Official NGINX Repository（源码直接编译之后安装）</li></ul><p>要为稳定版 nginx 包设置合适的存储库，运行以下命令：</p><div class="language-bash"><pre><code><span class="token comment"># 下载用于签署 NGINX 包和存储库的密钥，并将其添加到 apt 程序的密钥环</span>
<span class="token function">sudo</span> <span class="token function">wget</span> https://nginx.org/keys/nginx_signing.key
<span class="token function">sudo</span> apt-key <span class="token function">add</span> nginx_signing.key

<span class="token comment"># 编辑/etc/apt/source.list 文件，例如使用 vi</span>
<span class="token function">sudo</span> <span class="token function">vi</span> /etc/apt/sources.list

<span class="token comment"># 添加这些行 Source.list 来命名可以获得 NGINX 开放源码的存储库</span>
deb https://nginx.org/packages/mainline/ubuntu/ trusty nginx
deb-src https://nginx.org/packages/mainline/ubuntu/ trusty nginx

<span class="token comment"># 保存更改并退出 vi (按 ESC 并在提示符处:键入 wq)</span>

<span class="token comment"># 安装 NGINX 开放源码</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> nginx

<span class="token comment"># 启动 NGINX</span>
<span class="token function">sudo</span> nginx

<span class="token comment"># 确认 NGINX 开放源码已经启动并运行</span>
<span class="token function">curl</span> -I <span class="token number">127.0</span>.0.1
</code></pre></div><h3 id="从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）"><a class="header-anchor" href="#从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）" aria-hidden="true">#</a> 从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）</h3><div class="language-bash"><pre><code><span class="token comment"># 安装依赖库</span>

<span class="token comment">## PCRE-支持 NGINX 核心和重写模块所需的正则表达式</span>
<span class="token function">wget</span> ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.44.tar.gz
<span class="token function">tar</span> -zxf pcre-8.44.tar.gz
<span class="token builtin class-name">cd</span> pcre-8.44
./configure
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment">## Zlib-支持头部压缩。 NGINX Gzip 模块要求</span>
<span class="token function">wget</span> http://zlib.net/zlib-1.2.11.tar.gz
<span class="token function">tar</span> -zxf zlib-1.2.11.tar.gz
<span class="token builtin class-name">cd</span> zlib-1.2.11
./configure
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment">## OpenSSL-支持 HTTPS 协议。 NGINX SSL 模块和其他模块要求的</span>
<span class="token function">wget</span> http://www.openssl.org/source/openssl-1.1.1g.tar.gz
<span class="token function">tar</span> -zxf openssl-1.1.1g.tar.gz
<span class="token builtin class-name">cd</span> openssl-1.1.1g
./Configure darwin64-x86_64-cc --prefix<span class="token operator">=</span>/usr
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># 下载NGINX源码</span>
<span class="token function">wget</span> https://nginx.org/download/nginx-1.19.0.tar.gz
<span class="token function">tar</span> zxf nginx-1.19.0.tar.gz
<span class="token builtin class-name">cd</span> nginx-1.19.0

<span class="token comment"># 配置构建选项</span>
./configure
--sbin-path<span class="token operator">=</span>/usr/local/nginx/nginx
--conf-path<span class="token operator">=</span>/usr/local/nginx/nginx.conf
--pid-path<span class="token operator">=</span>/usr/local/nginx/nginx.pid
--with-pcre<span class="token operator">=</span><span class="token punctuation">..</span>/pcre-8.44
--with-zlib<span class="token operator">=</span><span class="token punctuation">..</span>/zlib-1.2.11
--with-http_ssl_module
--with-stream
--with-mail<span class="token operator">=</span>dynamic
--add-module<span class="token operator">=</span>/usr/build/nginx-rtmp-module
--add-dynamic-module<span class="token operator">=</span>/usr/build/3party_module

<span class="token comment"># 编译并安装构建</span>
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># --prefix=&lt;PATH&gt; NGINX 文件的目录。默认值:/usr/local/nginx</span>
<span class="token comment"># --sbin-path=&lt;PATH&gt; 可执行文件的名称。仅在安装过程中使用。默认值:&lt;prefix&gt;/sbin/nginx</span>
<span class="token comment"># --conf-path=&lt;PATH&gt; NGINX 配置文件的名称。默认值:&lt;prefix&gt;conf/nginx.conf</span>
<span class="token comment"># --pid-path=&lt;PATH&gt; NGINX 进程ID文件。默认值:&lt;prefix&gt;/logs/nginx.pid</span>
<span class="token comment"># --with-pcre=&lt;PATH&gt; PCRE 库的源路径，该库需要在位置指令和重写模块中进行常规表达式支持。（支持location、rewrite功能）</span>
<span class="token comment"># --with-zlib=&lt;PATH&gt; zlib 库的源路径，支持Gzip模块</span>
<span class="token comment"># -- with-mail 启用邮件代理功能</span>
<span class="token comment"># -- with-mail=dynamic 启用邮件代理功能，将其编译为一个单独的动态模块</span>
<span class="token comment"># -- with-stream 开启TCP、UDP代理功能</span>
<span class="token comment"># -- with-stream=dynamic 开启TCP、UDP代理功能，将其编译为一个单独的动态模块</span>
<span class="token comment"># --with-http_ssl_module 支持HTTPS支持。需要SSL库，比如OpenSSL</span>
<span class="token comment"># --add-module=&lt;PATH&gt; 静态链接模块：在编译时构建在 NGINX 开源中，并静态链接到 NGINX 二进制文件</span>
<span class="token comment"># --add-dynamic-module=&lt;PATH&gt; 动态链接模块：运行时动态加载到 NGINX 开放源码</span>
<span class="token comment"># with对应without：禁用模块</span>

<span class="token comment"># 启动NGINX</span>
nginx
</code></pre></div><h2 id="在docker上部署nginx"><a class="header-anchor" href="#在docker上部署nginx" aria-hidden="true">#</a> 在Docker上部署NGINX</h2><h3 id="在docker上运行nginx"><a class="header-anchor" href="#在docker上运行nginx" aria-hidden="true">#</a> 在Docker上运行NGINX</h3><div class="language-docker"><pre><code><span class="token comment"># 启动运行在容器中的 NGINX 实例，使用缺省的 NGINX 配置，并执行以下命令</span>
docker run --name mynginx1 -p 80:80 -d nginx
<span class="token comment"># mynginx1 是基于 NGINX 映像创建的容器的名称</span>
<span class="token comment"># -d 选项指定容器以分离模式运行: 容器继续运行，直到停止，但不响应命令行上运行的命令</span>
<span class="token comment"># -p 第一个参数指定 Docker 主机中的端口（nginx端口），第二个参数映射到容器中公开的端口（客户端端口）</span>
<span class="token comment"># 该命令返回容器 ID 的长格式: fcd1fb01b14557c7c9d991238f2558ae2704d129cf9fb97bb4fadf673a58580d。这种形式的 ID 用于日志文件的名称。</span>

<span class="token comment"># 验证容器是否已经创建并且正在使用</span>
docker ps
</code></pre></div><h3 id="管理内容和配置文件"><a class="header-anchor" href="#管理内容和配置文件" aria-hidden="true">#</a> 管理内容和配置文件</h3><ul><li>在Doker主机上维护内容和配置文件</li></ul><p>在创建容器时，可以将 Docker 主机上的本地目录挂载到容器中的目录中。NGINX 映像使用默认的 NGINX 配置，它使用/usr/share/NGINX/html 作为容器的根目录，并将配置文件放入/etc/NGINX 中。对于Docker主机内容在本地目录/var/www 中、配置文件在/var/nginx/conf 中的 Docker 主机，运行以下命令：</p><div class="language-docker"><pre><code>docker run --name mynginx2 --mount type=bind,source=/var/www,target=/usr/share/nginx/html,readonly --mount source=/var/nginx/conf,target=/etc/nginx/conf,readonly -p 80:80 -d nginx
</code></pre></div><p>对 Docker 主机上的本地目录/var/www 和/var/nginx/conf 中的文件所做的任何更改都反映在容器中的目录/usr/share/nginx/html 和/etc/nginx 中。Readonly 选项意味着只能在 Docker 主机上更改这些目录，而不能从容器内更改</p><ul><li>从 Docker 主机复制内容和配置文件</li></ul><p>在容器创建期间，Docker 可以从 Docker 主机上的本地目录复制内容和配置文件。一旦创建了一个容器，文件将通过在文件更改时创建一个新容器或通过修改容器中的文件来维护。</p><p>复制文件的一个简单方法是创建一个 Dockerfile，其中包含在基于 NGINX 映像生成新的 Docker 映像期间运行的命令。对于 Dockerfile 中的 file-COPY (COPY)命令，本地目录路径相对于 Dockerfile 所在的构建上下文。</p><p>假设内容目录是<code>content</code>，配置文件目录是 <code>conf</code>，这两个子目录都是 Dockerfile 所在的目录。NGINX 映像在<code>/etc/NGINX/conf.d</code> 目录中有缺省的 NGINX 配置文件，包括 <code>default.conf</code>。要只使用 Docker 主机上的配置文件，请使用 RUN 命令删除默认文件:</p><div class="language-docker"><pre><code><span class="token instruction"><span class="token keyword">FROM</span> nginx</span>
<span class="token instruction"><span class="token keyword">RUN</span> rm /etc/nginx/conf.d/default.conf</span>
<span class="token instruction"><span class="token keyword">COPY</span> content /usr/share/nginx/html</span>
<span class="token instruction"><span class="token keyword">COPY</span> conf /etc/nginx</span>
</code></pre></div><p>通过在 Dockerfile 所在的目录中运行命令创建 NGINX 映像。句号(&quot;.&quot;)在命令的末尾将工作目录文件定义为构建上下文，其中包含 Dockerfile 和要复制的目录:</p><div class="language-docker"><pre><code>docker build -t mynginx_image1 .
</code></pre></div><p>基于 mynginx image1映像创建一个容器 mynginx3:</p><div class="language-docker"><pre><code>docker run --name mynginx3 -p 80:80 -d mynginx_image1
</code></pre></div><ul><li>在容器中维护内容和配置文件</li></ul><p>由于 SSH 不能用于访问 NGINX 容器，因此要直接编辑内容或配置文件，您需要创建一个具有 shell 访问权限的辅助容器。要让 helper 容器能够访问这些文件，创建一个新的映像，其中包含为映像定义的适当的 Docker 数据卷:</p><div class="language-docker"><pre><code><span class="token comment"># 复制 nginx 内容和配置文件，用 Dockerfile 定义映像的音量:</span>
<span class="token instruction"><span class="token keyword">FROM</span> nginx</span>
<span class="token instruction"><span class="token keyword">COPY</span> content /usr/share/nginx/html</span>
<span class="token instruction"><span class="token keyword">COPY</span> conf /etc/nginx</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> /usr/share/nginx/html</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> /etc/nginx</span>

<span class="token comment"># 通过运行以下命令创建新的 NGINX 映像:</span>
docker build -t mynginx_image2 .

<span class="token comment"># 基于 mynginx image2映像创建一个 NGINX 容器 mynginx4:</span>
docker run --name mynginx4 -p 80:80 -d mynginx_image2

<span class="token comment"># 启动一个带有 shell 的 helper 容器 mynginx4文件，提供对我们刚刚创建的 mynginx4容器的内容和配置目录的访问:</span>
docker run -i -t --volumes-from mynginx4 --name mynginx4_files debian /bin/bash
<span class="token comment"># 新的mynginx4_files帮助器容器在前台运行，带有一个持久的标准输入(-i选项)和一个tty (-t选项)。mynginx4中定义的所有卷都作为helper容器中的本地目录挂载。</span>
<span class="token comment"># debian参数意味着帮助容器使用来自Docker Hub的debian映像。因为NGINX映像也使用Debian，所以最有效的方法是使用Debian作为辅助容器，而不是让Docker加载另一个操作系统</span>
<span class="token comment"># /bin/bash参数意味着bash shell在helper容器中运行，显示一个shell提示符，您可以根据需要使用该提示符修改文件</span>

<span class="token comment"># 要启动和停止容器，请运行以下命令:</span>
docker start mynginx4_files
docker stop mynginx4_files

<span class="token comment"># 要退出 shell 但保持容器运行，请按 Ctrl + p，然后按 Ctrl + q 组合键恢复对正在运行的容器的 shell 访问，运行以下命令:</span>
docker attach mynginx4_files

<span class="token comment"># 要退出 shell 并终止容器，请运行 exit 命令。</span>
</code></pre></div><h3 id="管理日志"><a class="header-anchor" href="#管理日志" aria-hidden="true">#</a> 管理日志</h3><ul><li>使用默认日志记录</li></ul><p>默认情况下，NGINX 映像配置为向 Docker 日志收集器发送 NGINX 访问日志和错误日志。这是通过将它们链接到 stdout 和 stderr 来实现的: 然后将来自这两个日志的所有消息写入文件/var/lib/docker/containers/container-ID/container-ID-json。登录 Docker 主机。Container-ID 是创建容器时返回的长形式 ID。要显示长表单 ID，请运行以下命令:</p><div class="language-docker"><pre><code>docker inspect --format &#39;{{ .Id }}&#39; container-name
</code></pre></div><p>可以使用 Docker 命令行和 Docker 引擎 API 提取日志消息:</p><div class="language-docker"><pre><code><span class="token comment"># 要从命令行提取日志消息，请运行以下命令:</span>
docker logs container-name

<span class="token comment"># 要使用 Docker Remote API 提取日志消息，请使用 Docker Unix sock 发送一个 GET 请求:</span>
curl --unix-sock /var/run/docker-sock http://localhost/containers/container-name/logs?stdout=1&amp;stderr=1
<span class="token comment"># 若要在输出中只包含访问日志消息，请只包含 stdout = 1。要将输出限制为错误日志消息，只包含 stderr = 1</span>
</code></pre></div><ul><li>使用定制的日志记录</li></ul><p>如果希望为某些配置块(如服务器{}和位置{})以不同的方式配置日志记录，请为容器中存储日志文件的目录定义 Docker 卷，创建一个帮助容器来访问日志文件，并使用任何日志记录工具。要实现这一点，请创建一个新映像，其中包含日志文件的卷或卷。</p><div class="language-docker"><pre><code><span class="token comment"># 例如，为了配置 NGINX 将日志文件存储在/var/log/NGINX/log 中，在 Dockerfile 中添加该目录的 VOLUME 定义(前提是内容和配置文件在容器中进行管理) :</span>
<span class="token instruction"><span class="token keyword">FROM</span> nginx</span>
<span class="token instruction"><span class="token keyword">COPY</span> content /usr/share/nginx/html</span>
<span class="token instruction"><span class="token keyword">COPY</span> conf /etc/nginx</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> /var/log/nginx/log</span>
<span class="token comment"># 然后，您可以创建一个映像，并使用它创建一个 NGINX 容器和一个可以访问日志目录的 helper 容器。助手容器可以安装任何所需的日志记录工具。</span>
</code></pre></div><h3 id="控制-nginx"><a class="header-anchor" href="#控制-nginx" aria-hidden="true">#</a> 控制 NGINX</h3><p>由于不能直接访问 NGINX 容器的命令行，因此不能直接将 NGINX 命令发送到容器。相反，信号可以通过 Docker kill 命令发送到容器</p><div class="language-docker"><pre><code><span class="token comment"># 要重新加载 NGINX 配置，请向 Docker 发送 HUP 信号:</span>
docker kill -s HUP container-name

<span class="token comment"># 要重新启动 NGINX，运行以下命令重新启动容器:</span>
docker restart container-name
</code></pre></div><h2 id="基本功能"><a class="header-anchor" href="#基本功能" aria-hidden="true">#</a> 基本功能</h2><h3 id="master-and-worker-processes"><a class="header-anchor" href="#master-and-worker-processes" aria-hidden="true">#</a> Master and Worker Processes</h3><p>NGINX 有一个主进程和一个或多个辅助进程。如果启用了缓存，缓存加载器和缓存管理器进程也会在启动时运行。</p><p>主进程的主要目的是读取和评估配置文件，以及维护辅助进程。</p><p>辅助进程执行请求的实际处理。NGINX 依靠依赖于操作系统的机制在工作进程之间有效地分配请求。辅助进程的数量由 nginx.conf 配置文件中的 worker _ processes 指令定义，可以设置为固定数量，也可以配置为自动调整可用 CPU 内核的数量。</p><h3 id="控制-nginx-命令"><a class="header-anchor" href="#控制-nginx-命令" aria-hidden="true">#</a> 控制 NGINX 命令</h3><p>要重新加载配置，可以停止或重新启动 NGINX，或者向主进程发送信号。可以通过运行带有-s 参数的 NGINX 命令(调用 NGINX 可执行文件)来发送信号。</p><div class="language-nginx"><pre><code>nginx -s &lt;SIGNAL&gt;
</code></pre></div><p>其中 &lt; signal &gt; 可以是以下任何一个:</p><ul><li>quit – 优雅关闭</li><li>reload – 重新加载配置文件</li><li>reopen – 重新打开日志文件</li><li>stop – 立即关闭(快速关闭)</li></ul><p>Kill 实用程序也可用于直接向主进程发送信号。默认情况下，主进程的进程 ID 被写入 nginx.pid 文件，该文件位于/usr/local/nginx/logs 或/var/run 目录中。</p><h3 id="创建-nginx-配置文件"><a class="header-anchor" href="#创建-nginx-配置文件" aria-hidden="true">#</a> 创建 NGINX 配置文件</h3><p>默认情况下，配置文件名为 NGINX.conf。它通常是/usr/local/nginx/conf、/etc/nginx 或/usr/local/etc/nginx 之一</p><ul><li>Directives</li></ul><p>配置文件由指令及其参数组成。简单(单行)指令的每个末尾都有一个分号。其他指令充当“容器”，将相关指令组合在一起，并用花括号括起来({}) ; 这些指令通常称为块。下面是一些简单指令的例子。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">user</span>             nobody</span><span class="token punctuation">;</span>
<span class="token directive"><span class="token keyword">error_log</span>        logs/error.log notice</span><span class="token punctuation">;</span>
<span class="token directive"><span class="token keyword">worker_processes</span> <span class="token number">1</span></span><span class="token punctuation">;</span>
</code></pre></div><ul><li>特定功能的配置文件</li></ul><p>为了使配置更易于维护，我们建议您将其分割为一组特定于特性的文件，存储在/etc/nginx/conf.d 目录中，并使用 nginx.conf 主文件中的头文件文件来引用特定于特性的文件的内容。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">include</span> conf.d/http</span><span class="token punctuation">;</span>
<span class="token directive"><span class="token keyword">include</span> conf.d/stream</span><span class="token punctuation">;</span>
<span class="token directive"><span class="token keyword">include</span> conf.d/exchange-enhanced</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>Contexts(称为上下文)</li></ul><p>一些顶级指令(称为上下文)将适用于不同流量类型的指令组合在一起:</p><ul><li>events – 一般连接处理</li><li>http - HTTP 传输</li><li>mail - 邮件通信</li><li>stream - TCP 和 UDP 通信</li></ul><p>置于这些Contexts之外的指令被认为是<code>main context</code></p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">user</span> nobody</span><span class="token punctuation">;</span> <span class="token comment"># a directive in the &#39;main&#39; context</span>

<span class="token directive"><span class="token keyword">events</span></span> <span class="token punctuation">{</span>
  <span class="token comment"># configuration of connection processing</span>
<span class="token punctuation">}</span>

<span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>
  <span class="token comment"># Configuration specific to HTTP and affecting all virtual servers  </span>

  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># configuration of HTTP virtual server 1       </span>
    <span class="token directive"><span class="token keyword">location</span> /one</span> <span class="token punctuation">{</span>
      <span class="token comment"># configuration for processing URIs starting with &#39;/one&#39;</span>
    <span class="token punctuation">}</span>
    <span class="token directive"><span class="token keyword">location</span> /two</span> <span class="token punctuation">{</span>
      <span class="token comment"># configuration for processing URIs starting with &#39;/two&#39;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
  
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># configuration of HTTP virtual server 2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token directive"><span class="token keyword">stream</span></span> <span class="token punctuation">{</span>
  <span class="token comment"># Configuration specific to TCP/UDP and affecting all virtual servers</span>
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># configuration of TCP virtual server 1 </span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="http-load-balancing（负载均衡）"><a class="header-anchor" href="#http-load-balancing（负载均衡）" aria-hidden="true">#</a> HTTP Load Balancing（负载均衡）</h2><h3 id="overview（概览）"><a class="header-anchor" href="#overview（概览）" aria-hidden="true">#</a> Overview（概览）</h3><p>负载均衡指的是在多个后端服务器之间有效地分配网络流量</p><p>跨多个应用程序实例的负载平衡是一种常用的技术，用于优化资源利用率、最大化吞吐量、减少延迟并确保容错配置。</p><h3 id="proxying-http-traffic-to-a-group-of-servers"><a class="header-anchor" href="#proxying-http-traffic-to-a-group-of-servers" aria-hidden="true">#</a> Proxying HTTP Traffic to a Group of Servers</h3><p>要开始使用 NGINX Open Source 来平衡一组服务器的 HTTP 流量，首先需要使用<code>upstream</code>指令定义该组。该指令被放置在 http 上下文中。</p><p>例如，下面的配置定义了一个名为 backend 的组，由三个服务器配置组成(可以在三个以上的实际服务器中解析) :</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">server</span> backend1.example.com weight=5</span><span class="token punctuation">;</span> <span class="token comment"># 运行同一应用程序的实例</span>
    <span class="token directive"><span class="token keyword">server</span> backend2.example.com</span><span class="token punctuation">;</span> <span class="token comment"># 运行同一应用程序的实例</span>
    <span class="token directive"><span class="token keyword">server</span> 192.0.0.1 backup</span><span class="token punctuation">;</span> <span class="token comment"># 备份服务器</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
      <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment"># NGINX 上运行的虚拟服务器将所有请求传递给前面例子中定义的备份服务器</span>
<span class="token punctuation">}</span>
<span class="token comment"># 因为在upstream中没有指定负载平衡算法，所以 NGINX 使用默认算法 Round Robin:</span>
</code></pre></div><h3 id="选择负载平衡方法"><a class="header-anchor" href="#选择负载平衡方法" aria-hidden="true">#</a> 选择负载平衡方法</h3><p>NGINX 开源支持四种负载平衡方法:</p><ul><li>Round Robin - 请求均匀地分布在服务器上，并考虑服务器权重。默认情况下使用此方法(没有启用它的指令)</li></ul><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span>
  <span class="token comment"># no load balancing method is specified for Round Robin</span>
  <span class="token directive"><span class="token keyword">server</span> backend1.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend2.example.com</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>Least Connections - 最少的连接——向服务器发送的请求中活动连接的数量最少，同样要考虑服务器权重:</li></ul><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">least_conn</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend1.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend2.example.com</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>IP Hash - 发送请求的服务器是由客户端 IP 地址决定的。在这种情况下，使用 IPv4地址的前三个八位元组或整个 IPv6地址来计算散列值。该方法保证来自相同地址的请求到达相同的服务器，除非它不可用。</li></ul><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">ip_hash</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend1.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend2.example.com</span><span class="token punctuation">;</span>

  <span class="token comment"># 如果某个服务器需要暂时从负载平衡旋转中删除，可以用 down 参数对其进行标记，以便保留当前客户端 IP 地址的散列。由此服务器处理的请求将自动发送到组中的下一个服务器:</span>
  <span class="token directive"><span class="token keyword">server</span> backend3.example.com down</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><ul><li>Hash - 请求是从用户定义的关键，可以是一个文本字符串，变量，或一个组合确定。例如，密钥可能是一个成对的源 IP 地址和端口，或者是一个 URI，如下例所示:</li></ul><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">hash</span> <span class="token variable">$request_uri</span> consistent</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend1.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend2.example.com</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Hash 指令的可选的 consistent 参数启用 ketama consistent-hash 负载平衡。根据用户定义的散列键值，请求均匀地分布在所有上游服务器上。如果将上游服务器添加到上游组或从上游组移除，则只需重新映射少量密钥，从而在负载平衡缓存服务器或其他累积状态的应用程序的情况下，最大限度地减少缓存丢失。</p><h3 id="server-weights"><a class="header-anchor" href="#server-weights" aria-hidden="true">#</a> Server Weights</h3><p>默认情况下，NGINX 使用 Round Robin 方法根据请求的权重在组中的服务器之间分发请求。服务器指令的 weight 参数设置服务器的权重; 默认值是1:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">server</span> backend1.example.com weight=5</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend2.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> 192.0.0.1 backup</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 在本例中， backend1.example.com 服务器的权重为5; 其他两个服务器的默认权重为1，但 IP 地址为192.0.0.1的服务器被标记为备份服务器，除非其他两个服务器都不可用，否则不会接收请求。使用这种权重配置，每6个请求中，5个发送到 backend1.example.com ，1个发送到 backend2.example.com。</span>
</code></pre></div><h2 id="tcp-and-udp-load-balancing"><a class="header-anchor" href="#tcp-and-udp-load-balancing" aria-hidden="true">#</a> TCP and UDP Load Balancing</h2><h3 id="配置反向代理"><a class="header-anchor" href="#配置反向代理" aria-hidden="true">#</a> 配置反向代理</h3><p>首先，您需要配置反向代理，以便 NGINX Open Source 可以将客户机的 TCP 连接或 UDP 数据报转发到upstream组或代理服务器</p><p>打开 NGINX 配置文件并执行以下步骤:</p><div class="language-nginx"><pre><code><span class="token comment"># 创建一个顶级 stream {} 块:</span>
<span class="token directive"><span class="token keyword">stream</span></span> <span class="token punctuation">{</span>
  <span class="token comment"># 为 stream {}上下文中的每个虚拟服务器定义一个或多个 server {} 配置块</span>
  <span class="token comment"># 在每个服务器的 server {}配置块中，包含 listen 指令来定义服务器侦听的 IP 地址和/或端口</span>
  <span class="token comment"># 使用 proxy_ pass 指令来定义被代理的服务器或者服务器转发流量的upstream组</span>
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># TCP 是 stream 上下文的默认协议，所以 listen 指令没有 TCP 参数</span>
    <span class="token directive"><span class="token keyword">listen</span> <span class="token number">12345</span></span><span class="token punctuation">;</span>
    <span class="token comment">#TCP traffic will be forwarded to the &quot;stream_backend&quot; upstream group</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> stream_backend</span><span class="token punctuation">;</span>
    <span class="token comment"># ...</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># 对于 UDP 流量，还包括 UDP 参数</span>
    <span class="token directive"><span class="token keyword">listen</span> <span class="token number">53</span> udp</span><span class="token punctuation">;</span>
    <span class="token comment">#TCP traffic will be forwarded to the specified server</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> backend.example.com:12346</span><span class="token punctuation">;</span>
    <span class="token comment"># ...</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">listen</span>     <span class="token number">53</span> udp</span><span class="token punctuation">;</span>
    <span class="token comment">#UDP traffic will be forwarded to the &quot;dns_servers&quot; upstream group</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> dns_servers</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># 如果代理服务器有多个网络接口，您可以选择配置 NGINX，使其在连接到上游服务器时使用特定的源 IP 地址。如果 NGINX 后面的代理服务器配置为接受来自特定 IP 网络或 IP 地址范围的连接，这可能会很有用</span>
    <span class="token directive"><span class="token keyword">listen</span>     127.0.0.1:12345</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> backend.example.com:12345</span><span class="token punctuation">;</span>
    <span class="token comment"># 包括 proxy _ bind 指令和适当网络接口的 IP 地址</span>
    <span class="token directive"><span class="token keyword">proxy_bind</span> 127.0.0.1:12345</span><span class="token punctuation">;</span>
    <span class="token comment"># 还可以选择调整两个内存缓冲区的大小，NGINX 可以在这两个缓冲区中放置来自客户端和上游连接的数据。如果数据量很小，可以减少缓冲区，从而节省内存资源。如果存在大量数据，则可以增加缓冲区大小，以减少套接字读/写操作的数量。一旦在一个连接上接收到数据，NGINX 就会读取数据并通过另一个连接将其转发。缓冲区由 proxy _ buffer _ size 指令控制</span>
    <span class="token directive"><span class="token keyword">proxy_buffer_size</span> <span class="token number">16k</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment"># ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="configuring-tcp-or-udp-load-balancing"><a class="header-anchor" href="#configuring-tcp-or-udp-load-balancing" aria-hidden="true">#</a> Configuring TCP or UDP Load Balancing</h3><div class="language-nginx"><pre><code><span class="token comment"># 创建一组服务器，或者一个负载均衡的上游组。在upsteam{}上下文中定义一个或多个upsteam {}配置块，并设置上游组的名称，例如，TCP 服务器的 stream_backend 和 UDP 服务器的 dns_servers</span>
<span class="token directive"><span class="token keyword">stream</span></span> <span class="token punctuation">{</span>
  <span class="token comment"># 确保 proxy_pass 指令引用了上游组的名称，就像上面为反向代理配置的那些指令一样</span>
  <span class="token directive"><span class="token keyword">upstream</span> stream_backend</span> <span class="token punctuation">{</span>
    <span class="token comment"># 用上游服务器填充上游组。在上游{}块中，为每个上游服务器添加一个服务器指令，指定它的 IP 地址或主机名(可以解析为多个 IP 地址)和一个必需的端口号。请注意，您没有为每个服务器定义协议，因为这是通过您在服务器块中的 listen 指令上包含的参数为整个上游组定义的，该参数是您前面创建的</span>
    <span class="token directive"><span class="token keyword">server</span> backend1.example.com:12345</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> backend2.example.com:12345</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> backend3.example.com:12346</span><span class="token punctuation">;</span>
    <span class="token comment"># ...</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">upstream</span> dns_servers</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.136.130:53</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.136.131:53</span><span class="token punctuation">;</span>
    <span class="token comment"># ...</span>
  <span class="token punctuation">}</span>

  <span class="token comment"># ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>配置上游组使用的负载平衡方法:</p><ul><li>Round Robin - 默认情况下，NGINX 使用 Round Robin 算法来平衡负载流量，并将其顺序指向配置的上游组中的服务器</li><li>Least Connections - 最少连接-NGINX 选择当前活动连接数较少的服务器</li><li>Hash - Hash-NGINX 基于用户定义的密钥选择服务器，例如，源 IP 地址($remote_addr)</li><li>Random - 每个连接将被传递到一个随机选择的服务器。如果指定了这个<code>two</code>参数，首先，NGINX 随机选择两个服务器并考虑服务器权重，然后使用指定的方法选择其中一个服务器: <ul><li>least_conn - 活动连接的最少数量</li></ul></li><li>对于每个上游服务器，可以选择指定特定于服务器的参数，包括最大连接数、服务器重量等</li></ul><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">upstream</span> stream_backend</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">hash</span>   <span class="token variable">$remote_addr</span> consistent</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend1.example.com:12345 weight=5</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend2.example.com:12345</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend3.example.com:12346 max_conns=3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token directive"><span class="token keyword">upstream</span> dns_servers</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">least_conn</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> 192.168.136.130:53</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> 192.168.136.131:53</span><span class="token punctuation">;</span>
  <span class="token comment"># ...</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>另一种方法是代理流量到单个服务器，而不是上游组。如果您通过主机名识别服务器，并配置主机名以解析为多个 IP 地址，那么 NGINX 负载使用 Round Robin 算法平衡 IP 地址之间的流量。在这种情况下，您必须在 proxy _ pass 指令中指定服务器端口号，并且不能在 IP 地址或主机名之前指定协议</li></ul><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">stream</span></span> <span class="token punctuation">{</span>
  <span class="token comment"># ...</span>
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">listen</span>     <span class="token number">12345</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> backend.example.com:12345</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="example-of-tcp-and-udp-load-balancing-configuration"><a class="header-anchor" href="#example-of-tcp-and-udp-load-balancing-configuration" aria-hidden="true">#</a> Example of TCP and UDP Load-Balancing Configuration</h3><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">stream</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">upstream</span> stream_backend</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">least_conn</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> backend1.example.com:12345 weight=5</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> backend2.example.com:12345 max_fails=2 fail_timeout=30s</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> backend3.example.com:12345 max_conns=3</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token directive"><span class="token keyword">upstream</span> dns_servers</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">least_conn</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.136.130:53</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.136.131:53</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.136.132:53</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># 服务器监听端口12345，并将所有 TCP 连接代理到上游服务器的 stream _ backend 组。注意，在流模块的上下文中定义的 proxy _ pass 指令不能包含协议</span>
    <span class="token directive"><span class="token keyword">listen</span>        <span class="token number">12345</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span>    stream_backend</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_timeout</span> <span class="token number">3s</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_connect_timeout</span> <span class="token number">1s</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># 服务器监听端口53，并将所有 UDP 数据报(listen 指令的 UDP 参数)代理到名为 dns _ servers 的上游组。如果未指定 udp 参数，套接字将侦听 TCP 连接。</span>
    <span class="token directive"><span class="token keyword">listen</span>     <span class="token number">53</span> udp</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> dns_servers</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># 虚拟服务器监听端口12346并将 TCP 连接代理到 backend4.example.com 服务器，该服务器可以解析几个 IP 地址，这些 IP 地址通过 Round Robin 方法实现负载平衡</span>
    <span class="token directive"><span class="token keyword">listen</span>     <span class="token number">12346</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> backend4.example.com:12346</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="http-health-checks"><a class="header-anchor" href="#http-health-checks" aria-hidden="true">#</a> HTTP Health Checks</h2><h3 id="introduction"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h3><p>NGINX 可以不断地测试上游服务器，避免出现故障的服务器，并优雅地将恢复的服务器添加到负载平衡组中。</p><h3 id="passive-health-checks（被动健康检查）"><a class="header-anchor" href="#passive-health-checks（被动健康检查）" aria-hidden="true">#</a> Passive Health Checks（被动健康检查）</h3><p>对于被动健康检查，NGINX 会在事务发生时进行监视，并尝试恢复失败的连接。如果事务仍然不能恢复，NGINX 开放源码将服务器标记为不可用，并暂时停止向它发送请求，直到它再次被标记为活动</p><ul><li>fail_timeout - 设置服务器被标记为不可用的时间，以及服务器被标记为不可用的时间(默认为10秒)</li><li>max_fails - 服务器被标记为不可用(默认为1次尝试)</li></ul><p>在下面的例子中，如果 NGINX 无法向服务器发送请求，或者在30秒内3次没有收到服务器的响应，它将服务器标记为30秒内不可用:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">server</span> backend1.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend2.example.com max_fails=3 fail_timeout=30s</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最近恢复的服务器很容易被连接压垮，这可能导致服务器再次被标记为不可用。缓慢启动允许上游服务器逐渐恢复其重量从零到其名义值后，它已恢复或成为可用。这可以通过上游服务器指令的 slow _ start 参数来完成</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">upstream</span> backend</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">server</span> backend1.example.com slow_start=30s</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> backend2.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server</span> 192.0.0.1 backup</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">提醒</p><p>注意，如果组中只有一个服务器，fail_timeout 和 max_fails 参数将被忽略，服务器永远不会被标记为不可用。</p></div><h3 id="tcp-health-checks"><a class="header-anchor" href="#tcp-health-checks" aria-hidden="true">#</a> TCP Health Checks</h3><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">stream</span></span> <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
  <span class="token directive"><span class="token keyword">upstream</span> stream_backend</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">server</span> backend1.example.com:12345 weight=5</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> backend2.example.com:12345 max_fails=2 fail_timeout=30s</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> backend3.example.com:12345 max_conns=3</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">#...</span>
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">listen</span>     <span class="token number">12345</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> stream_backend</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="udp-health-checks"><a class="header-anchor" href="#udp-health-checks" aria-hidden="true">#</a> UDP Health Checks</h3><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">stream</span></span> <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
  <span class="token directive"><span class="token keyword">upstream</span> dns_upstream</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.136.130:53 fail_timeout=60s</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.136.131:53 fail_timeout=60s</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.136.132:53 fail_timeout=60s</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">#...</span>
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">listen</span>          <span class="token number">53</span> udp</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span>      dns_upstream</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_timeout</span>   <span class="token number">1s</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_responses</span> <span class="token number">1</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">error_log</span>       logs/dns.log</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="web-server"><a class="header-anchor" href="#web-server" aria-hidden="true">#</a> Web Server</h2><h3 id="setting-up-virtual-servers"><a class="header-anchor" href="#setting-up-virtual-servers" aria-hidden="true">#</a> Setting Up Virtual Servers</h3><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token comment"># 服务器配置块通常包括一个 listen 指令，用于指定服务器侦听请求的 IP 地址和端口(或 Unix domain socket 和路径)。IPv4和 IPv6地址均可接受，请将 IPv6地址放在方括号内</span>
    <span class="token directive"><span class="token keyword">listen</span> 127.0.0.1:8080</span><span class="token punctuation">;</span>
    <span class="token comment"># Additional server configuration</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果忽略某个端口，则使用标准端口。同样，如果省略了一个地址，服务器将侦听所有地址。如果未包含 listen 指令，“标准”端口为80/tcp，“缺省”端口为8000/tcp，具体取决于超级用户权限。</p><p>如果有多个服务器与请求的 IP 地址和端口匹配，NGINX 将在服务器块中根据 server_name 指令测试请求的 Host 头字段。Server_name 的参数可以是完整的(精确的)名称、通配符或正则表达式。通配符是一个字符串，其开头、结尾或两者都包含星号(*) ; 星号匹配任何字符序列。NGINX Plus 对正则表达式使用 Perl 语法; 在它们之前加上波浪号(~)。这个例子说明了一个确切的名称。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span>      <span class="token number">80</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server_name</span> example.org www.example.org</span><span class="token punctuation">;</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果 Host header 字段与服务器名称不匹配，NGINX Plus 将请求路由到请求到达的端口的默认服务器。缺省服务器是 nginx.conf 文件中列出的第一个服务器，除非在 listen 指令中包含 default _ server 参数，以显式地将服务器指定为缺省服务器。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span> default_server</span><span class="token punctuation">;</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="configuring-locations"><a class="header-anchor" href="#configuring-locations" aria-hidden="true">#</a> Configuring Locations</h3><p>Location 指令有两种类型的参数: 前缀字符串(路径名)和正则表达式。要使请求 URI 匹配前缀字符串，它必须以前缀字符串开头。</p><div class="language-nginx"><pre><code><span class="token comment"># 以下带有路径名参数的示例位置匹配以/some/path/开头的请求 uri，如/some/path/document. html。(它不匹配/my-site/some/path，因为/some/path 不会出现在 URI 的开头。)</span>
<span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>

<span class="token comment"># 正则表达式前面带有用于区分大小写匹配的波浪号(~) ，或者用于不区分大小写匹配的波浪号星号(~*)。下面的示例匹配包含字符串的 uri的 .html 或 .htm在任何位置。</span>
<span class="token directive"><span class="token keyword">location</span> ~ \.html?</span> <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>

<span class="token comment"># = 修饰符的典型用例是对/(正斜杠)的请求。如果频繁地请求/，则将 =/指定为 location 指令的参数可以加快处理速度，因为在第一次比较之后将停止搜索匹配项。</span>
<span class="token directive"><span class="token keyword">location</span> = /</span> <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>

<span class="token comment"># location上下文可以包含定义如何解析请求的指令——服务于静态文件或将请求传递给代理服务器。在下面的示例中，匹配第一个location上下文的请求是来自/data 目录的服务文件，匹配第二个location上下文的请求被传递给承载 www.example. com 域内容的代理服务器。</span>
<span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">location</span> /images/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">root</span> /data</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://www.example.com</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment"># root 指令指定用于搜索要服务的静态文件的文件系统路径。</span>
<span class="token comment"># 在上面的示例中，所有以/images/开头的 uri 请求都被传递到代理服务器</span>

<span class="token comment"># 有些网站 uri 要求立即返回带有特定错误的响应或重定向代码，例如当页面被临时或永久移动时。最简单的方法是使用 return 指令</span>
<span class="token directive"><span class="token keyword">location</span> /wrong/url</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">return</span> <span class="token number">404</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 返回的第一个参数是响应代码。可选的第二个参数可以是重定向(代码301、302、303和307)的 URL，也可以是在响应主体中返回的文本</span>
<span class="token directive"><span class="token keyword">location</span> /permanently/moved/url</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">return</span> <span class="token number">301</span> http://www.example.com/moved/here</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 在请求处理期间，可以通过使用 rewrite 指令多次修改请求 URI，该指令有一个可选参数和两个必需参数。第一个(必需的)参数是请求 URI 必须匹配的正则表达式。第二个参数是用于替换匹配 URI 的 URI。可选的第三个参数是一个标志，它可以停止进一步重写指令的处理，或者发送重定向(代码301或302)</span>
<span class="token directive"><span class="token keyword">location</span> /users/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">rewrite</span> ^/users/(.*)$ /show?user=<span class="token variable">$1</span> break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 下面的示例显示重写指令与 return 指令的组合</span>
<span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
  <span class="token directive"><span class="token keyword">rewrite</span> ^(/download/.*)/media/(\w+)\.?.*$ <span class="token variable">$1</span>/mp3/<span class="token variable">$2</span>.mp3 last</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">rewrite</span> ^(/download/.*)/audio/(\w+)\.?.*$ <span class="token variable">$1</span>/mp3/<span class="token variable">$2</span>.ra  last</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">return</span>  <span class="token number">403</span></span><span class="token punctuation">;</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
<span class="token comment"># break——像break指令一样，停止当前上下文中对重写指令的处理，并取消对匹配新URI位置的搜索。不执行新位置中的重写指令。</span>
<span class="token comment"># last——停止当前服务器或位置上下文中重写指令的执行，但是NGINX Plus搜索与重写的URI匹配的位置，并且应用新位置中的任何重写指令(意味着URI可以再次更改)。</span>
</code></pre></div><h3 id="rewriting-http-responses"><a class="header-anchor" href="#rewriting-http-responses" aria-hidden="true">#</a> Rewriting HTTP Responses</h3><div class="language-nginx"><pre><code><span class="token comment"># 可以更改引用代理以外的服务器的绝对链接:</span>
<span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">sub_filter</span>      /blog/ /blog-staging/</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">sub_filter_once</span> <span class="token boolean">off</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 另一个示例将方案从 http://更改为 https://，并将本地主机地址替换为请求头字段中的主机名。子过滤器 once 指令告诉 NGINX 在一个位置内连续应用子过滤器指令</span>
<span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">sub_filter</span>     <span class="token string">&#39;href=&quot;http://127.0.0.1:8080/&#39;</span>    <span class="token string">&#39;href=&quot;https://<span class="token variable">$host</span>/&#39;</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">sub_filter</span>     <span class="token string">&#39;img src=&quot;http://127.0.0.1:8080/&#39;</span> <span class="token string">&#39;img src=&quot;https://<span class="token variable">$host</span>/&#39;</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">sub_filter_once</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="handling-errors"><a class="header-anchor" href="#handling-errors" aria-hidden="true">#</a> Handling Errors</h3><div class="language-nginx"><pre><code><span class="token comment"># error _ page 指定要返回的页面(/404. html)和404错误代码。</span>
<span class="token directive"><span class="token keyword">error_page</span> <span class="token number">404</span> /404.html</span><span class="token punctuation">;</span>

<span class="token comment"># 在下面的例子中，当 NGINX Plus 找不到一个页面时，它用代码301代替代码404，并将客户端重定向到 http:/example.com/new/path.html。当客户机仍然试图访问旧 URI 上的页面时，此配置非常有用。301代码告诉浏览器页面已经永久移动，并且需要在返回时自动用新地址替换旧地址。</span>
<span class="token directive"><span class="token keyword">location</span> /old/path.html</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">error_page</span> <span class="token number">404</span> =301 http:/example.com/new/path.html</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 下面的配置是在找不到文件时向后端传递请求的示例。因为在 error _ page 指令的等号后面没有指定状态代码，所以对客户端的响应包含由代理服务器返回的状态代码(不一定是404)</span>
<span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  ...
  <span class="token directive"><span class="token keyword">location</span> /images/</span> <span class="token punctuation">{</span>
    <span class="token comment"># Set the root directory to search for the file</span>
    <span class="token directive"><span class="token keyword">root</span> /data/www</span><span class="token punctuation">;</span>

    <span class="token comment"># Disable logging of errors related to file existence</span>
    <span class="token directive"><span class="token keyword">open_file_cache_errors</span> <span class="token boolean">off</span></span><span class="token punctuation">;</span>

    <span class="token comment"># Make an internal redirect if the file is not found</span>
    <span class="token directive"><span class="token keyword">error_page</span> <span class="token number">404</span> = /fetch<span class="token variable">$uri</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">location</span> /fetch/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend/</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="root-directory-and-index-files-根目录和索引文件"><a class="header-anchor" href="#root-directory-and-index-files-根目录和索引文件" aria-hidden="true">#</a> Root Directory and Index Files(根目录和索引文件)</h3><p><code>root</code>指令指定用于搜索文件的根目录，该指令可以放置在 <code>http {}</code>、<code>server {}</code>或 <code>location {}</code>上下文中的任何级别上</p><div class="language-nginx"><pre><code><span class="token comment"># 在这里，NGINX 在文件系统中的/www/data/images/目录中搜索以/images/开头的 URI。但是如果 URI 以.Mp3或.Mp4扩展名，NGINX 将在/www/media/目录中搜索文件，因为它是在匹配的位置块中定义的。</span>
<span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">root</span> /www/data</span><span class="token punctuation">;</span>

  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">root</span> /data</span><span class="token punctuation">;</span>
    <span class="token comment"># 按照指定的顺序搜索文件并返回它找到的第一个文件</span>
    <span class="token comment"># 这里使用的 $geo 变量是通过 geo 指令设置的自定义变量。变量的值取决于客户端的 IP 地址。</span>
    <span class="token directive"><span class="token keyword">index</span> index.<span class="token variable">$geo</span>.html index.htm index.html</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">location</span> /images/</span> <span class="token punctuation">{</span>
    <span class="token comment"># 返回一个自动生成的目录列表</span>
    <span class="token directive"><span class="token keyword">autoindex</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token directive"><span class="token keyword">location</span> ~ \.(mp3|mp4)</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">root</span> /www/media</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment"># 在这里，如果请求中的 URI 为/path/，并且/data/path/index. html 不存在，但是/data/path/index.php 存在，则内部重定向到/path/index.php 将映射到第二个位置。因此，请求被代理。</span>
  <span class="token directive"><span class="token keyword">location</span> ~ \.php</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">fastcgi_pass</span> localhost:8000</span><span class="token punctuation">;</span>
    <span class="token comment">#...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="trying-several-options-尝试几种选择"><a class="header-anchor" href="#trying-several-options-尝试几种选择" aria-hidden="true">#</a> Trying Several Options (尝试几种选择)</h3><p>可以使用 <code>try_files</code> 指令检查指定的文件或目录是否存在; 如果存在，NGINX 将进行内部重定向; 如果不存在，则返回指定的状态代码。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">root</span> /www/data</span><span class="token punctuation">;</span>

  <span class="token comment"># 最后一个参数也可以是状态码(前面直接有等号)或位置的名称。在下面的示例中，如果 try _ files 指令的所有参数都没有解析为现有文件或目录，则返回404错误。</span>
  <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">try_files</span> <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ <span class="token variable">$uri</span>.html =404</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment"># 该文件以 URI 的形式指定，使用当前位置或虚拟服务器上下文中设置的根指令或别名指令处理该文件。在这种情况下，如果与原始 URI 对应的文件不存在，NGINX 将内部重定向到最后一个参数指定的 URI，返回/www/data/images/default.gif。</span>
  <span class="token directive"><span class="token keyword">location</span> /images/</span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">try_files</span> <span class="token variable">$uri</span> /images/default.gif</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果原始 URI 和带有斜杠解析符的 URI 都没有被引导到现有的文件或目录中，那么请求就会被重定向到指定的位置，然后被传递到一个代理服务器。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">try_files</span> <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ @backend</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token directive"><span class="token keyword">location</span> @backend</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://backend.example.com</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="passing-request-headers"><a class="header-anchor" href="#passing-request-headers" aria-hidden="true">#</a> Passing Request Headers</h3><p>默认情况下，NGINX 在代理请求中重新定义两个头字段，“ Host”和“ Connection”，并消除值为空字符串的头字段。“ Host”设置为 $proxy _ Host 变量，“ Connection”设置为 close。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
  <span class="token comment"># 在这种配置中，“ Host”字段设置为 $Host 变量。</span>
  <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://localhost:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 为了防止头字段被传递给代理服务器，将其设置为空字符串，如下所示:</span>
<span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_set_header</span> Accept-Encoding <span class="token string">&quot;&quot;</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://localhost:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="configuring-buffers-配置缓冲区"><a class="header-anchor" href="#configuring-buffers-配置缓冲区" aria-hidden="true">#</a> Configuring Buffers(配置缓冲区)</h3><p>默认情况下，NGINX 缓冲区响应来自代理服务器。响应存储在内部缓冲区中，在收到整个响应之前不会发送到客户机。缓冲区有助于优化缓慢客户机的性能，如果响应同步地从 NGINX 传递到客户机，则会浪费代理服务器的时间。然而，当缓冲启用 NGINX 时，代理服务器可以快速处理响应，而 NGINX 将响应存储的时间与客户端下载响应所需的时间一样长。</p><p>负责启用和禁用缓冲的指令是 proxy _ buffering。默认情况下，它设置为 on 并启用缓冲。</p><p><code>Proxy_buffers</code> 指令控制为请求分配的缓冲区的数量和大小。来自代理服务器的响应的第一部分存储在一个单独的缓冲区中，其大小由 <code>proxy_buffer_size</code> 指令设置。</p><div class="language-nginx"><pre><code><span class="token comment"># 在下面的示例中，增加了缓冲区的默认数量，并且响应的第一部分的缓冲区的大小小于默认值。</span>
<span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_buffers</span> <span class="token number">16</span> <span class="token number">4k</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">proxy_buffer_size</span> <span class="token number">2k</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://localhost:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 若要在特定位置禁用缓冲，请将 proxy _ buffering 指令放在带有 off 参数的位置，如下所示:</span>
<span class="token directive"><span class="token keyword">location</span> /some/path/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_buffering</span> <span class="token boolean">off</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://localhost:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="choosing-an-outgoing-ip-address-选择传出-ip-地址"><a class="header-anchor" href="#choosing-an-outgoing-ip-address-选择传出-ip-地址" aria-hidden="true">#</a> Choosing an Outgoing IP Address(选择传出 IP 地址)</h3><p>如果您的代理服务器有多个网络接口，有时您可能需要选择一个特定的源 IP 地址来连接到代理服务器或上行服务器。如果 NGINX 后面的代理服务器配置为接受来自特定 IP 网络或 IP 地址范围的连接，这可能会很有用。</p><div class="language-nginx"><pre><code><span class="token comment"># 指定 proxy _ bind 指令和必要网络接口的 IP 地址:</span>
<span class="token directive"><span class="token keyword">location</span> /app1/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_bind</span> 127.0.0.1</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://example.com/app1/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token directive"><span class="token keyword">location</span> /app2/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_bind</span> 127.0.0.2</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://example.com/app2/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 还可以用变量指定 IP 地址。例如，$server _ addr 变量传递接受请求的网络接口的 IP 地址:</span>
<span class="token directive"><span class="token keyword">location</span> /app3/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">proxy_bind</span> <span class="token variable">$server_addr</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">proxy_pass</span> http://example.com/app3/</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="enabling-compression-启用压缩功能"><a class="header-anchor" href="#enabling-compression-启用压缩功能" aria-hidden="true">#</a> Enabling Compression(启用压缩功能)</h3><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">gzip</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>

<span class="token comment"># 默认情况下，NGINX 只使用 text/html 的 MIME 类型压缩响应。要使用其他 MIME 类型压缩响应，请包含 gzip _ types 指令并列出其他类型。</span>
<span class="token directive"><span class="token keyword">gzip_types</span> text/plain application/xml</span><span class="token punctuation">;</span>

<span class="token comment"># 若要指定要压缩的响应的最小长度，请使用 gzip _ min _ length 指令。默认值是20字节(这里调整为1000) :</span>
<span class="token directive"><span class="token keyword">gzip_min_length</span> <span class="token number">1000</span></span><span class="token punctuation">;</span>
</code></pre></div><p>默认情况下，NGINX 不压缩对代理请求(来自代理服务器的请求)的响应。请求来自代理服务器的事实取决于请求中 <code>Via</code> 头字段的存在。要配置这些响应的压缩，请使用 <code>gzip_proxied</code> 指令。该指令有许多参数指定 NGINX 应该压缩哪些类型的代理请求。例如，只对不会在代理服务器上缓存的请求压缩响应是合理的。为此，<code>gzip_proxied</code> 指令具有一些参数，这些参数指示 NGINX 在响应中检查 <code>Cache-Control</code> 头字段，如果值为无缓存、无存储或私有，则压缩该响应。此外，必须包含过期参数才能检查 <code>Expires</code> 头字段的值。这些参数在下面的示例中设置，以及 <code>auth</code> 参数，该参数检查 <code>Authorization header</code> 字段的存在(授权响应特定于最终用户，通常不会被缓存) :</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">gzip_proxied</span> no-cache no-store private expired auth</span><span class="token punctuation">;</span>
</code></pre></div><p>与大多数其他指令一样，用于配置压缩的指令可以包含在 <code>http</code> 上下文中，也可以包含在<code>server</code>或<code>location</code>配置块中。</p><h3 id="enabling-decompression-启用解压缩"><a class="header-anchor" href="#enabling-decompression-启用解压缩" aria-hidden="true">#</a> Enabling Decompression(启用解压缩)</h3><p>有些客户端不支持 gzip 编码方法的响应。同时，可能希望存储压缩数据，或动态压缩响应并将其存储在缓存中。为了成功地为接受压缩数据和不接受压缩数据的客户机提供服务，NGINX 可以在将数据发送到后一种类型的客户机时动态地对数据进行解压缩。</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">location</span> /storage/</span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">gunzip</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">gzip_min_length</span> <span class="token number">1000</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">gunzip</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>
  ...
<span class="token punctuation">}</span>
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">注意</p><p>请注意，这个指令是在一个单独的模块中定义的，默认情况下 NGINX 开放源码构建中可能不包含这个模块。</p></div><h2 id="security-controls"><a class="header-anchor" href="#security-controls" aria-hidden="true">#</a> Security Controls</h2><h3 id="setting-up-an-https-server"><a class="header-anchor" href="#setting-up-an-https-server" aria-hidden="true">#</a> Setting up an HTTPS Server</h3><p>要建立一个 HTTPS 服务器，在 nginx.conf 文件中包含服务器块中 listen 指令的 ssl 参数，然后指定服务器证书和私钥文件的位置:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span>              <span class="token number">443</span> ssl</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server_name</span>         www.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_certificate</span>     www.example.com.crt</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_certificate_key</span> www.example.com.key</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_protocols</span>       TLSv1 TLSv1.1 TLSv1.2</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_ciphers</span>         HIGH:!aNULL:!MD5</span><span class="token punctuation">;</span>
  <span class="token comment">#使用 ssl_protocols和 ssl_ciphers指令要求客户端在建立连接时只使用 SSL/TLS 的强版本和加密器。</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="ocsp-validation-of-client-certificates-客户端证书的-ocsp-验证"><a class="header-anchor" href="#ocsp-validation-of-client-certificates-客户端证书的-ocsp-验证" aria-hidden="true">#</a> OCSP Validation of Client Certificates(客户端证书的 OCSP 验证)</h3><p>NGINX 可以配置为使用联机证书状态协议(Online Certificate Status Protocol，OCSP)来检查呈现的 x. 509客户机证书的有效性。一个关于客户端证书状态的 OCSP 请求被发送到一个 OCSP 响应器，该响应器检查证书的有效性并返回带有证书状态的响应:</p><ul><li><code>Good</code> - the certificate is not revoked - 证书不会被撤销</li><li><code>Revoked</code> - the certificate is revoked - 证书被撤销</li><li><code>Unknown</code> - no information is available about the client certificate - 没有有关客户端证书的资料</li></ul><p>要启用 SSL 客户端证书的 OCSP 验证，请指定 <code>SSL_OCSP</code> 指令以及 <code>SSL_verify_client</code> 指令，这将启用证书验证:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">443</span> ssl</span><span class="token punctuation">;</span>

  <span class="token directive"><span class="token keyword">ssl_certificate</span>     /etc/ssl/foo.example.com.crt</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_certificate_key</span> /etc/ssl/foo.example.com.key</span><span class="token punctuation">;</span>

  <span class="token directive"><span class="token keyword">ssl_verify_client</span>       <span class="token boolean">on</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_trusted_certificate</span> /etc/ssl/cachain.pem</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_ocsp</span>                <span class="token boolean">on</span></span><span class="token punctuation">;</span> <span class="token comment"># Enable OCSP validation</span>

  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="https-server-optimization-服务器优化"><a class="header-anchor" href="#https-server-optimization-服务器优化" aria-hidden="true">#</a> HTTPS Server Optimization(服务器优化)</h3><p>会话存储在工作进程之间共享的 SSL 会话缓存中，并由 <code>SSL_session_cache</code> 指令进行配置。一兆字节的高速缓存包含大约4000个会话。默认的缓存超时时间为5分钟。这个超时可以使用 <code>ssl_session_timeout</code> 指令来增加。下面是一个为10mb 共享会话缓存的多核系统优化的示例配置:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">worker_processes</span> auto</span><span class="token punctuation">;</span>

<span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">ssl_session_cache</span>   shared:SSL:10m</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_session_timeout</span> <span class="token number">10m</span></span><span class="token punctuation">;</span>

  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">listen</span>              <span class="token number">443</span> ssl</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server_name</span>         www.example.com</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">keepalive_timeout</span>   <span class="token number">70</span></span><span class="token punctuation">;</span>

    <span class="token directive"><span class="token keyword">ssl_certificate</span>     www.example.com.crt</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">ssl_certificate_key</span> www.example.com.key</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">ssl_protocols</span>       TLSv1 TLSv1.1 TLSv1.2</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">ssl_ciphers</span>         HIGH:!aNULL:!MD5</span><span class="token punctuation">;</span>
    <span class="token comment">#...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="ssl-certificate-chains-ssl-证书链"><a class="header-anchor" href="#ssl-certificate-chains-ssl-证书链" aria-hidden="true">#</a> SSL Certificate Chains(SSL 证书链)</h3><p>有些浏览器可能会抱怨由知名证书颁发机构签署的证书，而其他浏览器则可能毫无问题地接受该证书。发生这种情况的原因是，发出证书的机构已经使用中间证书对服务器证书进行了签名，而中间证书并不存在于众所周知的可信证书机构的基础中，这些可信证书机构分布在特定的浏览器中。在这种情况下，中心提供了一个链接证书包，它应该连接到签名的服务器证书。服务器证书必须出现在合并文件中的链接证书之前:</p><div class="language-bash"><pre><code><span class="token function">cat</span> www.example.com.crt bundle.crt <span class="token operator">&gt;</span> www.example.com.chained.crt
</code></pre></div><p>结果文件应该在 <code>ssl_certificate</code> 指令中使用:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span>              <span class="token number">443</span> ssl</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server_name</span>         www.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_certificate</span>     www.example.com.chained.crt</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_certificate_key</span> www.example.com.key</span><span class="token punctuation">;</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>浏览器通常存储它们接收并由受信任的授权机构签名的中间证书。因此，主动使用的浏览器可能已经具有所需的中间证书，并且可能不会抱怨发送的证书没有链接包。为了确保服务器发送完整的证书链，可以使用 openssl 命令行工具:</p><div class="language-bash"><pre><code>openssl s_client -connect www.godaddy.com:443
<span class="token punctuation">..</span>.
Certificate chain
 <span class="token number">0</span> s:/C<span class="token operator">=</span>US/ST<span class="token operator">=</span>Arizona/L<span class="token operator">=</span>Scottsdale/1.3.6.1.4.1.311.60.2.1.3<span class="token operator">=</span>US
     /1.3.6.1.4.1.311.60.2.1.2<span class="token operator">=</span>AZ/O<span class="token operator">=</span>GoDaddy.com, Inc
     /OU<span class="token operator">=</span>MIS Department/CN<span class="token operator">=</span>www.GoDaddy.com
     /serialNumber<span class="token operator">=</span>0796928-7/2.5.4.15<span class="token operator">=</span>V1.0, Clause <span class="token number">5</span>.<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
   i:/C<span class="token operator">=</span>US/ST<span class="token operator">=</span>Arizona/L<span class="token operator">=</span>Scottsdale/O<span class="token operator">=</span>GoDaddy.com, Inc.
     /OU<span class="token operator">=</span>http://certificates.godaddy.com/repository
     /CN<span class="token operator">=</span>Go Daddy Secure Certification Authority
     /serialNumber<span class="token operator">=</span>07969287
 <span class="token number">1</span> s:/C<span class="token operator">=</span>US/ST<span class="token operator">=</span>Arizona/L<span class="token operator">=</span>Scottsdale/O<span class="token operator">=</span>GoDaddy.com, Inc.
     /OU<span class="token operator">=</span>http://certificates.godaddy.com/repository
     /CN<span class="token operator">=</span>Go Daddy Secure Certification Authority
     /serialNumber<span class="token operator">=</span>07969287
   i:/C<span class="token operator">=</span>US/O<span class="token operator">=</span>The Go Daddy Group, Inc.
     /OU<span class="token operator">=</span>Go Daddy Class <span class="token number">2</span> Certification Authority
 <span class="token number">2</span> s:/C<span class="token operator">=</span>US/O<span class="token operator">=</span>The Go Daddy Group, Inc.
     /OU<span class="token operator">=</span>Go Daddy Class <span class="token number">2</span> Certification Authority
   i:/L<span class="token operator">=</span>ValiCert Validation Network/O<span class="token operator">=</span>ValiCert, Inc.
     /OU<span class="token operator">=</span>ValiCert Class <span class="token number">2</span> Policy Validation Authority
     /CN<span class="token operator">=</span>http://www.valicert.com//emailAddress<span class="token operator">=</span>info@valicert.com
<span class="token punctuation">..</span>.
</code></pre></div><p>在这个示例中，www.godaddy. com 服务器证书 # 0的主题(“ s”)由发行者(“ i”)签名，而发行者本身就是证书 # 1的主题。Certificate # 1由发行人签署，发行人本身也是 Certificate # 2的主体。但是，这个证书是由著名的颁发者 ValiCert，inc. 签署的，该公司的证书存储在浏览器本身中。</p><h3 id="a-single-http-https-server"><a class="header-anchor" href="#a-single-http-https-server" aria-hidden="true">#</a> A Single HTTP/HTTPS Server</h3><p>通过在同一个虚拟服务器中放置一个带 ssl 参数的 listen 指令和一个不带 ssl 参数的 listen 指令，可以配置一个同时处理 HTTP 和 HTTPS 请求的服务器:</p><div class="language-nginx"><pre><code><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
  <span class="token directive"><span class="token keyword">listen</span>              <span class="token number">80</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">listen</span>              <span class="token number">443</span> ssl</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server_name</span>         www.example.com</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_certificate</span>     www.example.com.crt</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">ssl_certificate_key</span> www.example.com.key</span><span class="token punctuation">;</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><p><a href="https://github.com/digitalocean/nginxconfig.io" target="_blank" rel="noopener noreferrer">可视化配置 nginx 提供了多个基础模板</a></p></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><a class="link" href="https://github.com/QiYoe/c-blog/edit/master/docs/front-end/linux/nginx.md" target="_blank" rel="noopener noreferrer" data-v-1ed99556>在 GitHub 上编辑此页 <svg class="icon outbound icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-1ed99556><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="updated" data-v-fb8d84c6><p class="last-updated" data-v-fb8d84c6 data-v-5797b537><span class="prefix" data-v-5797b537>最新更新时间:</span><span class="datetime" data-v-5797b537></span></p></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/front-end/linux/" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>Linux启动Nginx服务</span></a></div><div class="next" data-v-38ede35f><a class="link" href="/front-end/linux/docker" data-v-38ede35f><span class="text" data-v-38ede35f>Docker</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"8376b327\",\"algorithm_index.md\":\"a709c586\",\"algorithm_leetcode.md\":\"f9949b43\",\"algorithm_lodash.md\":\"9d0e2b89\",\"books_css-secrets.md\":\"37a968e7\",\"books_docker-practice.md\":\"1e6482fe\",\"books_grokking-algorithms.md\":\"b46b11f6\",\"books_index.md\":\"eb308233\",\"books_js-advice.md\":\"1b0b63a0\",\"books_pro-git.md\":\"0ac73fcd\",\"books_you-dont-know-js.md\":\"ef9b6543\",\"devops_index.md\":\"4297ce66\",\"devops_jira.md\":\"3fbf2c51\",\"front-end_index.md\":\"59ea0a1d\",\"other_30-seconds-of-code.md\":\"827459dc\",\"other_computer-tech.md\":\"ea19708b\",\"other_index.md\":\"e6fe4877\",\"other_smart-tools.md\":\"f63ff67e\",\"other_vanillawebprojects.md\":\"2b4b75fe\",\"quotations_index.md\":\"2821ca30\",\"front-end_ast_index.md\":\"526922de\",\"front-end_blog-build_aliyun-domin.md\":\"4fb0807e\",\"front-end_blog-build_baidu-include.md\":\"faf0b3d8\",\"front-end_blog-build_index.md\":\"07734941\",\"front-end_blog-build_seo-optimize.md\":\"157fc77a\",\"front-end_git_advance.md\":\"289c30dc\",\"front-end_git_flight-rules.md\":\"ab1e80d4\",\"front-end_git_index.md\":\"0334037b\",\"front-end_linux_docker.md\":\"e37ca1b9\",\"front-end_linux_index.md\":\"dbce420f\",\"front-end_linux_nginx.md\":\"95e1ef2b\",\"front-end_swagger-hub_curl.md\":\"f3f495d0\",\"front-end_swagger-hub_index.md\":\"a8db9f4d\",\"front-end_vue_axios.md\":\"e696f4b8\",\"front-end_vue_index.md\":\"4650b396\",\"front-end_vue_nuxt.md\":\"9cebe5c2\",\"front-end_vue_sass.md\":\"adab2ef2\",\"front-end_vue_typescript.md\":\"9bd22788\",\"front-end_vue_vite.md\":\"8fa5e7d2\",\"front-end_vue_vue-router.md\":\"d1ebe64f\",\"front-end_web-container_index.md\":\"8d4d4ecb\",\"front-end_websocket_index.md\":\"cb70ff72\"}")</script>
    <script type="module" async src="/assets/app.f03f2116.js"></script>
  </body>
</html>