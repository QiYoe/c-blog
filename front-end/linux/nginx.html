<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>
      Nginx配置详解 | 南上康青山
    </title>
    <meta name="description" content="Nginx配置详解">
    <link rel="stylesheet" href="/assets/style.3d4e16a3.css">
    <link rel="modulepreload" href="/assets/Home.7d117cba.js">
    <link rel="modulepreload" href="/assets/app.7412c22e.js">
    <link rel="modulepreload" href="/assets/front-end_linux_nginx.md.2da67810.lean.js">
    <link rel="modulepreload" href="/assets/app.7412c22e.js">
    <link rel="image/x-icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="keywords" content="南上康青山, vitepress, 顾青山, blog, 博客, 狗窝, 青山">
    <meta name="baidu-site-verification" content="code-5BMDhSDgSq">
    <meta name="baidu_union_verify" content="acd0eb90461e19817cabd1140c8ffd54">
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1801e4a45f1eecdfe603fc0637120c56";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);

      // 引入谷歌,不需要可删除这段
      var hm1 = document.createElement("script");
      hm1.src = "https://www.googletagmanager.com/gtag/js?id=G-SBNLNM3Q41";
      var s1 = document.getElementsByTagName("script")[0]; 
      s1.parentNode.insertBefore(hm1, s1);
    })();

    // 谷歌加载,不需要可删除
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-SBNLNM3Q41');
  </script>
    <meta name="keywords" content="Linux Ubuntu CentOS Nginx Nginx配置">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-5df6160f><div class="sidebar-button" data-v-5df6160f><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="南上康青山, back to home" data-v-5df6160f data-v-8dbfef3c><!----> 南上康青山</a><div class="flex-grow" data-v-5df6160f></div><div class="nav" data-v-5df6160f><nav class="nav-links" data-v-5df6160f data-v-38e3b123><!--[--><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item" href="/" data-v-45eb32c6>首页 <!----></a></div></div><div class="item" data-v-38e3b123><div class="nav-dropdown-link" data-v-38e3b123 data-v-6bbf01f6><button class="button" aria-label="前端" data-v-6bbf01f6><span class="button-text" data-v-6bbf01f6>前端</span><span class="right button-arrow" data-v-6bbf01f6></span></button><ul class="dialog" data-v-6bbf01f6><!--[--><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/front-end/blog-build/vitepress-build" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>博客相关</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/front-end/swagger-hub/" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>SwaggerHub</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item active" href="/front-end/linux/" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>Linux相关</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/front-end/vue/" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>Vue</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/front-end/web-container/" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>WebContainer</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-38e3b123><div class="nav-dropdown-link" data-v-38e3b123 data-v-6bbf01f6><button class="button" aria-label="书籍" data-v-6bbf01f6><span class="button-text" data-v-6bbf01f6>书籍</span><span class="right button-arrow" data-v-6bbf01f6></span></button><ul class="dialog" data-v-6bbf01f6><!--[--><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/books/you-dont-know-js" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>你不知道的JavaScript</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-38e3b123><div class="nav-dropdown-link" data-v-38e3b123 data-v-6bbf01f6><button class="button" aria-label="算法" data-v-6bbf01f6><span class="button-text" data-v-6bbf01f6>算法</span><span class="right button-arrow" data-v-6bbf01f6></span></button><ul class="dialog" data-v-6bbf01f6><!--[--><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/algorithm/leetcode" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>LeetCode</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item" href="/tools/smart-tools" aria-label="工具" data-v-45eb32c6>工具 <!----></a></div></div><!--]--><!----><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item isExternal" href="https://github.com/QiYoe/c-blog" target="_blank" rel="noopener noreferrer" data-v-45eb32c6>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-45eb32c6><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-58e261f2><nav class="nav-links nav" data-v-58e261f2 data-v-38e3b123><!--[--><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item" href="/" data-v-45eb32c6>首页 <!----></a></div></div><div class="item" data-v-38e3b123><div class="nav-dropdown-link" data-v-38e3b123 data-v-6bbf01f6><button class="button" aria-label="前端" data-v-6bbf01f6><span class="button-text" data-v-6bbf01f6>前端</span><span class="right button-arrow" data-v-6bbf01f6></span></button><ul class="dialog" data-v-6bbf01f6><!--[--><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/front-end/blog-build/vitepress-build" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>博客相关</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/front-end/swagger-hub/" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>SwaggerHub</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item active" href="/front-end/linux/" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>Linux相关</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/front-end/vue/" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>Vue</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/front-end/web-container/" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>WebContainer</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-38e3b123><div class="nav-dropdown-link" data-v-38e3b123 data-v-6bbf01f6><button class="button" aria-label="书籍" data-v-6bbf01f6><span class="button-text" data-v-6bbf01f6>书籍</span><span class="right button-arrow" data-v-6bbf01f6></span></button><ul class="dialog" data-v-6bbf01f6><!--[--><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/books/you-dont-know-js" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>你不知道的JavaScript</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-38e3b123><div class="nav-dropdown-link" data-v-38e3b123 data-v-6bbf01f6><button class="button" aria-label="算法" data-v-6bbf01f6><span class="button-text" data-v-6bbf01f6>算法</span><span class="right button-arrow" data-v-6bbf01f6></span></button><ul class="dialog" data-v-6bbf01f6><!--[--><li class="dialog-item" data-v-6bbf01f6><div class="nav-dropdown-link-item" data-v-6bbf01f6 data-v-d552fd76><a class="item" href="/algorithm/leetcode" data-v-d552fd76><span class="arrow" data-v-d552fd76></span><span class="text" data-v-d552fd76>LeetCode</span><span class="icon" data-v-d552fd76><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item" href="/tools/smart-tools" aria-label="工具" data-v-45eb32c6>工具 <!----></a></div></div><!--]--><!----><div class="item" data-v-38e3b123><div class="nav-link" data-v-38e3b123 data-v-45eb32c6><a class="item isExternal" href="https://github.com/QiYoe/c-blog" target="_blank" rel="noopener noreferrer" data-v-45eb32c6>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-45eb32c6><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-58e261f2><!--[--><li class="sidebar-link"><p class="sidebar-link-item">博客相关</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/blog-build/vitepress-build">博客搭建</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/blog-build/baidu-include">百度收录</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/blog-build/seo-optimize">SEO优化</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/blog-build/aliyun-domin">阿里云域名</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">SwaggerHub</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/swagger-hub/">SwaggerHub使用教程</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">Linux相关</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/linux/">Linux启动Nginx服务</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/front-end/linux/nginx">Nginx</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#为什么nginx？">为什么Nginx？</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#安装">安装</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#centos（安装nginx预生成包版）">CentOS（安装nginx预生成包版）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#ubuntu（安装nginx预生成包版）">Ubuntu（安装nginx预生成包版）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）">从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#在docker上部署nginx">在Docker上部署NGINX</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#在docker上运行nginx">在Docker上运行NGINX</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#管理内容和配置文件">管理内容和配置文件</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#管理日志">管理日志</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#控制-nginx">控制 NGINX</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#基本功能">基本功能</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#master-and-worker-processes">Master and Worker Processes</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#控制-nginx-命令">控制 NGINX 命令</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#创建-nginx-配置文件">创建 NGINX 配置文件</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#http-load-balancing（负载均衡）">HTTP Load Balancing（负载均衡）</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#overview（概览）">Overview（概览）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#proxying-http-traffic-to-a-group-of-servers">Proxying HTTP Traffic to a Group of Servers</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#选择负载平衡方法">选择负载平衡方法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#server-weights">Server Weights</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tcp-and-udp-load-balancing">TCP and UDP Load Balancing</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#配置反向代理">配置反向代理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#configuring-tcp-or-udp-load-balancing">Configuring TCP or UDP Load Balancing</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#example-of-tcp-and-udp-load-balancing-configuration">Example of TCP and UDP Load-Balancing Configuration</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#http-health-checks">HTTP Health Checks</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#introduction">Introduction</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#passive-health-checks（被动健康检查）">Passive Health Checks（被动健康检查）</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#tcp-health-checks">TCP Health Checks</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#udp-health-checks">UDP Health Checks</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#读取静态文件">读取静态文件</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#设置一个简单的代理服务器">设置一个简单的代理服务器</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/linux/docker">Docker</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">Vue</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/">Vue3学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/axios">Axios学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/vue-router">VueRouter学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/typescript">TS学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/vite">Vite学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/nuxt">Nuxt学习笔记</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/vue/sass">Sass学习笔记</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">WebContainer</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/front-end/web-container/">webContainer详解</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-d36a7fda><div class="container" data-v-d36a7fda><!--[--><!--]--><div class="content" data-v-d36a7fda><div data-v-d36a7fda><h2 id="为什么nginx？"><a class="header-anchor" href="#为什么nginx？" aria-hidden="true">#</a> 为什么Nginx？</h2><p><a href="http://nginx.org/en/" target="_blank" rel="noopener noreferrer">Nginx官网</a></p><p><a href="https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/" target="_blank" rel="noopener noreferrer">Nginx文档官网</a></p><p>官方版：Nginx时轻量级Web服务器，它不仅时一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POPS/SMTP代理服务器。</p><p>通俗版：轻量、简单、流行</p><h2 id="安装"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h2><h3 id="centos（安装nginx预生成包版）"><a class="header-anchor" href="#centos（安装nginx预生成包版）" aria-hidden="true">#</a> CentOS（安装nginx预生成包版）</h3><p>两种安装方式：</p><ul><li>Installing a Prebuilt CentOS/RHEL Package from an OS Repository（使用yum更新源安装）</li></ul><div class="language-bash"><pre><code><span class="token comment"># 安装 EPEL 存储库</span>
<span class="token function">sudo</span> yum <span class="token function">install</span> epel-release

<span class="token comment"># 更新存储库</span>
<span class="token function">sudo</span> yum update

<span class="token comment"># 安装 NGINX 开放源码</span>
<span class="token function">sudo</span> yum <span class="token function">install</span> nginx

<span class="token comment"># 验证安装</span>
<span class="token function">sudo</span> nginx -v
</code></pre></div><ul><li>Installing a Prebuilt CentOS/RHEL Package from the Official NGINX Repository（源码直接编译之后安装）</li></ul><div class="language-bash"><pre><code><span class="token comment"># 通过在/etc/yum.repop.d 中创建 nginx.repo 文件，为 CentOS 设置 yum 存储库，例如使用 vi</span>
<span class="token function">sudo</span> <span class="token function">vi</span> /etc/yum.repos.d/nginx.repo

<span class="token comment"># 在 nginx.repo 中添加以下行</span>
<span class="token punctuation">[</span>nginx<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>nginx repo
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>https://nginx.org/packages/mainline/centos/7/<span class="token variable">$basearch</span>/
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>

<span class="token comment"># 保存更改并退出 vi (按 ESC 并在提示符处:键入 wq)</span>

<span class="token comment"># 更新存储库</span>
<span class="token function">sudo</span> yum update

<span class="token comment"># 启动NGINX</span>
<span class="token function">sudo</span> nginx

<span class="token comment"># 确认 NGINX 开放源码已经启动并运行</span>
<span class="token function">curl</span> -I <span class="token number">127.0</span>.0.1
</code></pre></div><h3 id="ubuntu（安装nginx预生成包版）"><a class="header-anchor" href="#ubuntu（安装nginx预生成包版）" aria-hidden="true">#</a> Ubuntu（安装nginx预生成包版）</h3><p>两种安装方式：</p><ul><li>Installing a Prebuilt Ubuntu Package from an Ubuntu Repository（使用apt-get更新源安装）</li></ul><div class="language-bash"><pre><code><span class="token comment"># 更新 Ubuntu 存储库</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> update

<span class="token comment"># 安装软件包</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> nginx

<span class="token comment"># 验证安装</span>
<span class="token function">sudo</span> nginx -v
</code></pre></div><ul><li>Installing a Prebuilt Ubuntu Package from the Official NGINX Repository（源码直接编译之后安装）</li></ul><p>要为稳定版 nginx 包设置合适的存储库，运行以下命令：</p><div class="language-bash"><pre><code><span class="token comment"># 下载用于签署 NGINX 包和存储库的密钥，并将其添加到 apt 程序的密钥环</span>
<span class="token function">sudo</span> <span class="token function">wget</span> https://nginx.org/keys/nginx_signing.key
<span class="token function">sudo</span> apt-key <span class="token function">add</span> nginx_signing.key

<span class="token comment"># 编辑/etc/apt/source.list 文件，例如使用 vi</span>
<span class="token function">sudo</span> <span class="token function">vi</span> /etc/apt/sources.list

<span class="token comment"># 添加这些行 Source.list 来命名可以获得 NGINX 开放源码的存储库</span>
deb https://nginx.org/packages/mainline/ubuntu/ trusty nginx
deb-src https://nginx.org/packages/mainline/ubuntu/ trusty nginx

<span class="token comment"># 保存更改并退出 vi (按 ESC 并在提示符处:键入 wq)</span>

<span class="token comment"># 安装 NGINX 开放源码</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> nginx

<span class="token comment"># 启动 NGINX</span>
<span class="token function">sudo</span> nginx

<span class="token comment"># 确认 NGINX 开放源码已经启动并运行</span>
<span class="token function">curl</span> -I <span class="token number">127.0</span>.0.1
</code></pre></div><h3 id="从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）"><a class="header-anchor" href="#从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）" aria-hidden="true">#</a> 从源代码编译和安装（更灵活，安装操作也更繁琐，但后面使用非常便利）</h3><div class="language-bash"><pre><code><span class="token comment"># 安装依赖库</span>

<span class="token comment">## PCRE-支持 NGINX 核心和重写模块所需的正则表达式</span>
<span class="token function">wget</span> ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.44.tar.gz
<span class="token function">tar</span> -zxf pcre-8.44.tar.gz
<span class="token builtin class-name">cd</span> pcre-8.44
./configure
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment">## Zlib-支持头部压缩。 NGINX Gzip 模块要求</span>
<span class="token function">wget</span> http://zlib.net/zlib-1.2.11.tar.gz
<span class="token function">tar</span> -zxf zlib-1.2.11.tar.gz
<span class="token builtin class-name">cd</span> zlib-1.2.11
./configure
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment">## OpenSSL-支持 HTTPS 协议。 NGINX SSL 模块和其他模块要求的</span>
<span class="token function">wget</span> http://www.openssl.org/source/openssl-1.1.1g.tar.gz
<span class="token function">tar</span> -zxf openssl-1.1.1g.tar.gz
<span class="token builtin class-name">cd</span> openssl-1.1.1g
./Configure darwin64-x86_64-cc --prefix<span class="token operator">=</span>/usr
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># 下载NGINX源码</span>
<span class="token function">wget</span> https://nginx.org/download/nginx-1.19.0.tar.gz
<span class="token function">tar</span> zxf nginx-1.19.0.tar.gz
<span class="token builtin class-name">cd</span> nginx-1.19.0

<span class="token comment"># 配置构建选项</span>
./configure
--sbin-path<span class="token operator">=</span>/usr/local/nginx/nginx
--conf-path<span class="token operator">=</span>/usr/local/nginx/nginx.conf
--pid-path<span class="token operator">=</span>/usr/local/nginx/nginx.pid
--with-pcre<span class="token operator">=</span><span class="token punctuation">..</span>/pcre-8.44
--with-zlib<span class="token operator">=</span><span class="token punctuation">..</span>/zlib-1.2.11
--with-http_ssl_module
--with-stream
--with-mail<span class="token operator">=</span>dynamic
--add-module<span class="token operator">=</span>/usr/build/nginx-rtmp-module
--add-dynamic-module<span class="token operator">=</span>/usr/build/3party_module

<span class="token comment"># 编译并安装构建</span>
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># --prefix=&lt;PATH&gt; NGINX 文件的目录。默认值:/usr/local/nginx</span>
<span class="token comment"># --sbin-path=&lt;PATH&gt; 可执行文件的名称。仅在安装过程中使用。默认值:&lt;prefix&gt;/sbin/nginx</span>
<span class="token comment"># --conf-path=&lt;PATH&gt; NGINX 配置文件的名称。默认值:&lt;prefix&gt;conf/nginx.conf</span>
<span class="token comment"># --pid-path=&lt;PATH&gt; NGINX 进程ID文件。默认值:&lt;prefix&gt;/logs/nginx.pid</span>
<span class="token comment"># --with-pcre=&lt;PATH&gt; PCRE 库的源路径，该库需要在位置指令和重写模块中进行常规表达式支持。（支持location、rewrite功能）</span>
<span class="token comment"># --with-zlib=&lt;PATH&gt; zlib 库的源路径，支持Gzip模块</span>
<span class="token comment"># -- with-mail 启用邮件代理功能</span>
<span class="token comment"># -- with-mail=dynamic 启用邮件代理功能，将其编译为一个单独的动态模块</span>
<span class="token comment"># -- with-stream 开启TCP、UDP代理功能</span>
<span class="token comment"># -- with-stream=dynamic 开启TCP、UDP代理功能，将其编译为一个单独的动态模块</span>
<span class="token comment"># --with-http_ssl_module 支持HTTPS支持。需要SSL库，比如OpenSSL</span>
<span class="token comment"># --add-module=&lt;PATH&gt; 静态链接模块：在编译时构建在 NGINX 开源中，并静态链接到 NGINX 二进制文件</span>
<span class="token comment"># --add-dynamic-module=&lt;PATH&gt; 动态链接模块：运行时动态加载到 NGINX 开放源码</span>
<span class="token comment"># with对应without：禁用模块</span>

<span class="token comment"># 启动NGINX</span>
nginx
</code></pre></div><h2 id="在docker上部署nginx"><a class="header-anchor" href="#在docker上部署nginx" aria-hidden="true">#</a> 在Docker上部署NGINX</h2><h3 id="在docker上运行nginx"><a class="header-anchor" href="#在docker上运行nginx" aria-hidden="true">#</a> 在Docker上运行NGINX</h3><div class="language-bash"><pre><code><span class="token comment"># 启动运行在容器中的 NGINX 实例，使用缺省的 NGINX 配置，并执行以下命令</span>
docker run --name mynginx1 -p <span class="token number">80</span>:80 -d nginx
<span class="token comment"># mynginx1 是基于 NGINX 映像创建的容器的名称</span>
<span class="token comment"># -d 选项指定容器以分离模式运行: 容器继续运行，直到停止，但不响应命令行上运行的命令</span>
<span class="token comment"># -p 第一个参数指定 Docker 主机中的端口（nginx端口），第二个参数映射到容器中公开的端口（客户端端口）</span>
<span class="token comment"># 该命令返回容器 ID 的长格式: fcd1fb01b14557c7c9d991238f2558ae2704d129cf9fb97bb4fadf673a58580d。这种形式的 ID 用于日志文件的名称。</span>

<span class="token comment"># 验证容器是否已经创建并且正在使用</span>
docker <span class="token function">ps</span>
</code></pre></div><h3 id="管理内容和配置文件"><a class="header-anchor" href="#管理内容和配置文件" aria-hidden="true">#</a> 管理内容和配置文件</h3><ul><li>在Doker主机上维护内容和配置文件</li></ul><p>在创建容器时，可以将 Docker 主机上的本地目录挂载到容器中的目录中。NGINX 映像使用默认的 NGINX 配置，它使用/usr/share/NGINX/html 作为容器的根目录，并将配置文件放入/etc/NGINX 中。对于Docker主机内容在本地目录/var/www 中、配置文件在/var/nginx/conf 中的 Docker 主机，运行以下命令：</p><div class="language-bash"><pre><code>docker run --name mynginx2 --mount <span class="token assign-left variable">type</span><span class="token operator">=</span>bind,source<span class="token operator">=</span>/var/www,target<span class="token operator">=</span>/usr/share/nginx/html,readonly --mount <span class="token assign-left variable">source</span><span class="token operator">=</span>/var/nginx/conf,target<span class="token operator">=</span>/etc/nginx/conf,readonly -p <span class="token number">80</span>:80 -d nginx
</code></pre></div><p>对 Docker 主机上的本地目录/var/www 和/var/nginx/conf 中的文件所做的任何更改都反映在容器中的目录/usr/share/nginx/html 和/etc/nginx 中。Readonly 选项意味着只能在 Docker 主机上更改这些目录，而不能从容器内更改</p><ul><li>从 Docker 主机复制内容和配置文件</li></ul><p>在容器创建期间，Docker 可以从 Docker 主机上的本地目录复制内容和配置文件。一旦创建了一个容器，文件将通过在文件更改时创建一个新容器或通过修改容器中的文件来维护。</p><p>复制文件的一个简单方法是创建一个 Dockerfile，其中包含在基于 NGINX 映像生成新的 Docker 映像期间运行的命令。对于 Dockerfile 中的 file-COPY (COPY)命令，本地目录路径相对于 Dockerfile 所在的构建上下文。</p><p>假设内容目录是<code>content</code>，配置文件目录是 <code>conf</code>，这两个子目录都是 Dockerfile 所在的目录。NGINX 映像在<code>/etc/NGINX/conf.d</code> 目录中有缺省的 NGINX 配置文件，包括 <code>default.conf</code>。要只使用 Docker 主机上的配置文件，请使用 RUN 命令删除默认文件:</p><div class="language-bash"><pre><code>FROM nginx
RUN <span class="token function">rm</span> /etc/nginx/conf.d/default.conf
COPY content /usr/share/nginx/html
COPY conf /etc/nginx
</code></pre></div><p>通过在 Dockerfile 所在的目录中运行命令创建 NGINX 映像。句号(&quot;.&quot;)在命令的末尾将工作目录文件定义为构建上下文，其中包含 Dockerfile 和要复制的目录:</p><div class="language-bash"><pre><code>docker build -t mynginx_image1 <span class="token builtin class-name">.</span>
</code></pre></div><p>基于 mynginx image1映像创建一个容器 mynginx3:</p><div class="language-bash"><pre><code>docker run --name mynginx3 -p <span class="token number">80</span>:80 -d mynginx_image1
</code></pre></div><ul><li>在容器中维护内容和配置文件</li></ul><p>由于 SSH 不能用于访问 NGINX 容器，因此要直接编辑内容或配置文件，您需要创建一个具有 shell 访问权限的辅助容器。要让 helper 容器能够访问这些文件，创建一个新的映像，其中包含为映像定义的适当的 Docker 数据卷:</p><div class="language-bash"><pre><code><span class="token comment"># 复制 nginx 内容和配置文件，用 Dockerfile 定义映像的音量:</span>
FROM nginx
COPY content /usr/share/nginx/html
COPY conf /etc/nginx
VOLUME /usr/share/nginx/html
VOLUME /etc/nginx

<span class="token comment"># 通过运行以下命令创建新的 NGINX 映像:</span>
docker build -t mynginx_image2 <span class="token builtin class-name">.</span>

<span class="token comment"># 基于 mynginx image2映像创建一个 NGINX 容器 mynginx4:</span>
docker run --name mynginx4 -p <span class="token number">80</span>:80 -d mynginx_image2

<span class="token comment"># 启动一个带有 shell 的 helper 容器 mynginx4文件，提供对我们刚刚创建的 mynginx4容器的内容和配置目录的访问:</span>
docker run -i -t --volumes-from mynginx4 --name mynginx4_files debian /bin/bash
<span class="token comment"># 新的mynginx4_files帮助器容器在前台运行，带有一个持久的标准输入(-i选项)和一个tty (-t选项)。mynginx4中定义的所有卷都作为helper容器中的本地目录挂载。</span>
<span class="token comment"># debian参数意味着帮助容器使用来自Docker Hub的debian映像。因为NGINX映像也使用Debian，所以最有效的方法是使用Debian作为辅助容器，而不是让Docker加载另一个操作系统</span>
<span class="token comment"># /bin/bash参数意味着bash shell在helper容器中运行，显示一个shell提示符，您可以根据需要使用该提示符修改文件</span>

<span class="token comment"># 要启动和停止容器，请运行以下命令:</span>
docker start mynginx4_files
docker stop mynginx4_files

<span class="token comment"># 要退出 shell 但保持容器运行，请按 Ctrl + p，然后按 Ctrl + q 组合键恢复对正在运行的容器的 shell 访问，运行以下命令:</span>
docker attach mynginx4_files

<span class="token comment"># 要退出 shell 并终止容器，请运行 exit 命令。</span>
</code></pre></div><h3 id="管理日志"><a class="header-anchor" href="#管理日志" aria-hidden="true">#</a> 管理日志</h3><ul><li>使用默认日志记录</li></ul><p>默认情况下，NGINX 映像配置为向 Docker 日志收集器发送 NGINX 访问日志和错误日志。这是通过将它们链接到 stdout 和 stderr 来实现的: 然后将来自这两个日志的所有消息写入文件/var/lib/docker/containers/container-ID/container-ID-json。登录 Docker 主机。Container-ID 是创建容器时返回的长形式 ID。要显示长表单 ID，请运行以下命令:</p><div class="language-bash"><pre><code>docker inspect --format <span class="token string">&#39;{{ .Id }}&#39;</span> container-name
</code></pre></div><p>可以使用 Docker 命令行和 Docker 引擎 API 提取日志消息:</p><div class="language-bash"><pre><code><span class="token comment"># 要从命令行提取日志消息，请运行以下命令:</span>
docker logs container-name

<span class="token comment"># 要使用 Docker Remote API 提取日志消息，请使用 Docker Unix sock 发送一个 GET 请求:</span>
<span class="token function">curl</span> --unix-sock /var/run/docker-sock http://localhost/containers/container-name/logs?stdout<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span><span class="token assign-left variable">stderr</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token comment"># 若要在输出中只包含访问日志消息，请只包含 stdout = 1。要将输出限制为错误日志消息，只包含 stderr = 1</span>
</code></pre></div><ul><li>使用定制的日志记录</li></ul><p>如果希望为某些配置块(如服务器{}和位置{})以不同的方式配置日志记录，请为容器中存储日志文件的目录定义 Docker 卷，创建一个帮助容器来访问日志文件，并使用任何日志记录工具。要实现这一点，请创建一个新映像，其中包含日志文件的卷或卷。</p><div class="language-bash"><pre><code><span class="token comment"># 例如，为了配置 NGINX 将日志文件存储在/var/log/NGINX/log 中，在 Dockerfile 中添加该目录的 VOLUME 定义(前提是内容和配置文件在容器中进行管理) :</span>
FROM nginx
COPY content /usr/share/nginx/html
COPY conf /etc/nginx
VOLUME /var/log/nginx/log
<span class="token comment"># 然后，您可以创建一个映像，并使用它创建一个 NGINX 容器和一个可以访问日志目录的 helper 容器。助手容器可以安装任何所需的日志记录工具。</span>
</code></pre></div><h3 id="控制-nginx"><a class="header-anchor" href="#控制-nginx" aria-hidden="true">#</a> 控制 NGINX</h3><p>由于不能直接访问 NGINX 容器的命令行，因此不能直接将 NGINX 命令发送到容器。相反，信号可以通过 Docker kill 命令发送到容器</p><div class="language-bash"><pre><code><span class="token comment"># 要重新加载 NGINX 配置，请向 Docker 发送 HUP 信号:</span>
docker <span class="token function">kill</span> -s HUP container-name

<span class="token comment"># 要重新启动 NGINX，运行以下命令重新启动容器:</span>
docker restart container-name
</code></pre></div><h2 id="基本功能"><a class="header-anchor" href="#基本功能" aria-hidden="true">#</a> 基本功能</h2><h3 id="master-and-worker-processes"><a class="header-anchor" href="#master-and-worker-processes" aria-hidden="true">#</a> Master and Worker Processes</h3><p>NGINX 有一个主进程和一个或多个辅助进程。如果启用了缓存，缓存加载器和缓存管理器进程也会在启动时运行。</p><p>主进程的主要目的是读取和评估配置文件，以及维护辅助进程。</p><p>辅助进程执行请求的实际处理。NGINX 依靠依赖于操作系统的机制在工作进程之间有效地分配请求。辅助进程的数量由 nginx.conf 配置文件中的 worker _ processes 指令定义，可以设置为固定数量，也可以配置为自动调整可用 CPU 内核的数量。</p><h3 id="控制-nginx-命令"><a class="header-anchor" href="#控制-nginx-命令" aria-hidden="true">#</a> 控制 NGINX 命令</h3><p>要重新加载配置，可以停止或重新启动 NGINX，或者向主进程发送信号。可以通过运行带有-s 参数的 NGINX 命令(调用 NGINX 可执行文件)来发送信号。</p><div class="language-bash"><pre><code>nginx -s <span class="token operator">&lt;</span>SIGNAL<span class="token operator">&gt;</span>
</code></pre></div><p>其中 &lt; signal &gt; 可以是以下任何一个:</p><ul><li>quit – 优雅关闭</li><li>reload – 重新加载配置文件</li><li>reopen – 重新打开日志文件</li><li>stop – 立即关闭(快速关闭)</li></ul><p>Kill 实用程序也可用于直接向主进程发送信号。默认情况下，主进程的进程 ID 被写入 nginx.pid 文件，该文件位于/usr/local/nginx/logs 或/var/run 目录中。</p><h3 id="创建-nginx-配置文件"><a class="header-anchor" href="#创建-nginx-配置文件" aria-hidden="true">#</a> 创建 NGINX 配置文件</h3><p>默认情况下，配置文件名为 NGINX.conf。它通常是/usr/local/nginx/conf、/etc/nginx 或/usr/local/etc/nginx 之一</p><ul><li>Directives</li></ul><p>配置文件由指令及其参数组成。简单(单行)指令的每个末尾都有一个分号。其他指令充当“容器”，将相关指令组合在一起，并用花括号括起来({}) ; 这些指令通常称为块。下面是一些简单指令的例子。</p><div class="language-bash"><pre><code>user             nobody<span class="token punctuation">;</span>
error_log        logs/error.log notice<span class="token punctuation">;</span>
worker_processes <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>特定功能的配置文件</li></ul><p>为了使配置更易于维护，我们建议您将其分割为一组特定于特性的文件，存储在/etc/nginx/conf.d 目录中，并使用 nginx.conf 主文件中的头文件文件来引用特定于特性的文件的内容。</p><div class="language-bash"><pre><code>include conf.d/http<span class="token punctuation">;</span>
include conf.d/stream<span class="token punctuation">;</span>
include conf.d/exchange-enhanced<span class="token punctuation">;</span>
</code></pre></div><ul><li>Contexts(称为上下文)</li></ul><p>一些顶级指令(称为上下文)将适用于不同流量类型的指令组合在一起:</p><ul><li>events – 一般连接处理</li><li>http - HTTP 传输</li><li>mail - 邮件通信</li><li>stream - TCP 和 UDP 通信</li></ul><p>置于这些Contexts之外的指令被认为是<code>main context</code></p><div class="language-bash"><pre><code>user nobody<span class="token punctuation">;</span> <span class="token comment"># a directive in the &#39;main&#39; context</span>

events <span class="token punctuation">{</span>
  <span class="token comment"># configuration of connection processing</span>
<span class="token punctuation">}</span>

http <span class="token punctuation">{</span>
  <span class="token comment"># Configuration specific to HTTP and affecting all virtual servers  </span>

  server <span class="token punctuation">{</span>
    <span class="token comment"># configuration of HTTP virtual server 1       </span>
    location /one <span class="token punctuation">{</span>
      <span class="token comment"># configuration for processing URIs starting with &#39;/one&#39;</span>
    <span class="token punctuation">}</span>
    location /two <span class="token punctuation">{</span>
      <span class="token comment"># configuration for processing URIs starting with &#39;/two&#39;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
  
  server <span class="token punctuation">{</span>
    <span class="token comment"># configuration of HTTP virtual server 2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

stream <span class="token punctuation">{</span>
  <span class="token comment"># Configuration specific to TCP/UDP and affecting all virtual servers</span>
  server <span class="token punctuation">{</span>
    <span class="token comment"># configuration of TCP virtual server 1 </span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="http-load-balancing（负载均衡）"><a class="header-anchor" href="#http-load-balancing（负载均衡）" aria-hidden="true">#</a> HTTP Load Balancing（负载均衡）</h2><h3 id="overview（概览）"><a class="header-anchor" href="#overview（概览）" aria-hidden="true">#</a> Overview（概览）</h3><p>负载均衡指的是在多个后端服务器之间有效地分配网络流量</p><p>跨多个应用程序实例的负载平衡是一种常用的技术，用于优化资源利用率、最大化吞吐量、减少延迟并确保容错配置。</p><h3 id="proxying-http-traffic-to-a-group-of-servers"><a class="header-anchor" href="#proxying-http-traffic-to-a-group-of-servers" aria-hidden="true">#</a> Proxying HTTP Traffic to a Group of Servers</h3><p>要开始使用 NGINX Open Source 来平衡一组服务器的 HTTP 流量，首先需要使用<code>upstream</code>指令定义该组。该指令被放置在 http 上下文中。</p><p>例如，下面的配置定义了一个名为 backend 的组，由三个服务器配置组成(可以在三个以上的实际服务器中解析) :</p><div class="language-bash"><pre><code>http <span class="token punctuation">{</span>
  upstream backend <span class="token punctuation">{</span>
    server backend1.example.com <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment"># 运行同一应用程序的实例</span>
    server backend2.example.com<span class="token punctuation">;</span> <span class="token comment"># 运行同一应用程序的实例</span>
    server <span class="token number">192.0</span>.0.1 backup<span class="token punctuation">;</span> <span class="token comment"># 备份服务器</span>
  <span class="token punctuation">}</span>

  server <span class="token punctuation">{</span>
    location / <span class="token punctuation">{</span>
      proxy_pass http://backend<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment"># NGINX 上运行的虚拟服务器将所有请求传递给前面例子中定义的备份服务器</span>
<span class="token punctuation">}</span>
<span class="token comment"># 因为在upstream中没有指定负载平衡算法，所以 NGINX 使用默认算法 Round Robin:</span>
</code></pre></div><h3 id="选择负载平衡方法"><a class="header-anchor" href="#选择负载平衡方法" aria-hidden="true">#</a> 选择负载平衡方法</h3><p>NGINX 开源支持四种负载平衡方法:</p><ul><li>Round Robin - 请求均匀地分布在服务器上，并考虑服务器权重。默认情况下使用此方法(没有启用它的指令)</li></ul><div class="language-bash"><pre><code>upstream backend <span class="token punctuation">{</span>
  <span class="token comment"># no load balancing method is specified for Round Robin</span>
  server backend1.example.com<span class="token punctuation">;</span>
  server backend2.example.com<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>Least Connections - 最少的连接——向服务器发送的请求中活动连接的数量最少，同样要考虑服务器权重:</li></ul><div class="language-bash"><pre><code>upstream backend <span class="token punctuation">{</span>
  least_conn<span class="token punctuation">;</span>
  server backend1.example.com<span class="token punctuation">;</span>
  server backend2.example.com<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>IP Hash - 发送请求的服务器是由客户端 IP 地址决定的。在这种情况下，使用 IPv4地址的前三个八位元组或整个 IPv6地址来计算散列值。该方法保证来自相同地址的请求到达相同的服务器，除非它不可用。</li></ul><div class="language-bash"><pre><code>upstream backend <span class="token punctuation">{</span>
  ip_hash<span class="token punctuation">;</span>
  server backend1.example.com<span class="token punctuation">;</span>
  server backend2.example.com<span class="token punctuation">;</span>

  <span class="token comment"># 如果某个服务器需要暂时从负载平衡旋转中删除，可以用 down 参数对其进行标记，以便保留当前客户端 IP 地址的散列。由此服务器处理的请求将自动发送到组中的下一个服务器:</span>
  server backend3.example.com down<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><ul><li>Hash - 请求是从用户定义的关键，可以是一个文本字符串，变量，或一个组合确定。例如，密钥可能是一个成对的源 IP 地址和端口，或者是一个 URI，如下例所示:</li></ul><div class="language-bash"><pre><code>upstream backend <span class="token punctuation">{</span>
  <span class="token builtin class-name">hash</span> <span class="token variable">$request_uri</span> consistent<span class="token punctuation">;</span>
  server backend1.example.com<span class="token punctuation">;</span>
  server backend2.example.com<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Hash 指令的可选的 consistent 参数启用 ketama consistent-hash 负载平衡。根据用户定义的散列键值，请求均匀地分布在所有上游服务器上。如果将上游服务器添加到上游组或从上游组移除，则只需重新映射少量密钥，从而在负载平衡缓存服务器或其他累积状态的应用程序的情况下，最大限度地减少缓存丢失。</p><h3 id="server-weights"><a class="header-anchor" href="#server-weights" aria-hidden="true">#</a> Server Weights</h3><p>默认情况下，NGINX 使用 Round Robin 方法根据请求的权重在组中的服务器之间分发请求。服务器指令的 weight 参数设置服务器的权重; 默认值是1:</p><div class="language-bash"><pre><code>upstream backend <span class="token punctuation">{</span>
  server backend1.example.com <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
  server backend2.example.com<span class="token punctuation">;</span>
  server <span class="token number">192.0</span>.0.1 backup<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment"># 在本例中， backend1.example.com 服务器的权重为5; 其他两个服务器的默认权重为1，但 IP 地址为192.0.0.1的服务器被标记为备份服务器，除非其他两个服务器都不可用，否则不会接收请求。使用这种权重配置，每6个请求中，5个发送到 backend1.example.com ，1个发送到 backend2.example.com。</span>
</code></pre></div><h2 id="tcp-and-udp-load-balancing"><a class="header-anchor" href="#tcp-and-udp-load-balancing" aria-hidden="true">#</a> TCP and UDP Load Balancing</h2><h3 id="配置反向代理"><a class="header-anchor" href="#配置反向代理" aria-hidden="true">#</a> 配置反向代理</h3><p>首先，您需要配置反向代理，以便 NGINX Open Source 可以将客户机的 TCP 连接或 UDP 数据报转发到upstream组或代理服务器</p><p>打开 NGINX 配置文件并执行以下步骤:</p><div class="language-bash"><pre><code><span class="token comment"># 创建一个顶级 stream {} 块:</span>
stream <span class="token punctuation">{</span>
  <span class="token comment"># 为 stream {}上下文中的每个虚拟服务器定义一个或多个 server {} 配置块</span>
  <span class="token comment"># 在每个服务器的 server {}配置块中，包含 listen 指令来定义服务器侦听的 IP 地址和/或端口</span>
  <span class="token comment"># 使用 proxy_ pass 指令来定义被代理的服务器或者服务器转发流量的upstream组</span>
  server <span class="token punctuation">{</span>
    <span class="token comment"># TCP 是 stream 上下文的默认协议，所以 listen 指令没有 TCP 参数</span>
    listen <span class="token number">12345</span><span class="token punctuation">;</span>
    <span class="token comment">#TCP traffic will be forwarded to the &quot;stream_backend&quot; upstream group</span>
    proxy_pass stream_backend<span class="token punctuation">;</span>
    <span class="token comment"># ...</span>
  <span class="token punctuation">}</span>

  server <span class="token punctuation">{</span>
    <span class="token comment"># 对于 UDP 流量，还包括 UDP 参数</span>
    listen <span class="token number">53</span> udp<span class="token punctuation">;</span>
    <span class="token comment">#TCP traffic will be forwarded to the specified server</span>
    proxy_pass backend.example.com:12346<span class="token punctuation">;</span>
    <span class="token comment"># ...</span>
  <span class="token punctuation">}</span>

  server <span class="token punctuation">{</span>
    listen     <span class="token number">53</span> udp<span class="token punctuation">;</span>
    <span class="token comment">#UDP traffic will be forwarded to the &quot;dns_servers&quot; upstream group</span>
    proxy_pass dns_servers<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  server <span class="token punctuation">{</span>
    <span class="token comment"># 如果代理服务器有多个网络接口，您可以选择配置 NGINX，使其在连接到上游服务器时使用特定的源 IP 地址。如果 NGINX 后面的代理服务器配置为接受来自特定 IP 网络或 IP 地址范围的连接，这可能会很有用</span>
    listen     <span class="token number">127.0</span>.0.1:12345<span class="token punctuation">;</span>
    proxy_pass backend.example.com:12345<span class="token punctuation">;</span>
    <span class="token comment"># 包括 proxy _ bind 指令和适当网络接口的 IP 地址</span>
    proxy_bind <span class="token number">127.0</span>.0.1:12345<span class="token punctuation">;</span>
    <span class="token comment"># 还可以选择调整两个内存缓冲区的大小，NGINX 可以在这两个缓冲区中放置来自客户端和上游连接的数据。如果数据量很小，可以减少缓冲区，从而节省内存资源。如果存在大量数据，则可以增加缓冲区大小，以减少套接字读/写操作的数量。一旦在一个连接上接收到数据，NGINX 就会读取数据并通过另一个连接将其转发。缓冲区由 proxy _ buffer _ size 指令控制</span>
    proxy_buffer_size 16k<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment"># ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="configuring-tcp-or-udp-load-balancing"><a class="header-anchor" href="#configuring-tcp-or-udp-load-balancing" aria-hidden="true">#</a> Configuring TCP or UDP Load Balancing</h3><div class="language-bash"><pre><code><span class="token comment"># 创建一组服务器，或者一个负载均衡的上游组。在upsteam{}上下文中定义一个或多个upsteam {}配置块，并设置上游组的名称，例如，TCP 服务器的 stream_backend 和 UDP 服务器的 dns_servers</span>
stream <span class="token punctuation">{</span>
  <span class="token comment"># 确保 proxy_pass 指令引用了上游组的名称，就像上面为反向代理配置的那些指令一样</span>
  upstream stream_backend <span class="token punctuation">{</span>
    <span class="token comment"># 用上游服务器填充上游组。在上游{}块中，为每个上游服务器添加一个服务器指令，指定它的 IP 地址或主机名(可以解析为多个 IP 地址)和一个必需的端口号。请注意，您没有为每个服务器定义协议，因为这是通过您在服务器块中的 listen 指令上包含的参数为整个上游组定义的，该参数是您前面创建的</span>
    server backend1.example.com:12345<span class="token punctuation">;</span>
    server backend2.example.com:12345<span class="token punctuation">;</span>
    server backend3.example.com:12346<span class="token punctuation">;</span>
    <span class="token comment"># ...</span>
  <span class="token punctuation">}</span>

  upstream dns_servers <span class="token punctuation">{</span>
    server <span class="token number">192.168</span>.136.130:53<span class="token punctuation">;</span>
    server <span class="token number">192.168</span>.136.131:53<span class="token punctuation">;</span>
    <span class="token comment"># ...</span>
  <span class="token punctuation">}</span>

  <span class="token comment"># ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>配置上游组使用的负载平衡方法:</p><ul><li>Round Robin - 默认情况下，NGINX 使用 Round Robin 算法来平衡负载流量，并将其顺序指向配置的上游组中的服务器</li><li>Least Connections - 最少连接-NGINX 选择当前活动连接数较少的服务器</li><li>Hash - Hash-NGINX 基于用户定义的密钥选择服务器，例如，源 IP 地址($remote_addr)</li><li>Random - 每个连接将被传递到一个随机选择的服务器。如果指定了这个<code>two</code>参数，首先，NGINX 随机选择两个服务器并考虑服务器权重，然后使用指定的方法选择其中一个服务器: <ul><li>least_conn - 活动连接的最少数量</li></ul></li><li>对于每个上游服务器，可以选择指定特定于服务器的参数，包括最大连接数、服务器重量等</li></ul><div class="language-bash"><pre><code>upstream stream_backend <span class="token punctuation">{</span>
  <span class="token builtin class-name">hash</span>   <span class="token variable">$remote_addr</span> consistent<span class="token punctuation">;</span>
  server backend1.example.com:12345 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
  server backend2.example.com:12345<span class="token punctuation">;</span>
  server backend3.example.com:12346 <span class="token assign-left variable">max_conns</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
upstream dns_servers <span class="token punctuation">{</span>
  least_conn<span class="token punctuation">;</span>
  server <span class="token number">192.168</span>.136.130:53<span class="token punctuation">;</span>
  server <span class="token number">192.168</span>.136.131:53<span class="token punctuation">;</span>
  <span class="token comment"># ...</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>另一种方法是代理流量到单个服务器，而不是上游组。如果您通过主机名识别服务器，并配置主机名以解析为多个 IP 地址，那么 NGINX 负载使用 Round Robin 算法平衡 IP 地址之间的流量。在这种情况下，您必须在 proxy _ pass 指令中指定服务器端口号，并且不能在 IP 地址或主机名之前指定协议</li></ul><div class="language-bash"><pre><code>stream <span class="token punctuation">{</span>
  <span class="token comment"># ...</span>
  server <span class="token punctuation">{</span>
    listen     <span class="token number">12345</span><span class="token punctuation">;</span>
    proxy_pass backend.example.com:12345<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="example-of-tcp-and-udp-load-balancing-configuration"><a class="header-anchor" href="#example-of-tcp-and-udp-load-balancing-configuration" aria-hidden="true">#</a> Example of TCP and UDP Load-Balancing Configuration</h3><div class="language-bash"><pre><code>stream <span class="token punctuation">{</span>
  upstream stream_backend <span class="token punctuation">{</span>
    least_conn<span class="token punctuation">;</span>
    server backend1.example.com:12345 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
    server backend2.example.com:12345 <span class="token assign-left variable">max_fails</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>30s<span class="token punctuation">;</span>
    server backend3.example.com:12345 <span class="token assign-left variable">max_conns</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  upstream dns_servers <span class="token punctuation">{</span>
    least_conn<span class="token punctuation">;</span>
    server <span class="token number">192.168</span>.136.130:53<span class="token punctuation">;</span>
    server <span class="token number">192.168</span>.136.131:53<span class="token punctuation">;</span>
    server <span class="token number">192.168</span>.136.132:53<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  server <span class="token punctuation">{</span>
    <span class="token comment"># 服务器监听端口12345，并将所有 TCP 连接代理到上游服务器的 stream _ backend 组。注意，在流模块的上下文中定义的 proxy _ pass 指令不能包含协议</span>
    listen        <span class="token number">12345</span><span class="token punctuation">;</span>
    proxy_pass    stream_backend<span class="token punctuation">;</span>
    proxy_timeout 3s<span class="token punctuation">;</span>
    proxy_connect_timeout 1s<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  server <span class="token punctuation">{</span>
    <span class="token comment"># 服务器监听端口53，并将所有 UDP 数据报(listen 指令的 UDP 参数)代理到名为 dns _ servers 的上游组。如果未指定 udp 参数，套接字将侦听 TCP 连接。</span>
    listen     <span class="token number">53</span> udp<span class="token punctuation">;</span>
    proxy_pass dns_servers<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  server <span class="token punctuation">{</span>
    <span class="token comment"># 虚拟服务器监听端口12346并将 TCP 连接代理到 backend4.example.com 服务器，该服务器可以解析几个 IP 地址，这些 IP 地址通过 Round Robin 方法实现负载平衡</span>
    listen     <span class="token number">12346</span><span class="token punctuation">;</span>
    proxy_pass backend4.example.com:12346<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="http-health-checks"><a class="header-anchor" href="#http-health-checks" aria-hidden="true">#</a> HTTP Health Checks</h2><h3 id="introduction"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h3><p>NGINX 可以不断地测试上游服务器，避免出现故障的服务器，并优雅地将恢复的服务器添加到负载平衡组中。</p><h3 id="passive-health-checks（被动健康检查）"><a class="header-anchor" href="#passive-health-checks（被动健康检查）" aria-hidden="true">#</a> Passive Health Checks（被动健康检查）</h3><p>对于被动健康检查，NGINX 会在事务发生时进行监视，并尝试恢复失败的连接。如果事务仍然不能恢复，NGINX 开放源码将服务器标记为不可用，并暂时停止向它发送请求，直到它再次被标记为活动</p><ul><li>fail_timeout - 设置服务器被标记为不可用的时间，以及服务器被标记为不可用的时间(默认为10秒)</li><li>max_fails - 服务器被标记为不可用(默认为1次尝试)</li></ul><p>在下面的例子中，如果 NGINX 无法向服务器发送请求，或者在30秒内3次没有收到服务器的响应，它将服务器标记为30秒内不可用:</p><div class="language-bash"><pre><code>upstream backend <span class="token punctuation">{</span>
  server backend1.example.com<span class="token punctuation">;</span>
  server backend2.example.com <span class="token assign-left variable">max_fails</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>30s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最近恢复的服务器很容易被连接压垮，这可能导致服务器再次被标记为不可用。缓慢启动允许上游服务器逐渐恢复其重量从零到其名义值后，它已恢复或成为可用。这可以通过上游服务器指令的 slow _ start 参数来完成</p><div class="language-bash"><pre><code>upstream backend <span class="token punctuation">{</span>
  server backend1.example.com <span class="token assign-left variable">slow_start</span><span class="token operator">=</span>30s<span class="token punctuation">;</span>
  server backend2.example.com<span class="token punctuation">;</span>
  server <span class="token number">192.0</span>.0.1 backup<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">提醒</p><p>注意，如果组中只有一个服务器，fail_timeout 和 max_fails 参数将被忽略，服务器永远不会被标记为不可用。</p></div><h3 id="tcp-health-checks"><a class="header-anchor" href="#tcp-health-checks" aria-hidden="true">#</a> TCP Health Checks</h3><div class="language-bash"><pre><code>stream <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
  upstream stream_backend <span class="token punctuation">{</span>
    server backend1.example.com:12345 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
    server backend2.example.com:12345 <span class="token assign-left variable">max_fails</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>30s<span class="token punctuation">;</span>
    server backend3.example.com:12345 <span class="token assign-left variable">max_conns</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">#...</span>
  server <span class="token punctuation">{</span>
    listen     <span class="token number">12345</span><span class="token punctuation">;</span>
    proxy_pass stream_backend<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="udp-health-checks"><a class="header-anchor" href="#udp-health-checks" aria-hidden="true">#</a> UDP Health Checks</h3><div class="language-bash"><pre><code>stream <span class="token punctuation">{</span>
  <span class="token comment">#...</span>
  upstream dns_upstream <span class="token punctuation">{</span>
    server <span class="token number">192.168</span>.136.130:53 <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>60s<span class="token punctuation">;</span>
    server <span class="token number">192.168</span>.136.131:53 <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>60s<span class="token punctuation">;</span>
    server <span class="token number">192.168</span>.136.132:53 <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>60s<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">#...</span>
  server <span class="token punctuation">{</span>
    listen          <span class="token number">53</span> udp<span class="token punctuation">;</span>
    proxy_pass      dns_upstream<span class="token punctuation">;</span>
    proxy_timeout   1s<span class="token punctuation">;</span>
    proxy_responses <span class="token number">1</span><span class="token punctuation">;</span>
    error_log       logs/dns.log<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">#...</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-bash"><pre><code>
<span class="token comment"># 获得所有正在运行的 nginx 进程的列表</span>
<span class="token function">ps</span> -ax <span class="token operator">|</span> <span class="token function">grep</span> nginx

<span class="token comment"># 默认情况下，nginx 主进程的进程 ID 写入到目录</span>
<span class="token comment"># killnginx.pid/usr/local/nginx/logs/var/run</span>
<span class="token function">kill</span> -s QUIT <span class="token number">1628</span>
</code></pre></div><h3 id="读取静态文件"><a class="header-anchor" href="#读取静态文件" aria-hidden="true">#</a> 读取静态文件</h3><div class="language-nginx"><pre><code><span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>      <span class="token comment"># 路由</span>
    <span class="token keyword">root</span> <span class="token operator">/</span>data<span class="token operator">/</span>www<span class="token punctuation">;</span> <span class="token comment"># 静态文件存放目录</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">location</span> <span class="token operator">/</span>images<span class="token operator">/</span> <span class="token punctuation">{</span>
    <span class="token keyword">root</span> <span class="token operator">/</span>data<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这已经是一个在标准端口80上侦听的服务器的工作配置，并且可以在本地机器上访问</p><h3 id="设置一个简单的代理服务器"><a class="header-anchor" href="#设置一个简单的代理服务器" aria-hidden="true">#</a> 设置一个简单的代理服务器</h3><div class="language-nginx"><pre><code><span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>
    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span><span class="token punctuation">;</span>  <span class="token comment"># 80端口代理到http://localhost:8080/</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">location</span> <span class="token operator">~</span> \<span class="token punctuation">.</span><span class="token punctuation">(</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>png<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
    <span class="token keyword">root</span> <span class="token operator">/</span>data<span class="token operator">/</span>images<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div></div><footer class="page-footer" data-v-d36a7fda data-v-5a019cc9><div class="edit" data-v-5a019cc9><div class="edit-link" data-v-5a019cc9 data-v-3ae295f1><a class="link" href="https://github.com/QiYoe/c-blog/edit/master/docs/front-end/linux/nginx.md" target="_blank" rel="noopener noreferrer" data-v-3ae295f1>在 GitHub 上编辑此页 <svg class="icon outbound icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-3ae295f1><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div><div class="updated" data-v-5a019cc9><p class="last-updated" data-v-5a019cc9 data-v-52854a16><span class="prefix" data-v-52854a16>最新更新时间:</span><span class="datetime" data-v-52854a16></span></p></div></footer><div class="next-and-prev-link" data-v-d36a7fda data-v-6683615c><div class="container" data-v-6683615c><div class="prev" data-v-6683615c><a class="link" href="/front-end/linux/" data-v-6683615c><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-6683615c><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-6683615c>Linux启动Nginx服务</span></a></div><div class="next" data-v-6683615c><a class="link" href="/front-end/linux/docker" data-v-6683615c><span class="text" data-v-6683615c>Docker</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-6683615c><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"13a40bb7\",\"algorithm_leetcode.md\":\"633cad7a\",\"books_you-dont-know-js.md\":\"96fc975c\",\"tools_smart-tools.md\":\"e46da50a\",\"front-end_blog-build_aliyun-domin.md\":\"ebd89d8d\",\"front-end_blog-build_baidu-include.md\":\"87da81c1\",\"front-end_blog-build_seo-optimize.md\":\"b4da9142\",\"front-end_blog-build_vitepress-build.md\":\"b76a763f\",\"front-end_linux_docker.md\":\"da76dccf\",\"front-end_linux_index.md\":\"e79c80fa\",\"front-end_linux_nginx.md\":\"2da67810\",\"front-end_swagger-hub_index.md\":\"6eb19474\",\"front-end_vue_axios.md\":\"9dd4e0a6\",\"front-end_vue_index.md\":\"26c332b7\",\"front-end_vue_nuxt.md\":\"16dfc8ea\",\"front-end_vue_sass.md\":\"dca24343\",\"front-end_vue_typescript.md\":\"9b20c21a\",\"front-end_vue_vite.md\":\"1734d1e4\",\"front-end_vue_vue-router.md\":\"46fb6547\",\"front-end_web-container_index.md\":\"b40cc3c3\"}")</script>
    <script type="module" async src="/assets/app.7412c22e.js"></script>
  </body>
</html>