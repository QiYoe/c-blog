---
title: 你不知道的JavaScript
head:
  - - meta
    - name: description
      content: you-dont-know-JS读书笔记
  - - meta
    - name: keywords
      content: 你不知道的JavaScript you-dont-know-JS 你不知道的JS 读书笔记
---

## 作用域和闭包

### 作用域是什么

首先介绍传统编译语言“编译”步骤：

- 分词：把我们编写的代码分解。比如var a = 2;，会分解成var、a、=、2、；空格的分解与否取决于空格在语言中有没有意义
- 解析：把上一步分解得到的词法单元流（数组）根据嵌套关系（作用域）组成“抽象语法树”（AST）
- 生成代码：将AST转为机器可执行指令

**总结：将编写的代码转换位AST，生成机器可执行指令，最后机器执行指令`创建变量、存储变量等`，实际上JavaScript编译过程也类似如此**

其次介绍js执行程序的“打工人”

- 引擎：项目经理，从头到尾参与整个编译和`执行`过程
- 编译器：苦逼程序员，上边编译过程就是它负责处理
- 作用域：产品经理，定义一套规则，规定当前执行代码对声明标识符的访问权限
  
当来一个新项目时（执行var a = 2;），程序员就要和产品经理开始沟通（撕逼：自行脑部吧🤭）

代码生成阶段编译器处理var a = 2;流程：

- 看到var a，编译器询问当前作用域是否已存在a，存在，则忽略它，继续编译；不存在，则在当前作用域生命变量a
- 然后编译器生成引擎运行所需代码(处理a = 2)。引擎运行编译器处理之后的a = 2：引擎询问当前作用域是否已存在a，存在，则使用此a赋值；不存在，则在向上作用域查找a
  - 类似a = 2这种查找赋值操作`目标`是LHS查询(引擎查找)
    - 查询不到时：正常模式-不会报错；严格模式-ReferenceError
    - 查到但进行不合理操作(比如应用null或undefined属性)：TypeError
  - 类似console.log(2)这种查找赋值操作`源头`是RHS查询(查询不到时：ReferenceError)(引擎查找)
- 引擎找到a，赋值；没找到，抛出异常

**总结：变量赋值时，首先编译器在当前作用域中声明一个变量`如果之前没声明过`，然后引擎运行时在作用域中查找该变量，能找到就赋值，找不到则抛出异常**

作用域链：作用域层层嵌套（比如函数嵌套函数）。当前作用域中找不到某变量，引擎就会向外层作用域层层查找，直到找到该变量或是在最外层的全局作用域中也没找到时停止查找

### 词法作用域

作用域有两种工作模型：

- 词法作用域(最为普遍)--定义在词法阶段的作用域(也就是说作用域在写代码时就已经决定好了--大部分情况下是这样)
  - 词法阶段：即上一节说到的`分词`
  - 查找：引擎执行代码，作用域(作用域气泡更容易理解)层层向上查找变量--`遮蔽效应`(作用域查找匹配到第一个标识符时停止，即内部标识符”屏蔽“了外部标识符)
  - 欺骗词法：打破定义在词法阶段的作用域的规则(非常不建议使用：影响性能)
    - eval：在运行修改书写期的词法作用域
    - with(废弃)
- 动态作用域(比如Bash、Perl)

### 函数作用域和块作用域

- 函数作用域--不多说，函数内部形成函数自身的作用域(即函数外部无法访问函数内部变量)
  - 函数声明--function foo()开头
  - 函数表达式--非function()开头`(function foo(){...}())或foo()`
    - 匿名(不建议)
    - 具名
      - IIFE(立即执行函数)
- 块作用域：{}
  - try/catch：catch会创建一个块作用域
  - let、const

**总结：任何声明在某个作用域内的变量，都将`附属于这个作用域`**

### 提升

引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来，[词法作用域](#词法作用域)核心内容(针对当前作用域)

函数优先：函数会首先被提升，然后才是变量

### 作用域闭包

## this和对象原型
