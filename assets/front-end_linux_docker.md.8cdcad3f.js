import{o as a,c as n,b as e}from"./app.af15a0c3.js";const s='{"title":"Docker配置详解","description":"Docker配置详解","frontmatter":{"title":"Docker配置详解","head":[["meta",{"name":"description","content":"Docker配置详解"}],["meta",{"name":"keywords","content":"Linux Ubuntu CentOS Docker Docker配置"}]]},"headers":[{"level":2,"title":"为什么Docker？","slug":"为什么docker？"},{"level":2,"title":"Getting Started","slug":"getting-started"},{"level":3,"title":"Getting started","slug":"getting-started-1"},{"level":3,"title":"Sample application","slug":"sample-application"},{"level":3,"title":"Update the application","slug":"update-the-application"},{"level":3,"title":"Share the application","slug":"share-the-application"},{"level":3,"title":"Persist the DB(持久化数据库)","slug":"persist-the-db-持久化数据库"}],"relativePath":"front-end/linux/docker.md","lastUpdated":1625154407938}',t={},o=e('<h2 id="为什么docker？"><a class="header-anchor" href="#为什么docker？" aria-hidden="true">#</a> 为什么Docker？</h2><p><a href="https://docs.docker.com/get-started/overview/" target="_blank" rel="noopener noreferrer">docker官网</a></p><p>Docker 是一个用于开发、发布和运行应用程序的开放平台。通过利用 Docker 的快速发布、测试和部署代码的方法，可以显著减少编写代码和在生产环境中运行代码之间的延迟。</p><h2 id="getting-started"><a class="header-anchor" href="#getting-started" aria-hidden="true">#</a> Getting Started</h2><p>官网下载<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener noreferrer">docker客户端</a></p><p>容器：简单地说，容器就是机器上与主机上的所有其他进程隔离的另一个进程。这种隔离利用了内核namespaces 和 cgroups，这些特性在 Linux 中已经存在很长时间了。</p><p>镜像：在运行容器时，它使用一个独立的文件系统。这个自定义文件系统是由容器镜像提供的。由于镜像包含容器的文件系统，因此它必须包含运行应用程序所需的所有内容——所有的依赖项、配置、脚本、二进制文件等。镜像还包含容器的其他配置，如环境变量、要运行的默认命令和其他元数据。</p><h3 id="getting-started-1"><a class="header-anchor" href="#getting-started-1" aria-hidden="true">#</a> Getting started</h3><p>命令行运行：</p><div class="language-bash"><pre><code>docker run -d -p <span class="token number">80</span>:80 docker/getting-started\n<span class="token comment"># -d  以分离模式(在后台)运行容器</span>\n<span class="token comment"># -p 80:80  将主机的80端口映射到容器的80端口</span>\n<span class="token comment"># docker/getting-started  使用镜像</span>\n<span class="token comment"># 缩写： docker run -dp 80:80 docker/getting-started</span>\n</code></pre></div><h3 id="sample-application"><a class="header-anchor" href="#sample-application" aria-hidden="true">#</a> Sample application</h3><p>下载<a href="https://github.com/docker/getting-started/tree/master/app" target="_blank" rel="noopener noreferrer">官网示例项目</a>。在项目根目录中添加Dockerfile文件：</p><div class="language-dockerfile"><pre><code><span class="token instruction"><span class="token keyword">FROM</span> node:12-alpine</span>\n<span class="token instruction"><span class="token keyword">RUN</span> apk add --no-cache python g++ make</span>\n<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>\n<span class="token instruction"><span class="token keyword">COPY</span> . .</span>\n<span class="token instruction"><span class="token keyword">RUN</span> yarn install --production</span>\n<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;node&quot;</span>, <span class="token string">&quot;src/index.js&quot;</span>]</span>\n</code></pre></div><p>命令行运行：</p><div class="language-bash"><pre><code>docker build -t getting-started <span class="token builtin class-name">.</span>\n<span class="token comment"># 该命令使用 Dockerfile 构建一个新的容器镜像，从node: 12-alpine 开始下载镜像。下载镜像之后，我们在应用程序中复制镜像，并使用yarn安装应用程序的依赖项。CMD 指令指定从此镜像启动容器时运行的默认命令。</span>\n<span class="token comment"># 最后,-t 标志标记我们的镜像。可以将其简单地看作是最终镜像的可读名称。</span>\n<span class="token comment"># 在 Docker build 命令的末尾告诉 Docker 应该在工作目录文件中寻找 Dockerfile。</span>\n\n<span class="token comment"># 使用 docker run 命令启动容器，并指定我们刚刚创建的镜像的名称:</span>\ndocker run -dp <span class="token number">3000</span>:3000 getting-started\n</code></pre></div><h3 id="update-the-application"><a class="header-anchor" href="#update-the-application" aria-hidden="true">#</a> Update the application</h3><p>在 src/static/js/app.js 文件中，更新第56行以使用新的空白文本：</p><div class="language-html"><pre><code>-  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text-center<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>No items yet! Add one above!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>\n+  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text-center<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>You have no todo items yet! Add one above!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><div class="language-bash"><pre><code><span class="token comment"># 让我们使用之前使用的相同命令构建映像的更新版本。</span>\ndocker build -t getting-started <span class="token builtin class-name">.</span>\n\n<span class="token comment"># 让我们使用更新的代码启动一个新容器。</span>\ndocker run -dp <span class="token number">3000</span>:3000 getting-started\n</code></pre></div><div class="danger custom-block"><p class="custom-block-title">报错</p><p>我们无法启动新容器，因为旧容器还在运转。这是一个问题，因为容器使用主机的端口3000，并且机器上只有一个进程(包括容器)可以侦听特定的端口。为了解决这个问题，我们需要移除旧的容器。</p></div><p>移除旧容器：</p><ul><li>Remove a container using the CLI</li></ul><div class="language-bash"><pre><code><span class="token comment"># 使用 docker ps 命令获取容器的 ID。</span>\ndocker <span class="token function">ps</span>\n\n<span class="token comment"># 使用 docker stop 命令停止容器。</span>\ndocker stop <span class="token operator">&lt;</span>the-container-id<span class="token operator">&gt;</span>\n\n<span class="token comment"># 一旦容器停止，您可以使用 dockerrm 命令删除它。</span>\ndocker <span class="token function">rm</span> <span class="token operator">&lt;</span>the-container-id<span class="token operator">&gt;</span>\n</code></pre></div><ul><li>Remove a container using the Docker Dashboard</li></ul><ol><li>打开仪表板，鼠标悬停在应用程序容器上，你会看到一组动作按钮出现在右边。</li><li>单击垃圾桶图标删除容器。</li><li>确认移除，你就完成了！</li></ol><p>现在，开始更新你的应用程序。</p><div class="language-bash"><pre><code>docker run -dp <span class="token number">3000</span>:3000 getting-started\n</code></pre></div><p>在你的浏览器上刷新http://localhost:3000，你就会看到更新的帮助文本！</p><h3 id="share-the-application"><a class="header-anchor" href="#share-the-application" aria-hidden="true">#</a> Share the application</h3><p>现在我们已经建立了一个镜像，让我们分享它！要共享 Docker 映像，必须使用 Docker 注册表。默认的注册表是 dockerhub，我们使用的所有镜像都来自这个注册表。</p><p>创建名为<code>getting-started</code>的仓库。。。</p><p>推送镜像：</p><div class="language-bash"><pre><code><span class="token comment"># 使用命令登录到 Docker Hub。</span>\ndocker login -u YOUR-<span class="token environment constant">USER</span>-NAME\n\n<span class="token comment"># 使用 `docker tag` 命令为刚开始使用的`getting-started`镜像命名。一定要用你的 Docker ID 替换掉 `YOUR-USER-NAME`。</span>\ndocker tag getting-started YOUR-<span class="token environment constant">USER</span>-NAME/getting-started\n\n<span class="token comment"># push。如果要从 dockerhub 复制值，可以删除 tagname 部分，因为我们没有向镜像名称添加标记。如果不指定标记，Docker 将使用名为 latest 的标记。</span>\ndocker push YOUR-<span class="token environment constant">USER</span>-NAME/getting-started\n</code></pre></div><p>在<a href="https://labs.play-with-docker.com/" target="_blank" rel="noopener noreferrer">Play with Docker</a>点击<code>ADD NEW INSTANCE</code>选项，在终端中，启动刚刚推出的应用程序。</p><div class="language-bash"><pre><code>docker run -dp <span class="token number">3000</span>:3000 YOUR-<span class="token environment constant">USER</span>-NAME/getting-started\n</code></pre></div><h3 id="persist-the-db-持久化数据库"><a class="header-anchor" href="#persist-the-db-持久化数据库" aria-hidden="true">#</a> Persist the DB(持久化数据库)</h3>',36);t.render=function(e,s,t,p,c,r){return a(),n("div",null,[o])};export default t;export{s as __pageData};
