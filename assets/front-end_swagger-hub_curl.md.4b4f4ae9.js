import{o as e,c as a,b as t}from"./app.cd4eb4cf.js";const o='{"title":"Curl","description":"Curl学习日志","frontmatter":{"title":"Curl","head":[["meta",{"name":"description","content":"Curl学习日志"}],["meta",{"name":"keywords","content":"Curl swaggerhub swagger-ui swagger"}]]},"headers":[{"level":2,"title":"-A(--user-agent)","slug":"a-user-agent"},{"level":2,"title":"-a(--append)","slug":"a-append"},{"level":3,"title":"--basic","slug":"basic"},{"level":3,"title":"--cacert FILE","slug":"cacert-file"},{"level":3,"title":"--capath DIR","slug":"capath-dir"},{"level":3,"title":"--aws-sigv4 [provider1[:provider2[:region[:service]]]]","slug":"aws-sigv4-provider1-provider2-region-service"},{"level":2,"title":"-B(--use-ascii)","slug":"b-use-ascii"},{"level":2,"title":"-b(--cookie STRING/FILE)","slug":"b-cookie-string-file"},{"level":2,"title":"-C(--continue-at OFFSET)","slug":"c-continue-at-offset"},{"level":2,"title":"-c(--cookie-jar FILE)","slug":"c-cookie-jar-file"},{"level":3,"title":"--create-dirs","slug":"create-dirs"},{"level":3,"title":"--crlf","slug":"crlf"},{"level":3,"title":"--crlfile FILE","slug":"crlfile-file"},{"level":2,"title":"-D(--dump-header FILE)","slug":"d-dump-header-file"},{"level":3,"title":"--egd-file FILE","slug":"egd-file-file"},{"level":3,"title":"--engine ENGINGE","slug":"engine-enginge"},{"level":2,"title":"-d(--data DATA)","slug":"d-data-data"},{"level":3,"title":"--data-urlencode DATA","slug":"data-urlencode-data"},{"level":3,"title":"--data-ascii DATA","slug":"data-ascii-data"},{"level":3,"title":"--data-binary DATA","slug":"data-binary-data"},{"level":3,"title":"--delegation STRING","slug":"delegation-string"},{"level":3,"title":"--digest`","slug":"digest"},{"level":3,"title":"--disable-eprt","slug":"disable-eprt"},{"level":3,"title":"--disable-epsv","slug":"disable-epsv"},{"level":2,"title":"-E(--cert CERT[:PASSWD])","slug":"e-cert-cert-passwd"},{"level":3,"title":"--cert-type TYPE","slug":"cert-type-type"},{"level":3,"title":"--ciphers LIST","slug":"ciphers-list"},{"level":3,"title":"--compressed","slug":"compressed"},{"level":2,"title":"-e(--referer)","slug":"e-referer"},{"level":2,"title":"-F(--form CONTENT)","slug":"f-form-content"},{"level":3,"title":"--form-string STRING","slug":"form-string-string"},{"level":3,"title":"--ftp-account DATA","slug":"ftp-account-data"},{"level":3,"title":"--ftp-alternative-to-user COMMAND","slug":"ftp-alternative-to-user-command"},{"level":3,"title":"--ftp-create-dirs","slug":"ftp-create-dirs"},{"level":3,"title":"--ftp-method","slug":"ftp-method"},{"level":3,"title":"--ftp-pasv","slug":"ftp-pasv"},{"level":2,"title":"-f(--fail)","slug":"f-fail"},{"level":2,"title":"-G(--get)","slug":"g-get"},{"level":2,"title":"-g(--globoff)","slug":"g-globoff"},{"level":2,"title":"-H(--header LINE)","slug":"h-header-line"},{"level":2,"title":"-h(--help)","slug":"h-help"},{"level":2,"title":"-I(--head)","slug":"i-head"},{"level":2,"title":"-i(--include)","slug":"i-include"},{"level":2,"title":"-J(--remote-header-name)","slug":"j-remote-header-name"},{"level":2,"title":"-j(--junk-session-cookies)","slug":"j-junk-session-cookies"},{"level":3,"title":"--keepalive-time SECONDS","slug":"keepalive-time-seconds"},{"level":3,"title":"--key KEY","slug":"key-key"},{"level":3,"title":"--key-type TYPE","slug":"key-type-type"},{"level":3,"title":"--krb LEVEL","slug":"krb-level"},{"level":3,"title":"--libcurl FILE","slug":"libcurl-file"},{"level":3,"title":"--limit-rate RATE","slug":"limit-rate-rate"},{"level":2,"title":"-K(--config FILE)","slug":"k-config-file"},{"level":3,"title":"--connect-timeout SECONDS","slug":"connect-timeout-seconds"},{"level":2,"title":"-k(--insecure)","slug":"k-insecure"},{"level":3,"title":"--interface INTERFAC","slug":"interface-interfac"},{"level":2,"title":"-L(--location)","slug":"l-location"},{"level":3,"title":"--location-trusted","slug":"location-trusted"},{"level":2,"title":"-l(--list-only)","slug":"l-list-only"},{"level":3,"title":"--limit-rate RANGE","slug":"limit-rate-range"},{"level":2,"title":"-M(--manual)","slug":"m-manual"},{"level":3,"title":"--mail-from FROM","slug":"mail-from-from"},{"level":3,"title":"--mail-rcpt TO","slug":"mail-rcpt-to"},{"level":3,"title":"--mail-auth AUTH","slug":"mail-auth-auth"},{"level":3,"title":"--max-filesize BYTES","slug":"max-filesize-bytes"},{"level":3,"title":"--max-redirs NUM","slug":"max-redirs-num"},{"level":2,"title":"-m(--max-time SECONDS)","slug":"m-max-time-seconds"},{"level":3,"title":"--metalink","slug":"metalink"},{"level":3,"title":"--negotiate","slug":"negotiate"},{"level":2,"title":"-N(--netrc)","slug":"n-netrc"},{"level":3,"title":"--netrc-optional","slug":"netrc-optional"},{"level":3,"title":"--netrc-file FILE","slug":"netrc-file-file"},{"level":2,"title":"-n(--no-buffer)","slug":"n-no-buffer"},{"level":3,"title":"--no-keepalive","slug":"no-keepalive"},{"level":3,"title":"--no-sessionid","slug":"no-sessionid"},{"level":3,"title":"--noproxy","slug":"noproxy"},{"level":3,"title":"--ntlm","slug":"ntlm"},{"level":2,"title":"-O(--remote-name)","slug":"o-remote-name"},{"level":3,"title":"--remote-name-all","slug":"remote-name-all"},{"level":2,"title":"-o(--output FILE)","slug":"o-output-file"},{"level":3,"title":"--pass PASS","slug":"pass-pass"},{"level":3,"title":"--post301","slug":"post301"},{"level":3,"title":"--post302","slug":"post302"},{"level":3,"title":"--post303","slug":"post303"},{"level":2,"title":"-P(--ftp-port ADR)","slug":"p-ftp-port-adr"},{"level":3,"title":"--ftp-skip-pasv-ip","slug":"ftp-skip-pasv-ip"},{"level":3,"title":"--ftp-pret","slug":"ftp-pret"},{"level":3,"title":"--ftp-ssl-ccc","slug":"ftp-ssl-ccc"},{"level":3,"title":"--ftp-ssl-ccc-mode","slug":"ftp-ssl-ccc-mode"},{"level":3,"title":"--ftp-ssl-control","slug":"ftp-ssl-control"},{"level":2,"title":"-p(--proxytunne)","slug":"p-proxytunne"},{"level":3,"title":"--pubkey KEY","slug":"pubkey-key"},{"level":2,"title":"-Q(--quote CMD)","slug":"q-quote-cmd"},{"level":3,"title":"--random-file FILE","slug":"random-file-file"},{"level":2,"title":"-q(--data)","slug":"q-data"},{"level":2,"title":"-R(--remote-time)","slug":"r-remote-time"},{"level":2,"title":"-r(--range RANGE)","slug":"r-range-range"},{"level":3,"title":"--raw","slug":"raw"},{"level":2,"title":"-S(--show-error)","slug":"s-show-error"},{"level":2,"title":"-s(--silent)","slug":"s-silent"},{"level":3,"title":"--socks4 HOST[:PORT]","slug":"socks4-host-port"},{"level":3,"title":"--socks4a HOST[:PORT]","slug":"socks4a-host-port"},{"level":3,"title":"--socks5 HOST[:PORT]","slug":"socks5-host-port"},{"level":3,"title":"--socks5-hostname HOST[:PORT]","slug":"socks5-hostname-host-port"},{"level":3,"title":"--socks5-gssapi-service NAME","slug":"socks5-gssapi-service-name"},{"level":3,"title":"--socks5-gssapi-nec","slug":"socks5-gssapi-nec"},{"level":2,"title":"-T(--upload-file FILE)","slug":"t-upload-file-file"},{"level":3,"title":"--url URL","slug":"url-url"},{"level":2,"title":"-t(--telnet-option OPT=VAL)","slug":"t-telnet-option-opt-val"},{"level":3,"title":"--tftp-blksize VALUE","slug":"tftp-blksize-value"},{"level":2,"title":"-U(--proxy-user USER[:PASSWORD])","slug":"u-proxy-user-user-password"},{"level":3,"title":"--proxy1.0 HOST[:PORT]","slug":"proxy1-0-host-port"},{"level":2,"title":"-u(--user USER[:PASSWORD])","slug":"u-user-user-password"},{"level":3,"title":"--tlsuser USER","slug":"tlsuser-user"},{"level":3,"title":"--tlspassword STRING","slug":"tlspassword-string"},{"level":3,"title":"--tlsauthtype STRING","slug":"tlsauthtype-string"},{"level":3,"title":"--unix-socket FILE","slug":"unix-socket-file"},{"level":2,"title":"-V(--version)","slug":"v-version"},{"level":2,"title":"-v(--verbose)","slug":"v-verbose"},{"level":2,"title":"-w(--write-out FORMAT)","slug":"w-write-out-format"},{"level":3,"title":"--xattr","slug":"xattr"},{"level":2,"title":"-X(--request COMMAND)","slug":"x-request-command"},{"level":3,"title":"--resolve HOST:PORT:ADDRESS","slug":"resolve-host-port-address"},{"level":3,"title":"--retry NUM","slug":"retry-num"},{"level":3,"title":"--retry-delay SECONDS","slug":"retry-delay-seconds"},{"level":3,"title":"--retry-max-time SECONDS","slug":"retry-max-time-seconds"},{"level":2,"title":"-x(--proxy [PROTOCOL://]HOST[:PORT])","slug":"x-proxy-protocol-host-port"},{"level":3,"title":"--proxy-anyauth","slug":"proxy-anyauth"},{"level":3,"title":"--proxy-basic","slug":"proxy-basic"},{"level":3,"title":"--proxy-digest","slug":"proxy-digest"},{"level":3,"title":"--proxy-negotiate","slug":"proxy-negotiate"},{"level":3,"title":"--proxy-ntlm","slug":"proxy-ntlm"},{"level":2,"title":"-Y(--speed-limit RATE)","slug":"y-speed-limit-rate"},{"level":2,"title":"-y(--speed-time SECONDS)","slug":"y-speed-time-seconds"},{"level":3,"title":"--ssl","slug":"ssl"},{"level":3,"title":"--ssl-reqd","slug":"ssl-reqd"},{"level":2,"title":"-z(--time-cond TIME)","slug":"z-time-cond-time"},{"level":2,"title":"-#(--progress-bar)","slug":"progress-bar"},{"level":3,"title":"--proto PROTOCOLS","slug":"proto-protocols"},{"level":3,"title":"--proto-redir PROTOCOLS","slug":"proto-redir-protocols"},{"level":2,"title":"-1(--tlsv1)","slug":"_1-tlsv1"},{"level":3,"title":"--tlsv1.0","slug":"tlsv1-0"},{"level":3,"title":"--tlsv1.1","slug":"tlsv1-1"},{"level":3,"title":"--tlsv1.2","slug":"tlsv1-2"},{"level":3,"title":"--trace FILE","slug":"trace-file"},{"level":3,"title":"--trace-ascii FILE","slug":"trace-ascii-file"},{"level":3,"title":"--trace-time","slug":"trace-time"},{"level":3,"title":"--tr-encoding","slug":"tr-encoding"},{"level":2,"title":"-2(--sslv2)","slug":"_2-sslv2"},{"level":2,"title":"-3(--sslv3)","slug":"_3-sslv3"},{"level":3,"title":"--ssl-allow-beast","slug":"ssl-allow-beast"},{"level":3,"title":"--stderr FILE","slug":"stderr-file"},{"level":3,"title":"--tcp-nodelay","slug":"tcp-nodelay"}],"relativePath":"front-end/swagger-hub/curl.md","lastUpdated":1627034651629}',l={},s=t('<div class="warning custom-block"><p class="custom-block-title">注意</p><blockquote><p>如果安装了git的话，则不需要再安装curl，因为git已经帮你安装好了</p><blockquote><p>但是，git安装的curl版本较低--git(v2.32.0)的curl(v7.55.0)</p></blockquote></blockquote><p>百度下载并按照网上教程配置好curl环境变量后，在Windows Poweshell中调用<code>curl + 参数</code>（例如<code>curl -h</code>）始终提示不对。应该是<code>curl.exe + 参数</code>（例如<code>curl.exe -h</code>）</p></div><div class="tip custom-block"><p class="custom-block-title">提示</p><p>以下内容源于<a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener noreferrer"><strong><u>阮一峰 curl的用法指南</u></strong></a>。但由于阮老师久未更新此篇，因此有许多命令已经不适用。本篇是curl的最新版-7.78.0，用以日常使用查看!</p></div><blockquote><p>用法：<code>curl [options...] &lt;url&gt;</code></p></blockquote><p>不带有任何参数时，curl 就是发出 GET 请求。</p><div class="language-bash"><pre><code>$ <span class="token function">curl</span> https://www.baidu.com\n</code></pre></div><p>上面命令向www.baidu.com发出 GET 请求，服务器返回的内容会在命令行输出。</p><h2 id="a-user-agent"><a class="header-anchor" href="#a-user-agent" aria-hidden="true">#</a> -A(--user-agent)</h2><blockquote><p>要发送到服务器的 User-Agent</p></blockquote><p>-A参数指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -A <span class="token string">&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39;</span> https://google.com\n</code></pre></div><p>上面命令将User-Agent改成 Chrome 浏览器。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -A <span class="token string">&#39;&#39;</span> https://google.com\n</code></pre></div><p>上面命令会移除User-Agent标头。</p><p>也可以通过-H参数直接指定标头，更改User-Agent。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -H <span class="token string">&#39;User-Agent: php/1.0&#39;</span> https://google.com\n</code></pre></div><h2 id="a-append"><a class="header-anchor" href="#a-append" aria-hidden="true">#</a> -a(--append)</h2><blockquote><p>添加要上传的文件</p></blockquote><h3 id="basic"><a class="header-anchor" href="#basic" aria-hidden="true">#</a> --basic</h3><blockquote><p>使用HTTP基础认证（Basic Authentication）</p></blockquote><h3 id="cacert-file"><a class="header-anchor" href="#cacert-file" aria-hidden="true">#</a> --cacert FILE</h3><blockquote><p>CA 证书，用于每次请求认证</p></blockquote><h3 id="capath-dir"><a class="header-anchor" href="#capath-dir" aria-hidden="true">#</a> --capath DIR</h3><blockquote><p>CA 证书目录</p></blockquote><h3 id="aws-sigv4-provider1-provider2-region-service"><a class="header-anchor" href="#aws-sigv4-provider1-provider2-region-service" aria-hidden="true">#</a> --aws-sigv4 [provider1[:provider2[:region[:service]]]]</h3><blockquote><p>使用AWS V4签名认证</p></blockquote><h2 id="b-use-ascii"><a class="header-anchor" href="#b-use-ascii" aria-hidden="true">#</a> -B(--use-ascii)</h2><blockquote><p>使用ASCII/text传输</p></blockquote><h2 id="b-cookie-string-file"><a class="header-anchor" href="#b-cookie-string-file" aria-hidden="true">#</a> -b(--cookie STRING/FILE)</h2><blockquote><p>Cookies字符串或读取Cookies的文件位置</p></blockquote><p>-b参数用来向服务器发送 Cookie。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -b <span class="token string">&#39;session=abcdef&#39;</span> https://google.com\n</code></pre></div><p>上面命令会生成一个标头Cookie: session=abcdef，向服务器发送一个名为session、值为abcdef的 Cookie。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -b <span class="token string">&#39;session=abcdef&#39;</span> -b <span class="token string">&#39;loggedin=true&#39;</span> https://google.com\n</code></pre></div><p>上面命令发送两个 Cookie。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -b cookies.txt https://www.google.com\n</code></pre></div><p>上面命令读取本地文件cookies.txt，里面是服务器设置的 Cookie（参见<a href="#c-cookie-jar">-c参数</a>），将其发送到服务器。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -c cookies.txt https://www.google.com\n</code></pre></div><h2 id="c-continue-at-offset"><a class="header-anchor" href="#c-continue-at-offset" aria-hidden="true">#</a> -C(--continue-at OFFSET)</h2><blockquote><p>断点续转</p></blockquote><h2 id="c-cookie-jar-file"><a class="header-anchor" href="#c-cookie-jar-file" aria-hidden="true">#</a> -c(--cookie-jar FILE)</h2><blockquote><p>操作结束后，要写入 Cookies 的文件位置</p></blockquote><p>-c参数将服务器设置的 Cookie 写入一个文件。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -c cookies.txt https://www.google.com\n</code></pre></div><p>上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。</p><h3 id="create-dirs"><a class="header-anchor" href="#create-dirs" aria-hidden="true">#</a> --create-dirs</h3><blockquote><p>创建必要的本地目录层次结构</p></blockquote><h3 id="crlf"><a class="header-anchor" href="#crlf" aria-hidden="true">#</a> --crlf</h3><blockquote><p>在上传时将 LF 转写为 CRLF</p></blockquote><h3 id="crlfile-file"><a class="header-anchor" href="#crlfile-file" aria-hidden="true">#</a> --crlfile FILE</h3><blockquote><p>从指定的文件获得PEM格式CRL列表</p></blockquote><h2 id="d-dump-header-file"><a class="header-anchor" href="#d-dump-header-file" aria-hidden="true">#</a> -D(--dump-header FILE)</h2><blockquote><p>将头信息写入指定的文件</p></blockquote><h3 id="egd-file-file"><a class="header-anchor" href="#egd-file-file" aria-hidden="true">#</a> --egd-file FILE</h3><blockquote><p>为随机数据设置EGD socket路径(SSL)</p></blockquote><h3 id="engine-enginge"><a class="header-anchor" href="#engine-enginge" aria-hidden="true">#</a> --engine ENGINGE</h3><blockquote><p>加密引擎 (SSL). &quot;--engine list&quot; 指定列表</p></blockquote><h2 id="d-data-data"><a class="header-anchor" href="#d-data-data" aria-hidden="true">#</a> -d(--data DATA)</h2><blockquote><p>HTTP POST 数据</p></blockquote><p>-d参数用于发送 POST 请求的数据体。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -d<span class="token string">&#39;login=emma＆password=123&#39;</span>-X POST https://google.com/login\n<span class="token comment"># 或者</span>\n<span class="token function">curl</span> -d <span class="token string">&#39;login=emma&#39;</span> -d <span class="token string">&#39;password=123&#39;</span> -X POST  https://google.com/login\n</code></pre></div><p>使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。</p><p>-d参数可以读取本地文本文件的数据，向服务器发送。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -d <span class="token string">&#39;@data.txt&#39;</span> https://google.com/login\n</code></pre></div><p>上面命令读取data.txt文件的内容，作为数据体向服务器发送。</p><h3 id="data-urlencode-data"><a class="header-anchor" href="#data-urlencode-data" aria-hidden="true">#</a> --data-urlencode DATA</h3><blockquote><p>url 编码 HTTP POST 数据</p></blockquote><p>--data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p><div class="language-bash"><pre><code><span class="token function">curl</span> --data-urlencode <span class="token string">&#39;comment=hello world&#39;</span> https://google.com/login\n</code></pre></div><p>上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。</p><h3 id="data-ascii-data"><a class="header-anchor" href="#data-ascii-data" aria-hidden="true">#</a> --data-ascii DATA</h3><blockquote><p>ASCII 编码 HTTP POST 数据</p></blockquote><h3 id="data-binary-data"><a class="header-anchor" href="#data-binary-data" aria-hidden="true">#</a> --data-binary DATA</h3><blockquote><p>binary 编码 HTTP POST 数据</p></blockquote><h3 id="delegation-string"><a class="header-anchor" href="#delegation-string" aria-hidden="true">#</a> --delegation STRING</h3><blockquote><p>GSS-API 委托权限</p></blockquote><h3 id="digest"><a class="header-anchor" href="#digest" aria-hidden="true">#</a> --digest`</h3><blockquote><p>使用数字身份验证</p></blockquote><h3 id="disable-eprt"><a class="header-anchor" href="#disable-eprt" aria-hidden="true">#</a> --disable-eprt</h3><blockquote><p>禁止使用 EPRT 或 LPRT</p></blockquote><h3 id="disable-epsv"><a class="header-anchor" href="#disable-epsv" aria-hidden="true">#</a> --disable-epsv</h3><blockquote><p>禁止使用 EPSV</p></blockquote><h2 id="e-cert-cert-passwd"><a class="header-anchor" href="#e-cert-cert-passwd" aria-hidden="true">#</a> -E(--cert CERT[:PASSWD])</h2><blockquote><p>客户端证书文件及密码</p></blockquote><h3 id="cert-type-type"><a class="header-anchor" href="#cert-type-type" aria-hidden="true">#</a> --cert-type TYPE</h3><blockquote><p>证书文件类型 (DER/PEM/ENG)</p></blockquote><h3 id="ciphers-list"><a class="header-anchor" href="#ciphers-list" aria-hidden="true">#</a> --ciphers LIST</h3><blockquote><p>SSL 秘钥</p></blockquote><h3 id="compressed"><a class="header-anchor" href="#compressed" aria-hidden="true">#</a> --compressed</h3><blockquote><p>请求压缩 (使用 deflate 或 gzip)</p></blockquote><h2 id="e-referer"><a class="header-anchor" href="#e-referer" aria-hidden="true">#</a> -e(--referer)</h2><blockquote><p>Referer URL</p></blockquote><p>-e参数用来设置 HTTP 的标头Referer，表示请求的来源。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -e <span class="token string">&#39;https://google.com?q=example&#39;</span> https://www.example.com\n</code></pre></div><p>上面命令将Referer标头设为https://google.com?q=example。</p><p>-H参数可以通过直接添加标头Referer，达到同样效果。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -H <span class="token string">&#39;Referer: https://google.com?q=example&#39;</span> https://www.example.com\n</code></pre></div><h2 id="f-form-content"><a class="header-anchor" href="#f-form-content" aria-hidden="true">#</a> -F(--form CONTENT)</h2><blockquote><p>模拟 HTTP 表单数据提交（multipart POST）</p></blockquote><p>-F参数用来向服务器上传二进制文件。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -F <span class="token string">&#39;file=@photo.png&#39;</span> https://google.com/profile\n</code></pre></div><p>上面命令会给 HTTP 请求加上标头Content-Type: multipart/form-data，然后将文件photo.png作为file字段上传。</p><p>-F参数可以指定 MIME 类型。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -F <span class="token string">&#39;file=@photo.png;type=image/png&#39;</span> https://google.com/profile\n</code></pre></div><p>上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为application/octet-stream。</p><p>-F参数也可以指定文件名。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -F <span class="token string">&#39;file=@photo.png;filename=me.png&#39;</span> https://google.com/profile\n</code></pre></div><p>上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。</p><h3 id="form-string-string"><a class="header-anchor" href="#form-string-string" aria-hidden="true">#</a> --form-string STRING</h3><blockquote><p>模拟 HTTP 表单数据提交</p></blockquote><h3 id="ftp-account-data"><a class="header-anchor" href="#ftp-account-data" aria-hidden="true">#</a> --ftp-account DATA</h3><blockquote><p>帐户数据提交</p></blockquote><h3 id="ftp-alternative-to-user-command"><a class="header-anchor" href="#ftp-alternative-to-user-command" aria-hidden="true">#</a> --ftp-alternative-to-user COMMAND</h3><blockquote><p>指定替换 &quot;USER [name]&quot; 的字符串</p></blockquote><h3 id="ftp-create-dirs"><a class="header-anchor" href="#ftp-create-dirs" aria-hidden="true">#</a> --ftp-create-dirs</h3><blockquote><p>如果不存在则创建远程目录</p></blockquote><h3 id="ftp-method"><a class="header-anchor" href="#ftp-method" aria-hidden="true">#</a> --ftp-method</h3><blockquote><p>[MULTICWD/NOCWD/SINGLECWD] 控制 CWD</p></blockquote><h3 id="ftp-pasv"><a class="header-anchor" href="#ftp-pasv" aria-hidden="true">#</a> --ftp-pasv</h3><blockquote><p>使用 PASV/EPSV 替换 PORT</p></blockquote><h2 id="f-fail"><a class="header-anchor" href="#f-fail" aria-hidden="true">#</a> -f(--fail)</h2><blockquote><p>连接失败时不显示HTTP错误信息</p></blockquote><h2 id="g-get"><a class="header-anchor" href="#g-get" aria-hidden="true">#</a> -G(--get)</h2><blockquote><p>使用 HTTP GET 方法发送 -d 数据</p></blockquote><p>-G参数用来构造 URL 的查询字符串。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -G -d <span class="token string">&#39;q=kitties&#39;</span> -d <span class="token string">&#39;count=20&#39;</span> https://google.com/search\n</code></pre></div><p>上面命令会发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties&amp;count=20。如果省略--G，会发出一个 POST 请求。</p><p>如果数据需要 URL 编码，可以结合--data--urlencode参数。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -G --data-urlencode <span class="token string">&#39;comment=hello world&#39;</span> https://www.example.com\n</code></pre></div><h2 id="g-globoff"><a class="header-anchor" href="#g-globoff" aria-hidden="true">#</a> -g(--globoff)</h2><blockquote><p>禁用的 URL 队列 及范围使用 {} 和 []</p></blockquote><h2 id="h-header-line"><a class="header-anchor" href="#h-header-line" aria-hidden="true">#</a> -H(--header LINE)</h2><blockquote><p>要发送到服务端的自定义请求头</p></blockquote><p>-H参数添加 HTTP 请求的标头。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -H <span class="token string">&#39;Accept-Language: en-US&#39;</span> https://google.com\n</code></pre></div><p>上面命令添加 HTTP 标头Accept-Language: en-US。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -H <span class="token string">&#39;Accept-Language: en-US&#39;</span> -H <span class="token string">&#39;Secret-Message: xyzzy&#39;</span> https://google.com\n</code></pre></div><p>上面命令添加两个 HTTP 标头。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -d <span class="token string">&#39;{&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;}&#39;</span> -H <span class="token string">&#39;Content-Type: application/json&#39;</span> https://google.com/login\n</code></pre></div><p>上面命令添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。</p><h2 id="h-help"><a class="header-anchor" href="#h-help" aria-hidden="true">#</a> -h(--help)</h2><blockquote><p>显示帮助</p></blockquote><h2 id="i-head"><a class="header-anchor" href="#i-head" aria-hidden="true">#</a> -I(--head)</h2><blockquote><p>仅显示响应文档头</p></blockquote><p>-I参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -I https://www.example.com\n</code></pre></div><p>上面命令输出服务器对 HEAD 请求的回应。</p><p>--head参数等同于-I。</p><div class="language-bash"><pre><code><span class="token function">curl</span> --head https://www.example.com\n</code></pre></div><h2 id="i-include"><a class="header-anchor" href="#i-include" aria-hidden="true">#</a> -i(--include)</h2><blockquote><p>在输出中包含协议头</p></blockquote><p>-i参数打印出服务器回应的 HTTP 标头。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -i https://www.example.com\n</code></pre></div><p>上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。</p><h2 id="j-remote-header-name"><a class="header-anchor" href="#j-remote-header-name" aria-hidden="true">#</a> -J(--remote-header-name)</h2><blockquote><p>从远程文件读取头信息</p></blockquote><h2 id="j-junk-session-cookies"><a class="header-anchor" href="#j-junk-session-cookies" aria-hidden="true">#</a> -j(--junk-session-cookies)</h2><blockquote><p>读取文件中但忽略会话cookie</p></blockquote><h3 id="keepalive-time-seconds"><a class="header-anchor" href="#keepalive-time-seconds" aria-hidden="true">#</a> --keepalive-time SECONDS</h3><blockquote><p>keepalive 包间隔</p></blockquote><h3 id="key-key"><a class="header-anchor" href="#key-key" aria-hidden="true">#</a> --key KEY</h3><blockquote><p>私钥文件名 (SSL/SSH)</p></blockquote><h3 id="key-type-type"><a class="header-anchor" href="#key-type-type" aria-hidden="true">#</a> --key-type TYPE</h3><blockquote><p>私钥文件类型 (DER/PEM/ENG) (SSL)</p></blockquote><h3 id="krb-level"><a class="header-anchor" href="#krb-level" aria-hidden="true">#</a> --krb LEVEL</h3><blockquote><p>启用指定安全级别的 Kerberos</p></blockquote><h3 id="libcurl-file"><a class="header-anchor" href="#libcurl-file" aria-hidden="true">#</a> --libcurl FILE</h3><blockquote><p>命令的libcurl等价代码</p></blockquote><h3 id="limit-rate-rate"><a class="header-anchor" href="#limit-rate-rate" aria-hidden="true">#</a> --limit-rate RATE</h3><blockquote><p>限制传输速度</p></blockquote><h2 id="k-config-file"><a class="header-anchor" href="#k-config-file" aria-hidden="true">#</a> -K(--config FILE)</h2><blockquote><p>指定配置文件</p></blockquote><h3 id="connect-timeout-seconds"><a class="header-anchor" href="#connect-timeout-seconds" aria-hidden="true">#</a> --connect-timeout SECONDS</h3><blockquote><p>连接超时设置</p></blockquote><h2 id="k-insecure"><a class="header-anchor" href="#k-insecure" aria-hidden="true">#</a> -k(--insecure)</h2><blockquote><p>允许连接到 SSL 站点，而不使用证书</p></blockquote><p>-k参数指定跳过 SSL 检测。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -k https://www.example.com\n</code></pre></div><p>上面命令不会检查服务器的 SSL 证书是否正确。</p><h3 id="interface-interfac"><a class="header-anchor" href="#interface-interfac" aria-hidden="true">#</a> --interface INTERFAC</h3><blockquote><p>指定网络接口／地址</p></blockquote><h2 id="l-location"><a class="header-anchor" href="#l-location" aria-hidden="true">#</a> -L(--location)</h2><blockquote><p>跟踪重定向</p></blockquote><p>-L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -L -d <span class="token string">&#39;tweet=hi&#39;</span> https://api.twitter.com/tweet\n</code></pre></div><h3 id="location-trusted"><a class="header-anchor" href="#location-trusted" aria-hidden="true">#</a> --location-trusted</h3><blockquote><p>类似 --location 并发送验证信息到其它主机</p></blockquote><h2 id="l-list-only"><a class="header-anchor" href="#l-list-only" aria-hidden="true">#</a> -l(--list-only)</h2><blockquote><p>只列出FTP目录的名称</p></blockquote><h3 id="limit-rate-range"><a class="header-anchor" href="#limit-rate-range" aria-hidden="true">#</a> --limit-rate RANGE</h3><blockquote><p>类似 --location 并发送验证信息到其它主机</p></blockquote><p>--limit-rate用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。</p><div class="language-bash"><pre><code><span class="token function">curl</span> --limit-rate 200k https://google.com\n</code></pre></div><p>上面命令将带宽限制在每秒 200K 字节。</p><h2 id="m-manual"><a class="header-anchor" href="#m-manual" aria-hidden="true">#</a> -M(--manual)</h2><blockquote><p>显示全手动</p></blockquote><h3 id="mail-from-from"><a class="header-anchor" href="#mail-from-from" aria-hidden="true">#</a> --mail-from FROM</h3><blockquote><p>从这个地址发送邮件</p></blockquote><h3 id="mail-rcpt-to"><a class="header-anchor" href="#mail-rcpt-to" aria-hidden="true">#</a> --mail-rcpt TO</h3><blockquote><p>发送邮件到这个接收人(s)</p></blockquote><h3 id="mail-auth-auth"><a class="header-anchor" href="#mail-auth-auth" aria-hidden="true">#</a> --mail-auth AUTH</h3><blockquote><p>原始电子邮件的起始地址</p></blockquote><h3 id="max-filesize-bytes"><a class="header-anchor" href="#max-filesize-bytes" aria-hidden="true">#</a> --max-filesize BYTES</h3><blockquote><p>下载的最大文件大小 (H/F)</p></blockquote><h3 id="max-redirs-num"><a class="header-anchor" href="#max-redirs-num" aria-hidden="true">#</a> --max-redirs NUM</h3><blockquote><p>最大重定向数 (H)</p></blockquote><h2 id="m-max-time-seconds"><a class="header-anchor" href="#m-max-time-seconds" aria-hidden="true">#</a> -m(--max-time SECONDS)</h2><blockquote><p>允许的最多传输时间</p></blockquote><h3 id="metalink"><a class="header-anchor" href="#metalink" aria-hidden="true">#</a> --metalink</h3><blockquote><p>处理指定的URL上的XML文件</p></blockquote><h3 id="negotiate"><a class="header-anchor" href="#negotiate" aria-hidden="true">#</a> --negotiate</h3><blockquote><p>使用 HTTP Negotiate 认证</p></blockquote><h2 id="n-netrc"><a class="header-anchor" href="#n-netrc" aria-hidden="true">#</a> -N(--netrc)</h2><blockquote><p>必须从 .netrc 文件读取用户名和密码</p></blockquote><h3 id="netrc-optional"><a class="header-anchor" href="#netrc-optional" aria-hidden="true">#</a> --netrc-optional</h3><blockquote><p>使用 .netrc 或 URL; 将重写 -n 参数</p></blockquote><h3 id="netrc-file-file"><a class="header-anchor" href="#netrc-file-file" aria-hidden="true">#</a> --netrc-file FILE</h3><blockquote><p>设置要使用的 netrc 文件名</p></blockquote><h2 id="n-no-buffer"><a class="header-anchor" href="#n-no-buffer" aria-hidden="true">#</a> -n(--no-buffer)</h2><blockquote><p>禁用输出流的缓存</p></blockquote><h3 id="no-keepalive"><a class="header-anchor" href="#no-keepalive" aria-hidden="true">#</a> --no-keepalive</h3><blockquote><p>禁用 connection 的 keepalive</p></blockquote><h3 id="no-sessionid"><a class="header-anchor" href="#no-sessionid" aria-hidden="true">#</a> --no-sessionid</h3><blockquote><p>禁止重复使用 SSL session-ID (SSL)</p></blockquote><h3 id="noproxy"><a class="header-anchor" href="#noproxy" aria-hidden="true">#</a> --noproxy</h3><blockquote><p>不使用代理的主机列表</p></blockquote><h3 id="ntlm"><a class="header-anchor" href="#ntlm" aria-hidden="true">#</a> --ntlm</h3><blockquote><p>使用 HTTP NTLM 认证</p></blockquote><h2 id="o-remote-name"><a class="header-anchor" href="#o-remote-name" aria-hidden="true">#</a> -O(--remote-name)</h2><blockquote><p>将输出写入远程文件</p></blockquote><p>-O参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -O https://www.example.com/foo/bar.html\n</code></pre></div><p>上面命令将服务器回应保存成文件，文件名为bar.html。</p><h3 id="remote-name-all"><a class="header-anchor" href="#remote-name-all" aria-hidden="true">#</a> --remote-name-all</h3><blockquote><p>使用所有URL的远程文件名</p></blockquote><h2 id="o-output-file"><a class="header-anchor" href="#o-output-file" aria-hidden="true">#</a> -o(--output FILE)</h2><blockquote><p>将输出写入文件，而非 stdout</p></blockquote><p>-o参数将服务器的回应保存成文件，等同于wget命令。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -o example.html https://www.example.com\n</code></pre></div><p>上面命令将www.example.com保存成example.html。</p><h3 id="pass-pass"><a class="header-anchor" href="#pass-pass" aria-hidden="true">#</a> --pass PASS</h3><blockquote><p>传递给私钥的短语 (SSL/SSH)</p></blockquote><h3 id="post301"><a class="header-anchor" href="#post301" aria-hidden="true">#</a> --post301</h3><blockquote><p>在 301 重定向后不要切换为 GET 请求</p></blockquote><h3 id="post302"><a class="header-anchor" href="#post302" aria-hidden="true">#</a> --post302</h3><blockquote><p>在 302 重定向后不要切换为 GET 请求</p></blockquote><h3 id="post303"><a class="header-anchor" href="#post303" aria-hidden="true">#</a> --post303</h3><blockquote><p>在 303 重定向后不要切换为 GET 请求</p></blockquote><h2 id="p-ftp-port-adr"><a class="header-anchor" href="#p-ftp-port-adr" aria-hidden="true">#</a> -P(--ftp-port ADR)</h2><blockquote><p>使用指定 PORT 及地址替换 PASV</p></blockquote><h3 id="ftp-skip-pasv-ip"><a class="header-anchor" href="#ftp-skip-pasv-ip" aria-hidden="true">#</a> --ftp-skip-pasv-ip</h3><blockquote><p>跳过 PASV 的IP地址</p></blockquote><h3 id="ftp-pret"><a class="header-anchor" href="#ftp-pret" aria-hidden="true">#</a> --ftp-pret</h3><blockquote><p>在 PASV 之前发送 PRET (drftpd)</p></blockquote><h3 id="ftp-ssl-ccc"><a class="header-anchor" href="#ftp-ssl-ccc" aria-hidden="true">#</a> --ftp-ssl-ccc</h3><blockquote><p>在认证之后发送 CCC</p></blockquote><h3 id="ftp-ssl-ccc-mode"><a class="header-anchor" href="#ftp-ssl-ccc-mode" aria-hidden="true">#</a> --ftp-ssl-ccc-mode</h3><blockquote><p>ACTIVE/PASSIVE 设置 CCC 模式</p></blockquote><h3 id="ftp-ssl-control"><a class="header-anchor" href="#ftp-ssl-control" aria-hidden="true">#</a> --ftp-ssl-control</h3><blockquote><p>ftp 登录时需要 SSL/TLS</p></blockquote><h2 id="p-proxytunne"><a class="header-anchor" href="#p-proxytunne" aria-hidden="true">#</a> -p(--proxytunne)</h2><blockquote><p>使用HTTP代理 (用于 CONNECT)</p></blockquote><h3 id="pubkey-key"><a class="header-anchor" href="#pubkey-key" aria-hidden="true">#</a> --pubkey KEY</h3><blockquote><p>公钥文件名 (SSH)</p></blockquote><h2 id="q-quote-cmd"><a class="header-anchor" href="#q-quote-cmd" aria-hidden="true">#</a> -Q(--quote CMD)</h2><blockquote><p>在传输开始前向服务器发送命令</p></blockquote><h3 id="random-file-file"><a class="header-anchor" href="#random-file-file" aria-hidden="true">#</a> --random-file FILE</h3><blockquote><p>读取随机数据的文件 (SSL)</p></blockquote><h2 id="q-data"><a class="header-anchor" href="#q-data" aria-hidden="true">#</a> -q(--data)</h2><blockquote><p>.curlrc 如果作为第一个参数无效</p></blockquote><h2 id="r-remote-time"><a class="header-anchor" href="#r-remote-time" aria-hidden="true">#</a> -R(--remote-time)</h2><blockquote><p>将远程文件的时间设置在本地输出上</p></blockquote><h2 id="r-range-range"><a class="header-anchor" href="#r-range-range" aria-hidden="true">#</a> -r(--range RANGE)</h2><blockquote><p>仅检索范围内的字节</p></blockquote><h3 id="raw"><a class="header-anchor" href="#raw" aria-hidden="true">#</a> --raw</h3><blockquote><p>使用原始HTTP传输，而不使用编码</p></blockquote><h2 id="s-show-error"><a class="header-anchor" href="#s-show-error" aria-hidden="true">#</a> -S(--show-error)</h2><blockquote><p>显示错误. 在选项 -s 中，当 curl 出现错误时将显示</p></blockquote><p>-S参数指定只输出错误信息，通常与-s一起使用。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -s -o /dev/null https://google.com\n</code></pre></div><p>上面命令没有任何输出，除非发生错误。</p><h2 id="s-silent"><a class="header-anchor" href="#s-silent" aria-hidden="true">#</a> -s(--silent)</h2><blockquote><p>Silent模式。不输出任务内容</p></blockquote><p>-s参数将不输出错误和进度信息。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -s https://www.example.com\n</code></pre></div><p>上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。</p><p>如果想让 curl 不产生任何输出，可以使用下面的命令。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -s -o /dev/null https://google.com\n</code></pre></div><h3 id="socks4-host-port"><a class="header-anchor" href="#socks4-host-port" aria-hidden="true">#</a> --socks4 HOST[:PORT]</h3><blockquote><p>在指定的 host + port 上使用 SOCKS4 代理</p></blockquote><h3 id="socks4a-host-port"><a class="header-anchor" href="#socks4a-host-port" aria-hidden="true">#</a> --socks4a HOST[:PORT]</h3><blockquote><p>在指定的 host + port 上使用 SOCKSa 代理</p></blockquote><h3 id="socks5-host-port"><a class="header-anchor" href="#socks5-host-port" aria-hidden="true">#</a> --socks5 HOST[:PORT]</h3><blockquote><p>在指定的 host + port 上使用 SOCKS5 代理</p></blockquote><h3 id="socks5-hostname-host-port"><a class="header-anchor" href="#socks5-hostname-host-port" aria-hidden="true">#</a> --socks5-hostname HOST[:PORT]</h3><blockquote><p>SOCKS5 代理，指定用户名、密码</p></blockquote><h3 id="socks5-gssapi-service-name"><a class="header-anchor" href="#socks5-gssapi-service-name" aria-hidden="true">#</a> --socks5-gssapi-service NAME</h3><blockquote><p>SOCKS5 代理，指定用户名、密码</p></blockquote><h3 id="socks5-gssapi-nec"><a class="header-anchor" href="#socks5-gssapi-nec" aria-hidden="true">#</a> --socks5-gssapi-nec</h3><blockquote><p>与NEC Socks5服务器兼容</p></blockquote><h2 id="t-upload-file-file"><a class="header-anchor" href="#t-upload-file-file" aria-hidden="true">#</a> -T(--upload-file FILE)</h2><blockquote><p>将文件传输（上传）到指定位置</p></blockquote><h3 id="url-url"><a class="header-anchor" href="#url-url" aria-hidden="true">#</a> --url URL</h3><blockquote><p>指定所使用的 URL</p></blockquote><h2 id="t-telnet-option-opt-val"><a class="header-anchor" href="#t-telnet-option-opt-val" aria-hidden="true">#</a> -t(--telnet-option OPT=VAL)</h2><blockquote><p>设置 telnet 选项</p></blockquote><h3 id="tftp-blksize-value"><a class="header-anchor" href="#tftp-blksize-value" aria-hidden="true">#</a> --tftp-blksize VALUE</h3><blockquote><p>设备 TFTP BLKSIZE 选项 (必须 &gt;512)</p></blockquote><h2 id="u-proxy-user-user-password"><a class="header-anchor" href="#u-proxy-user-user-password" aria-hidden="true">#</a> -U(--proxy-user USER[:PASSWORD])</h2><blockquote><p>代理用户名及密码</p></blockquote><h3 id="proxy1-0-host-port"><a class="header-anchor" href="#proxy1-0-host-port" aria-hidden="true">#</a> --proxy1.0 HOST[:PORT]</h3><blockquote><p>在指定的端口上使用 HTTP/1.0 代理</p></blockquote><h2 id="u-user-user-password"><a class="header-anchor" href="#u-user-user-password" aria-hidden="true">#</a> -u(--user USER[:PASSWORD])</h2><blockquote><p>指定服务器认证用户名、密码</p></blockquote><p>-u参数用来设置服务器认证的用户名和密码。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -u <span class="token string">&#39;bob:12345&#39;</span> https://google.com/login\n</code></pre></div><p>上面命令设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。</p><p>curl 能够识别 URL 里面的用户名和密码。</p><div class="language-bash"><pre><code><span class="token function">curl</span> https://bob:12345@google.com/login\n</code></pre></div><p>上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -u <span class="token string">&#39;bob&#39;</span> https://google.com/login\n</code></pre></div><p>上面命令只设置了用户名，执行后，curl 会提示用户输入密码。</p><h3 id="tlsuser-user"><a class="header-anchor" href="#tlsuser-user" aria-hidden="true">#</a> --tlsuser USER</h3><blockquote><p>TLS 用户名</p></blockquote><h3 id="tlspassword-string"><a class="header-anchor" href="#tlspassword-string" aria-hidden="true">#</a> --tlspassword STRING</h3><blockquote><p>TLS 密码</p></blockquote><h3 id="tlsauthtype-string"><a class="header-anchor" href="#tlsauthtype-string" aria-hidden="true">#</a> --tlsauthtype STRING</h3><blockquote><p>TLS 认证类型 (默认 SRP)</p></blockquote><h3 id="unix-socket-file"><a class="header-anchor" href="#unix-socket-file" aria-hidden="true">#</a> --unix-socket FILE</h3><blockquote><p>通过这个 UNIX socket 域连接</p></blockquote><h2 id="v-version"><a class="header-anchor" href="#v-version" aria-hidden="true">#</a> -V(--version)</h2><blockquote><p>显示版本号并退出</p></blockquote><h2 id="v-verbose"><a class="header-anchor" href="#v-verbose" aria-hidden="true">#</a> -v(--verbose)</h2><blockquote><p>显示详细操作信息</p></blockquote><p>-v参数输出通信的整个过程，用于调试。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -v https://www.example.com\n</code></pre></div><p>--trace参数也可以用于调试，还会输出原始的二进制数据。</p><div class="language-bash"><pre><code><span class="token function">curl</span> --trace - https://www.example.com\n</code></pre></div><h2 id="w-write-out-format"><a class="header-anchor" href="#w-write-out-format" aria-hidden="true">#</a> -w(--write-out FORMAT)</h2><blockquote><p>完成后输出什么</p></blockquote><h3 id="xattr"><a class="header-anchor" href="#xattr" aria-hidden="true">#</a> --xattr</h3><blockquote><p>将元数据存储在扩展文件属性中</p></blockquote><h2 id="x-request-command"><a class="header-anchor" href="#x-request-command" aria-hidden="true">#</a> -X(--request COMMAND)</h2><blockquote><p>使用指定的请求命令</p></blockquote><p>-X参数指定 HTTP 请求的方法。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -X POST https://www.example.com\n</code></pre></div><p>上面命令对https://www.example.com发出 POST 请求。</p><h3 id="resolve-host-port-address"><a class="header-anchor" href="#resolve-host-port-address" aria-hidden="true">#</a> --resolve HOST:PORT:ADDRESS</h3><blockquote><p>将 HOST:PORT 强制解析到 ADDRESS</p></blockquote><h3 id="retry-num"><a class="header-anchor" href="#retry-num" aria-hidden="true">#</a> --retry NUM</h3><blockquote><p>出现问题时的重试次数</p></blockquote><h3 id="retry-delay-seconds"><a class="header-anchor" href="#retry-delay-seconds" aria-hidden="true">#</a> --retry-delay SECONDS</h3><blockquote><p>重试时的延时时长</p></blockquote><h3 id="retry-max-time-seconds"><a class="header-anchor" href="#retry-max-time-seconds" aria-hidden="true">#</a> --retry-max-time SECONDS</h3><blockquote><p>仅在指定时间段内重试</p></blockquote><h2 id="x-proxy-protocol-host-port"><a class="header-anchor" href="#x-proxy-protocol-host-port" aria-hidden="true">#</a> -x(--proxy [PROTOCOL://]HOST[:PORT])</h2><blockquote><p>在指定的端口上使用代理</p></blockquote><p>-x参数指定 HTTP 请求的代理。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -x socks5://james:cats@myproxy.com:8080 https://www.example.com\n</code></pre></div><p>上面命令指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。</p><p>如果没有指定代理协议，默认为 HTTP。</p><div class="language-bash"><pre><code><span class="token function">curl</span> -x james:cats@myproxy.com:8080 https://www.example.com\n</code></pre></div><p>上面命令中，请求的代理使用 HTTP 协议。</p><h3 id="proxy-anyauth"><a class="header-anchor" href="#proxy-anyauth" aria-hidden="true">#</a> --proxy-anyauth</h3><blockquote><p>在代理上使用 &quot;any&quot; 认证方法</p></blockquote><h3 id="proxy-basic"><a class="header-anchor" href="#proxy-basic" aria-hidden="true">#</a> --proxy-basic</h3><blockquote><p>在代理上使用 Basic 认证</p></blockquote><h3 id="proxy-digest"><a class="header-anchor" href="#proxy-digest" aria-hidden="true">#</a> --proxy-digest</h3><blockquote><p>在代理上使用 Digest 认证</p></blockquote><h3 id="proxy-negotiate"><a class="header-anchor" href="#proxy-negotiate" aria-hidden="true">#</a> --proxy-negotiate</h3><blockquote><p>在代理上使用 Negotiate 认证</p></blockquote><h3 id="proxy-ntlm"><a class="header-anchor" href="#proxy-ntlm" aria-hidden="true">#</a> --proxy-ntlm</h3><blockquote><p>在代理上使用 NTLM 认证</p></blockquote><h2 id="y-speed-limit-rate"><a class="header-anchor" href="#y-speed-limit-rate" aria-hidden="true">#</a> -Y(--speed-limit RATE)</h2><blockquote><p>在指定限速时间之后停止传输</p></blockquote><h2 id="y-speed-time-seconds"><a class="header-anchor" href="#y-speed-time-seconds" aria-hidden="true">#</a> -y(--speed-time SECONDS)</h2><blockquote><p>指定时间之后触发限速. 默认 30</p></blockquote><h3 id="ssl"><a class="header-anchor" href="#ssl" aria-hidden="true">#</a> --ssl</h3><blockquote><p>尝试 SSL/TLS (FTP, IMAP, POP3, SMTP)</p></blockquote><h3 id="ssl-reqd"><a class="header-anchor" href="#ssl-reqd" aria-hidden="true">#</a> --ssl-reqd</h3><blockquote><p>需要 SSL/TLS (FTP, IMAP, POP3, SMTP)</p></blockquote><h2 id="z-time-cond-time"><a class="header-anchor" href="#z-time-cond-time" aria-hidden="true">#</a> -z(--time-cond TIME)</h2><blockquote><p>基于时间条件的传输</p></blockquote><h2 id="progress-bar"><a class="header-anchor" href="#progress-bar" aria-hidden="true">#</a> -#(--progress-bar)</h2><blockquote><p>以进度条显示传输进度</p></blockquote><h3 id="proto-protocols"><a class="header-anchor" href="#proto-protocols" aria-hidden="true">#</a> --proto PROTOCOLS</h3><blockquote><p>启用/禁用 指定的协议</p></blockquote><h3 id="proto-redir-protocols"><a class="header-anchor" href="#proto-redir-protocols" aria-hidden="true">#</a> --proto-redir PROTOCOLS</h3><blockquote><p>在重定向上 启用/禁用 指定的协议</p></blockquote><h2 id="_1-tlsv1"><a class="header-anchor" href="#_1-tlsv1" aria-hidden="true">#</a> -1(--tlsv1)</h2><blockquote><p>使用 =&gt; TLSv1 (SSL)</p></blockquote><h3 id="tlsv1-0"><a class="header-anchor" href="#tlsv1-0" aria-hidden="true">#</a> --tlsv1.0</h3><blockquote><p>使用 TLSv1.0 (SSL)</p></blockquote><h3 id="tlsv1-1"><a class="header-anchor" href="#tlsv1-1" aria-hidden="true">#</a> --tlsv1.1</h3><blockquote><p>使用 TLSv1.1 (SSL)</p></blockquote><h3 id="tlsv1-2"><a class="header-anchor" href="#tlsv1-2" aria-hidden="true">#</a> --tlsv1.2</h3><blockquote><p>使用 TLSv1.2 (SSL)</p></blockquote><h3 id="trace-file"><a class="header-anchor" href="#trace-file" aria-hidden="true">#</a> --trace FILE</h3><blockquote><p>将 debug 信息写入指定的文件</p></blockquote><h3 id="trace-ascii-file"><a class="header-anchor" href="#trace-ascii-file" aria-hidden="true">#</a> --trace-ascii FILE</h3><blockquote><p>类似 --trace 但使用16进度输出</p></blockquote><h3 id="trace-time"><a class="header-anchor" href="#trace-time" aria-hidden="true">#</a> --trace-time</h3><blockquote><p>向 trace/verbose 输出添加时间戳</p></blockquote><h3 id="tr-encoding"><a class="header-anchor" href="#tr-encoding" aria-hidden="true">#</a> --tr-encoding</h3><blockquote><p>请求压缩传输编码</p></blockquote><h2 id="_2-sslv2"><a class="header-anchor" href="#_2-sslv2" aria-hidden="true">#</a> -2(--sslv2)</h2><blockquote><p>使用 SSLv2 (SSL)</p></blockquote><h2 id="_3-sslv3"><a class="header-anchor" href="#_3-sslv3" aria-hidden="true">#</a> -3(--sslv3)</h2><blockquote><p>使用 SSLv3 (SSL)</p></blockquote><h3 id="ssl-allow-beast"><a class="header-anchor" href="#ssl-allow-beast" aria-hidden="true">#</a> --ssl-allow-beast</h3><blockquote><p>允许的安全漏洞，提高互操作性(SSL)</p></blockquote><h3 id="stderr-file"><a class="header-anchor" href="#stderr-file" aria-hidden="true">#</a> --stderr FILE</h3><blockquote><p>重定向 stderr 的文件位置. - means stdout</p></blockquote><h3 id="tcp-nodelay"><a class="header-anchor" href="#tcp-nodelay" aria-hidden="true">#</a> --tcp-nodelay</h3><blockquote><p>使用 TCP_NODELAY 选项</p></blockquote>',414);l.render=function(t,o,l,r,c,i){return e(),a("div",null,[s])};export default l;export{o as __pageData};
