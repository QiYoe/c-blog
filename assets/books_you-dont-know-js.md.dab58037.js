import{o as l,c as e,a as i}from"./app.4aaaf719.js";const a='{"title":"你不知道的JavaScript","description":"you-dont-know-JS读书笔记","frontmatter":{"title":"你不知道的JavaScript","head":[["meta",{"name":"description","content":"you-dont-know-JS读书笔记"}],["meta",{"name":"keywords","content":"你不知道的JavaScript you-dont-know-JS 你不知道的JS 读书笔记"}]]},"headers":[{"level":2,"title":"作用域和闭包","slug":"作用域和闭包"},{"level":3,"title":"作用域是什么","slug":"作用域是什么"},{"level":3,"title":"词法作用域","slug":"词法作用域"},{"level":3,"title":"函数作用域和块作用域","slug":"函数作用域和块作用域"},{"level":3,"title":"提升","slug":"提升"},{"level":3,"title":"作用域闭包","slug":"作用域闭包"},{"level":2,"title":"this和对象原型","slug":"this和对象原型"}],"relativePath":"books/you-dont-know-js.md","lastUpdated":1622802480770}',r={},o=i('<h2 id="作用域和闭包"><a class="header-anchor" href="#作用域和闭包" aria-hidden="true">#</a> 作用域和闭包</h2><h3 id="作用域是什么"><a class="header-anchor" href="#作用域是什么" aria-hidden="true">#</a> 作用域是什么</h3><p>首先介绍传统编译语言“编译”步骤：</p><ul><li>分词：把我们编写的代码分解。比如var a = 2;，会分解成var、a、=、2、；空格的分解与否取决于空格在语言中有没有意义</li><li>解析：把上一步分解得到的词法单元流（数组）根据嵌套关系（作用域）组成“抽象语法树”（AST）</li><li>生成代码：将AST转为机器可执行指令</li></ul><p><strong>总结：将编写的代码转换位AST，生成机器可执行指令，最后机器执行指令<code>创建变量、存储变量等</code>，实际上JavaScript编译过程也类似如此</strong></p><p>其次介绍js执行程序的“打工人”</p><ul><li>引擎：项目经理，从头到尾参与整个编译和<code>执行</code>过程</li><li>编译器：苦逼程序员，上边编译过程就是它负责处理</li><li>作用域：产品经理，定义一套规则，规定当前执行代码对声明标识符的访问权限</li></ul><p>当来一个新项目时（执行var a = 2;），程序员就要和产品经理开始沟通（撕逼：自行脑部吧🤭）</p><p>代码生成阶段编译器处理var a = 2;流程：</p><ul><li>看到var a，编译器询问<code>当前作用域</code>是否已存在a，存在，则忽略它，继续编译；不存在，则在当前作用域声明变量a（<strong>编译器在当前作用域活动</strong>）</li><li>然后编译器生成引擎运行所需代码（处理a = 2）。引擎运行编译器处理之后的a = 2：引擎询问当前作用域是否已存在a，存在，则使用此a赋值；不存在，则在向上作用域查找a（<strong>引擎在作用域链活动</strong>） <ul><li>类似a = 2这种查找赋值操作<code>目标</code>是LHS查询（<strong>引擎查找</strong>） <ul><li>查询不到时：正常模式-不会报错（<strong>自动生成全局属性a</strong>）；严格模式-ReferenceError</li><li>查到但进行不合理操作（比如获取null或undefined的子属性）：TypeError</li></ul></li><li>类似console.log(2)这种查找赋值操作<code>源头</code>是RHS查询（查询不到时：ReferenceError）（<strong>引擎查找</strong>）</li></ul></li></ul><p><strong>总结：变量赋值时，首先编译器在当前作用域中声明一个变量<code>如果之前没声明过</code>，然后引擎运行时在作用域中查找该变量，能找到就赋值，找不到则抛出异常（此处说的是严格模式，正常模式下不会报错）</strong></p><p>作用域链：作用域层层嵌套（比如函数嵌套函数）。当前作用域中找不到某变量，引擎就会向外层作用域层层查找，直到找到该变量或是在最外层的全局作用域中也没找到时停止查找</p><h3 id="词法作用域"><a class="header-anchor" href="#词法作用域" aria-hidden="true">#</a> 词法作用域</h3><p>作用域有两种工作模型：</p><ul><li>词法作用域（最为普遍）--定义在词法阶段的作用域（也就是说作用域在写代码时就已经决定好了--大部分情况下是这样） <ul><li>词法阶段：即<a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88">上一节</a>说到的<code>分词</code></li><li>查找：引擎执行代码，作用域（作用域气泡更容易理解）层层向上查找变量--<code>遮蔽效应</code>（作用域查找匹配到第一个标识符时停止，即内部标识符”屏蔽“了外部标识符）</li><li>欺骗词法：打破定义在词法阶段的作用域的规则（非常不建议使用：影响性能） <ul><li>eval：在运行修改书写期的词法作用域</li><li>with（废弃）</li></ul></li></ul></li><li>动态作用域（比如Bash、Perl）</li></ul><h3 id="函数作用域和块作用域"><a class="header-anchor" href="#函数作用域和块作用域" aria-hidden="true">#</a> 函数作用域和块作用域</h3><ul><li>函数作用域--不多说，函数内部形成函数自身的作用域（即函数外部无法访问函数内部变量） <ul><li>函数声明--function foo()开头</li><li>函数表达式--非function()开头<code>(function foo(){...}())或foo()</code><ul><li>匿名（不建议）</li><li>具名 <ul><li>IIFE（立即执行函数）</li></ul></li></ul></li></ul></li><li>块作用域：{}（<strong>if条件语句不算块</strong>） <ul><li>try/catch：catch会创建一个块作用域</li><li>let、const</li></ul></li></ul><p><strong>总结：任何声明在某个作用域内的变量，都将<code>附属于这个作用域</code></strong></p><h3 id="提升"><a class="header-anchor" href="#提升" aria-hidden="true">#</a> 提升</h3><p>引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来，<a href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F">词法作用域</a>核心内容（<strong>针对当前作用域</strong>）</p><p>函数优先：函数会首先被提升，然后才是变量（<strong>同名的函数声明和变量声明不提升规则方式进行覆盖</strong>）</p><h3 id="作用域闭包"><a class="header-anchor" href="#作用域闭包" aria-hidden="true">#</a> 作用域闭包</h3><p>启示：<strong>JavaScript中闭包无所不在，你只需要能够识别并拥抱它</strong></p><p><code>在自己定义的词法作用域以外的地方执行，此时该作用域并未被销毁</code></p><h2 id="this和对象原型"><a class="header-anchor" href="#this和对象原型" aria-hidden="true">#</a> this和对象原型</h2>',25);r.render=function(i,a,r,t,n,d){return l(),e("div",null,[o])};export default r;export{a as __pageData};
